From c2766777108f9db66046700381fc2df3a92c9792 Mon Sep 17 00:00:00 2001
From: Han Gao <gaohan@iscas.ac.cn>
Date: Tue, 4 Jun 2024 17:19:05 +0800
Subject: [PATCH 1/7] sync: sync eswin code

Signed-off-by: Han Gao <gaohan@iscas.ac.cn>
---
 Makefile                          |    3 +-
 configure                         |  171 +-
 fftools/ffmpeg.h                  |    2 +
 fftools/ffmpeg_es.c               |   73 +
 fftools/ffmpeg_opt.c              |    8 +-
 fftools/ffplay.c                  |   14 +-
 libavcodec/Makefile               |   22 +
 libavcodec/allcodecs.c            |   24 +
 libavcodec/es_audio_dec.c         |  276 ++
 libavcodec/es_audio_enc.c         |  346 +++
 libavcodec/es_codec_private.h     |   60 +
 libavcodec/es_common.c            |  359 +++
 libavcodec/es_common.h            |  134 +
 libavcodec/es_jpeg_decode.c       | 2453 +++++++++++++++++
 libavcodec/es_jpeg_decode.h       |  399 +++
 libavcodec/es_jpegdec.c           |  507 ++++
 libavcodec/es_jpegenc.c           | 2621 ++++++++++++++++++
 libavcodec/es_jpegenc.h           |  412 +++
 libavcodec/esdec_common.c         |  292 ++
 libavcodec/esdec_common.h         |   71 +
 libavcodec/esdec_internal.c       |  985 +++++++
 libavcodec/esdec_internal.h       |   47 +
 libavcodec/esdec_wrapper.c        |  102 +
 libavcodec/esdec_wrapper.h        |   13 +
 libavcodec/esdecapi.c             | 1189 +++++++++
 libavcodec/esdecapi.h             |  105 +
 libavcodec/esdecbuffer.c          |  731 +++++
 libavcodec/esdecbuffer.h          |  135 +
 libavcodec/esdecode.c             |  448 ++++
 libavcodec/esenc_common.c         |  325 +++
 libavcodec/esenc_common.h         |   96 +
 libavcodec/esenc_h26x.c           |  445 ++++
 libavcodec/esenc_vid.c            | 4120 +++++++++++++++++++++++++++++
 libavcodec/esenc_vid.h            |  688 +++++
 libavcodec/esenc_vid_buffer.c     |  335 +++
 libavcodec/esenc_vid_buffer.h     |   53 +
 libavcodec/esenc_vid_internal.c   | 1341 ++++++++++
 libavcodec/esenc_vid_internal.h   |   64 +
 libavcodec/esjdecapi.c            | 2252 ++++++++++++++++
 libavcodec/esjdecapi.h            |  179 ++
 libavcodec/esjdecode.c            |  383 +++
 libavcodec/eslog.h                |   30 +
 libavcodec/esqueue.c              |  439 +++
 libavcodec/esqueue.h              |   56 +
 libavcodec/hwconfig.h             |    2 +
 libavfilter/Makefile              |    1 +
 libavfilter/allfilters.c          |    2 +
 libavfilter/dnn/Makefile          |    1 +
 libavfilter/dnn/dnn_backend_umd.c |  741 ++++++
 libavfilter/dnn/dnn_backend_umd.h |   40 +
 libavfilter/dnn/dnn_interface.c   |   13 +
 libavfilter/dnn_interface.h       |    2 +-
 libavfilter/esvfbuffer.c          |  504 ++++
 libavfilter/esvfbuffer.h          |   71 +
 libavfilter/esvfcommon.c          |  442 ++++
 libavfilter/esvfcommon.h          |  147 +
 libavfilter/esvfqueue.c           |  230 ++
 libavfilter/esvfqueue.h           |   28 +
 libavfilter/vf_convert_es.c       | 1234 +++++++++
 libavfilter/vf_derain.c           |    3 +
 libavfilter/vf_dnn_classify.c     |    3 +
 libavfilter/vf_dnn_detect.c       |    3 +
 libavfilter/vf_dnn_processing.c   |   70 +
 libavformat/aviobuf.c             |    6 +
 libavutil/Makefile                |    5 +
 libavutil/hwcontext.c             |    4 +
 libavutil/hwcontext.h             |    1 +
 libavutil/hwcontext_es.c          |  299 +++
 libavutil/hwcontext_es.h          |   90 +
 libavutil/hwcontext_internal.h    |    1 +
 libavutil/pixdesc.c               |  114 +
 libavutil/pixfmt.h                |   14 +
 72 files changed, 26864 insertions(+), 15 deletions(-)
 create mode 100644 fftools/ffmpeg_es.c
 create mode 100644 libavcodec/es_audio_dec.c
 create mode 100644 libavcodec/es_audio_enc.c
 create mode 100644 libavcodec/es_codec_private.h
 create mode 100644 libavcodec/es_common.c
 create mode 100644 libavcodec/es_common.h
 create mode 100644 libavcodec/es_jpeg_decode.c
 create mode 100644 libavcodec/es_jpeg_decode.h
 create mode 100644 libavcodec/es_jpegdec.c
 create mode 100644 libavcodec/es_jpegenc.c
 create mode 100644 libavcodec/es_jpegenc.h
 create mode 100644 libavcodec/esdec_common.c
 create mode 100644 libavcodec/esdec_common.h
 create mode 100644 libavcodec/esdec_internal.c
 create mode 100644 libavcodec/esdec_internal.h
 create mode 100644 libavcodec/esdec_wrapper.c
 create mode 100644 libavcodec/esdec_wrapper.h
 create mode 100644 libavcodec/esdecapi.c
 create mode 100644 libavcodec/esdecapi.h
 create mode 100644 libavcodec/esdecbuffer.c
 create mode 100644 libavcodec/esdecbuffer.h
 create mode 100644 libavcodec/esdecode.c
 create mode 100644 libavcodec/esenc_common.c
 create mode 100644 libavcodec/esenc_common.h
 create mode 100644 libavcodec/esenc_h26x.c
 create mode 100644 libavcodec/esenc_vid.c
 create mode 100644 libavcodec/esenc_vid.h
 create mode 100644 libavcodec/esenc_vid_buffer.c
 create mode 100644 libavcodec/esenc_vid_buffer.h
 create mode 100644 libavcodec/esenc_vid_internal.c
 create mode 100644 libavcodec/esenc_vid_internal.h
 create mode 100644 libavcodec/esjdecapi.c
 create mode 100644 libavcodec/esjdecapi.h
 create mode 100644 libavcodec/esjdecode.c
 create mode 100644 libavcodec/eslog.h
 create mode 100644 libavcodec/esqueue.c
 create mode 100644 libavcodec/esqueue.h
 create mode 100644 libavfilter/dnn/dnn_backend_umd.c
 create mode 100644 libavfilter/dnn/dnn_backend_umd.h
 create mode 100644 libavfilter/esvfbuffer.c
 create mode 100644 libavfilter/esvfbuffer.h
 create mode 100644 libavfilter/esvfcommon.c
 create mode 100644 libavfilter/esvfcommon.h
 create mode 100644 libavfilter/esvfqueue.c
 create mode 100644 libavfilter/esvfqueue.h
 create mode 100644 libavfilter/vf_convert_es.c
 create mode 100644 libavutil/hwcontext_es.c
 create mode 100644 libavutil/hwcontext_es.h

diff --git a/Makefile b/Makefile
index 61f79e27ae..130c4153b7 100644
--- a/Makefile
+++ b/Makefile
@@ -128,7 +128,8 @@ else
 endif
 
 %$(PROGSSUF)_g$(EXESUF): $(FF_DEP_LIBS)
-	$(LD) $(LDFLAGS) $(LDEXEFLAGS) $(LD_O) $(OBJS-$*) $(FF_EXTRALIBS)
+	echo "$(LD) $(LDFLAGS) $(LDEXEFLAGS) $(LD_O) $(OBJS-$*) $(FF_EXTRALIBS)"
+	$(LD) $(LDFLAGS) $(LDEXEFLAGS) $(LD_O) $(OBJS-$*) -Xlinker "-(" $(FF_EXTRALIBS) -Xlinker "-)"
 
 VERSION_SH  = $(SRC_PATH)/ffbuild/version.sh
 GIT_LOG     = $(SRC_PATH)/.git/logs/HEAD
diff --git a/configure b/configure
index ba5793b2ff..2e8eaf963f 100755
--- a/configure
+++ b/configure
@@ -231,6 +231,14 @@ External library support:
   --enable-libdc1394       enable IIDC-1394 grabbing using libdc1394
                            and libraw1394 [no]
   --enable-libfdk-aac      enable AAC de/encoding via libfdk-aac [no]
+  --enable-es-aac          enable AAC de/encoding via es_codec [no]
+  --enable-es-mp3          enable MP3 de/encoding via es_codec [no]
+  --enable-es-amrnb        enable amrnb de/encoding via es_codec [no]
+  --enable-es-amrwb        enable amrwb de/encoding via es_codec [no]
+  --enable-es-g711alaw     enable amrnb de/encoding via es_codec [no]
+  --enable-es-g711mulaw    enable amrwb de/encoding via es_codec [no]
+  --enable-es-g722         enable amrnb de/encoding via es_codec [no]
+  --enable-es-g726         enable amrwb de/encoding via es_codec [no]
   --enable-libflite        enable flite (voice synthesis) support via libflite [no]
   --enable-libfontconfig   enable libfontconfig, useful for drawtext filter [no]
   --enable-libfreetype     enable libfreetype, needed for drawtext filter [no]
@@ -329,6 +337,13 @@ External library support:
   --disable-vulkan         disable Vulkan code [autodetect]
   --disable-xlib           disable xlib [autodetect]
   --disable-zlib           disable zlib [autodetect]
+  --enable-esvd            enable es video decoder [no]
+  --enable-esve            enable es video encoder [no]
+  --enable-esjd            enable es jpeg decoder [no]
+  --enable-esje            enable es jpeg encoder [no]
+  --enable-convert_es      enable es convert_es filter [no]
+  --enable-esumd           enable es umd as a DNN module backend
+                           for DNN based filters like sr [no]
 
   The following libraries provide various hardware acceleration features:
   --disable-amf            disable AMF video encoding code [autodetect]
@@ -1787,7 +1802,22 @@ EXTERNAL_LIBRARY_GPL_LIST="
 EXTERNAL_LIBRARY_NONFREE_LIST="
     decklink
     libfdk_aac
+    es_aac
+    es_mp3
+    es_amrnb
+    es_amrwb
+    es_g711alaw
+    es_g711mulaw
+    es_g722
+    es_g726
     libtls
+#ifdef ESW_FF_ENHANCEMENT
+    esvd
+    esjd
+    esje
+    esve
+    convert_es
+#endif
 "
 
 EXTERNAL_LIBRARY_VERSION3_LIST="
@@ -1885,6 +1915,7 @@ EXTERNAL_LIBRARY_LIST="
     openssl
     pocketsphinx
     vapoursynth
+    esumd
 "
 
 HWACCEL_AUTODETECT_LIBRARY_LIST="
@@ -2518,6 +2549,11 @@ CONFIG_EXTRA="
     vp8dsp
     wma_freqs
     wmv2dsp
+#ifdef ESW_FF_ENHANCEMENT
+    es_codec
+    es_decode
+    es_video_decoder
+#endif
 "
 
 CMDLINE_SELECT="
@@ -3250,6 +3286,20 @@ vp9_qsv_encoder_select="qsvenc"
 vp9_v4l2m2m_decoder_deps="v4l2_m2m vp9_v4l2_m2m"
 wmv3_crystalhd_decoder_select="crystalhd"
 av1_qsv_decoder_select="qsvdec"
+#ifdef ESW_FF_ENHANCEMENT
+h264_es_decoder_deps="esvd"
+h264_es_decoder_select="es_video_decoder es_decode es_codec"
+hevc_es_decoder_deps="esvd"
+hevc_es_decoder_select="es_video_decoder es_decode es_codec"
+h264_es_encoder_deps="esve"
+h264_es_encoder_select="esve es_codec"
+h265_es_encoder_deps="esve"
+h265_es_encoder_select="esve es_codec"
+jpeg_es_encoder_deps="esje"
+jpeg_es_encoder_select="es_codec"
+jpeg_es_decoder_deps="esjd"
+jpeg_es_decoder_select="es_decode es_codec"
+#endif
 
 # parsers
 aac_parser_select="adts_header mpeg4audio"
@@ -3332,6 +3382,36 @@ libdavs2_decoder_deps="libdavs2"
 libdavs2_decoder_select="avs2_parser"
 libfdk_aac_decoder_deps="libfdk_aac"
 libfdk_aac_encoder_deps="libfdk_aac"
+es_aac_decoder_extralibs="-les_codec"
+es_aac_decoder_deps="es_aac"
+es_aac_encoder_extralibs="-les_codec"
+es_aac_encoder_deps="es_aac"
+es_mp3_decoder_extralibs="-les_codec"
+es_mp3_decoder_deps="es_mp3"
+es_amrnb_decoder_extralibs="-les_codec"
+es_amrnb_decoder_deps="es_amrnb"
+es_amrnb_encoder_extralibs="-les_codec"
+es_amrnb_encoder_deps="es_amrwb"
+es_amrwb_decoder_extralibs="-les_codec"
+es_amrwb_decoder_deps="es_amrwb"
+es_amrwb_encoder_extralibs="-les_codec"
+es_amrwb_encoder_deps="es_amrwb"
+es_g711alaw_decoder_extralibs="-les_codec"
+es_g711alaw_decoder_deps="es_g711alaw"
+es_g711alaw_encoder_extralibs="-les_codec"
+es_g711alaw_encoder_deps="es_g711alaw"
+es_g711mulaw_decoder_extralibs="-les_codec"
+es_g711mulaw_decoder_deps="es_g711mulaw"
+es_g711mulaw_encoder_extralibs="-les_codec"
+es_g711mulaw_encoder_deps="es_g711mulaw"
+es_g722_decoder_extralibs="-les_codec"
+es_g722_decoder_deps="es_g722"
+es_g722_encoder_extralibs="-les_codec"
+es_g722_encoder_deps="es_g722"
+es_g726_decoder_extralibs="-les_codec"
+es_g726_decoder_deps="es_g726"
+es_g726_encoder_extralibs="-les_codec"
+es_g726_encoder_deps="es_g726"
 libfdk_aac_encoder_select="audio_frame_queue"
 libgme_demuxer_deps="libgme"
 libgsm_decoder_deps="libgsm"
@@ -3763,6 +3843,7 @@ xfade_opencl_filter_deps="opencl"
 yadif_cuda_filter_deps="ffnvcodec"
 yadif_cuda_filter_deps_any="cuda_nvcc cuda_llvm"
 yadif_videotoolbox_filter_deps="metal corevideo videotoolbox"
+convert_es_filter_deps="convert_es"
 
 # examples
 avio_list_dir_deps="avformat avutil"
@@ -5643,7 +5724,7 @@ case $target_os in
         enabled x86_64 && objformat="win64" || objformat="win32"
         enable dos_paths
         enabled shared && ! enabled small && test_cmd $windres --version && enable gnu_windres
-        add_cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
+        add_cppflags -D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=600
         ;;
     *-dos|freedos|opendos)
         network_extralibs="-lsocket"
@@ -5741,10 +5822,10 @@ probe_libc(){
     # uclibc defines __GLIBC__, so it needs to be checked before glibc.
     if test_${pfx}cpp_condition features.h "defined __UCLIBC__"; then
         eval ${pfx}libc_type=uclibc
-        add_${pfx}cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
+        add_${pfx}cppflags -D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=600
     elif test_${pfx}cpp_condition features.h "defined __GLIBC__"; then
         eval ${pfx}libc_type=glibc
-        add_${pfx}cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
+        add_${pfx}cppflags -D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=600
     # MinGW headers can be installed on Cygwin, so check for newlib first.
     elif test_${pfx}cpp_condition newlib.h "defined _NEWLIB_VERSION"; then
         eval ${pfx}libc_type=newlib
@@ -5761,7 +5842,7 @@ probe_libc(){
             add_${pfx}cppflags -D__printf__=__gnu_printf__
         test_${pfx}cpp_condition windows.h "!defined(_WIN32_WINNT) || _WIN32_WINNT < 0x0600" &&
             add_${pfx}cppflags -D_WIN32_WINNT=0x0600
-        add_${pfx}cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
+        add_${pfx}cppflags -D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=600
     elif test_${pfx}cpp_condition _mingw.h "defined __MINGW_VERSION"  ||
          test_${pfx}cpp_condition _mingw.h "defined __MINGW32_VERSION"; then
         eval ${pfx}libc_type=mingw32
@@ -5775,7 +5856,7 @@ probe_libc(){
             add_${pfx}cppflags -D_WIN32_WINNT=0x0600
         eval test \$${pfx_no_}cc_type = "gcc" &&
             add_${pfx}cppflags -D__printf__=__gnu_printf__
-        add_${pfx}cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
+        add_${pfx}cppflags -D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=600
     elif test_${pfx}cpp_condition crtversion.h "defined _VC_CRT_MAJOR_VERSION"; then
         eval ${pfx}libc_type=msvcrt
         if test_${pfx}cpp_condition crtversion.h "_VC_CRT_MAJOR_VERSION < 14"; then
@@ -5829,7 +5910,7 @@ EOF
 #include <time.h>
 void *v = localtime_r;
 EOF
-test "$?" != 0 && test_${pfx}cc -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600 <<EOF && add_${pfx}cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
+test "$?" != 0 && test_${pfx}cc -D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=600 <<EOF && add_${pfx}cppflags -D_POSIX_C_SOURCE=200809L -D_XOPEN_SOURCE=600
 #include <time.h>
 void *v = localtime_r;
 EOF
@@ -6545,6 +6626,14 @@ enabled libfdk_aac        && { check_pkg_config libfdk_aac fdk-aac "fdk-aac/aace
                                { require libfdk_aac fdk-aac/aacenc_lib.h aacEncOpen -lfdk-aac &&
                                  warn "using libfdk without pkg-config"; } }
 flite_extralibs="-lflite_cmu_time_awb -lflite_cmu_us_awb -lflite_cmu_us_kal -lflite_cmu_us_kal16 -lflite_cmu_us_rms -lflite_cmu_us_slt -lflite_usenglish -lflite_cmulex -lflite"
+enabled es_aac            && require eswin_codec codec_api.h es_aenc_create -les_codec
+enabled es_mp3            && require eswin_codec codec_api.h es_aenc_create -les_codec
+enabled es_amrnb          && require eswin_codec codec_api.h es_aenc_create -les_codec
+enabled es_amrwb          && require eswin_codec codec_api.h es_aenc_create -les_codec
+enabled es_g711alaw       && require eswin_codec codec_api.h es_aenc_create -les_codec
+enabled es_g711mulaw      && require eswin_codec codec_api.h es_aenc_create -les_codec
+enabled es_g722           && require eswin_codec codec_api.h es_aenc_create -les_codec
+enabled es_g726           && require eswin_codec codec_api.h es_aenc_create -les_codec
 enabled libflite          && require libflite "flite/flite.h" flite_init $flite_extralibs
 enabled fontconfig        && enable libfontconfig
 enabled libfontconfig     && require_pkg_config libfontconfig fontconfig "fontconfig/fontconfig.h" FcInit
@@ -6737,6 +6826,74 @@ enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/r
                              }
 enabled vapoursynth       && require_pkg_config vapoursynth "vapoursynth-script >= 42" VSScript.h vsscript_init
 
+enabled esvd               && {
+
+    add_cflags -DESW_FF_ENHANCEMENT -DFIFO_DATATYPE=void* -DUSE_EXTERNAL_BUFFER -DUSE_OUTPUT_RELEASE -D_FILE_OFFSET_BITS=64 -D_DEFAULT_SOURCE -D_LARGEFILE64_SOURCE -DALWAYS_OUTPUT_REF -DUSE_NON_BLOCKING -DGET_FREE_BUFFER_NON_BLOCK -DGET_FREE_BUFFER_NON_BLOCK -DGET_OUTPUT_BUFFER_NON_BLOCK -DSKIP_OPENB_FRAME -DENABLE_DPB_RECOVER -D_LARGEFILE64_SOURCE -DEXPIRY_DATE=1 -D_RANGE_CHECK -D_ERROR_PRINT -DDEC_X170_OUTPUT_FORMAT=0 -DDEC_X170_TIMEOUT_LENGTH=-1 -DREORDER_ERROR_FIX -DCLEAR_HDRINFO_IN_SEEK -DNEW_MEM_ALLOC -DDWL_USE_DEC_IRQ -DENABLE_HUGEPAGE -DDEC_TRANS_ENABLE -DSUPPORT_CACHE -DSUPPORT_L2CACHE -DDRV_NEW_ARCH -DNEW_MEM_ALLOC -DCTBRC_STRENGTH -DFB_PERFORMANCE_STATIC -DFPGA -DDRV_NEW_ARCH
+
+    enabled h264_es_decoder && {
+        log check_pkg_config h264_es_decoder
+    } || disable h264_es_decoder
+    enabled hevc_es_decoder && {
+        log check_pkg_config hevc_es_decoder
+    } || disable hevc_es_decoder
+
+    if disabled_all h264_es_decoder hevc_es_decoder ; then
+        die "video decoder enabled but no supported codecs found"
+    fi
+}
+
+enabled esve               && {
+
+    add_cflags  -DESW_FF_ENHANCEMENT -DFIFO_DATATYPE=void* -DUSE_EXTERNAL_BUFFER -DUSE_OUTPUT_RELEASE -D_FILE_OFFSET_BITS=64 -D_DEFAULT_SOURCE -D_LARGEFILE64_SOURCE -DALWAYS_OUTPUT_REF -DUSE_NON_BLOCKING -DGET_FREE_BUFFER_NON_BLOCK -DGET_FREE_BUFFER_NON_BLOCK -DGET_OUTPUT_BUFFER_NON_BLOCK -DSKIP_OPENB_FRAME -DENABLE_DPB_RECOVER -D_LARGEFILE64_SOURCE -DEXPIRY_DATE=1 -D_RANGE_CHECK -D_ERROR_PRINT -DDEC_X170_OUTPUT_FORMAT=0 -DDEC_X170_TIMEOUT_LENGTH=-1 -DREORDER_ERROR_FIX -DCLEAR_HDRINFO_IN_SEEK -DNEW_MEM_ALLOC -DDWL_USE_DEC_IRQ -DENABLE_HUGEPAGE -DDEC_TRANS_ENABLE -DSUPPORT_CACHE -DSUPPORT_L2CACHE -DDRV_NEW_ARCH -DNEW_MEM_ALLOC -DCTBRC_STRENGTH -DFB_PERFORMANCE_STATIC -DFPGA -DDRV_NEW_ARCH
+
+    enabled h264_es_encoder && {
+        log check_pkg_config h264_es_encoder
+    } || disable h264_es_encoder
+
+    enabled h265_es_encoder  && {
+        log check_pkg_config h265_es_encoder
+    } || disable h265_es_encoder
+
+    if disabled_all h264_es_encoder h265_es_encoder; then
+        die "esve enabled but no supported codecs found"
+    fi
+}
+
+enabled esjd && {
+    add_cflags -DESW_FF_ENHANCEMENT -DFIFO_DATATYPE=void* -DUSE_EXTERNAL_BUFFER -DUSE_OUTPUT_RELEASE -D_FILE_OFFSET_BITS=64 -D_DEFAULT_SOURCE -D_LARGEFILE64_SOURCE -DALWAYS_OUTPUT_REF -DUSE_NON_BLOCKING -DGET_FREE_BUFFER_NON_BLOCK -DGET_FREE_BUFFER_NON_BLOCK -DGET_OUTPUT_BUFFER_NON_BLOCK -DSKIP_OPENB_FRAME -DENABLE_DPB_RECOVER -D_LARGEFILE64_SOURCE -DEXPIRY_DATE=1 -D_RANGE_CHECK -D_ERROR_PRINT -DDEC_X170_OUTPUT_FORMAT=0 -DDEC_X170_TIMEOUT_LENGTH=-1 -DREORDER_ERROR_FIX -DCLEAR_HDRINFO_IN_SEEK -DNEW_MEM_ALLOC -DDWL_USE_DEC_IRQ -fpic -DENABLE_HUGEPAGE -DDEC_TRANS_ENABLE -DSUPPORT_CACHE -DSUPPORT_L2CACHE -DDRV_NEW_ARCH -DNEW_MEM_ALLOC -DCTBRC_STRENGTH -DFB_PERFORMANCE_STATIC -DFPGA -DDRV_NEW_ARCH
+
+    enabled jpeg_es_decoder  && {
+        log check_pkg_config jpeg_es_decoder
+    } || disable jpeg_es_decoder
+
+    if disabled_all jpeg_es_decoder; then
+        die "esjd enabled but no supported jpegdecoders found"
+    fi
+}
+
+enabled convert_es && {
+    add_cflags -DESW_FF_ENHANCEMENT
+
+    enabled convert_es_filter  && {
+        log check_pkg_config convert_es_filter
+    } || disable convert_es_filter
+
+    if disabled_all convert_es_filter; then
+        die "convert_es_filter enabled but no supported filter found"
+    fi
+}
+
+enabled esje && {
+    add_cflags -DESW_FF_ENHANCEMENT -DFIFO_DATATYPE=void* -DUSE_EXTERNAL_BUFFER -DUSE_OUTPUT_RELEASE -D_FILE_OFFSET_BITS=64 -D_DEFAULT_SOURCE -D_LARGEFILE64_SOURCE -DALWAYS_OUTPUT_REF -DUSE_NON_BLOCKING -DGET_FREE_BUFFER_NON_BLOCK -DGET_FREE_BUFFER_NON_BLOCK -DGET_OUTPUT_BUFFER_NON_BLOCK -DSKIP_OPENB_FRAME -DENABLE_DPB_RECOVER -D_LARGEFILE64_SOURCE -DEXPIRY_DATE=1 -D_RANGE_CHECK -D_ERROR_PRINT -DDEC_X170_OUTPUT_FORMAT=0 -DDEC_X170_TIMEOUT_LENGTH=-1 -DREORDER_ERROR_FIX -DCLEAR_HDRINFO_IN_SEEK -DNEW_MEM_ALLOC -DDWL_USE_DEC_IRQ -fpic -DENABLE_HUGEPAGE -DDEC_TRANS_ENABLE -DSUPPORT_CACHE -DSUPPORT_L2CACHE -DDRV_NEW_ARCH -DNEW_MEM_ALLOC -DCTBRC_STRENGTH -DFB_PERFORMANCE_STATIC -DFPGA -DDRV_NEW_ARCH
+
+    enabled jpeg_es_encoder && {
+    log check_pkg_config jpeg_es_encoder
+    } || disable jpeg_es_encoder
+
+    if disabled_all jpeg_es_encoder; then
+        die "esje enabled but no supported jpegencoders found"
+    fi
+}
 
 if enabled gcrypt; then
     GCRYPT_CONFIG="${cross_prefix}libgcrypt-config"
@@ -6752,7 +6909,7 @@ if enabled gcrypt; then
 fi
 
 if enabled sdl2; then
-    SDL2_CONFIG="${cross_prefix}sdl2-config"
+    SDL2_CONFIG="${sysroot}/usr/bin/sdl2-config"
     test_pkg_config sdl2 "sdl2 >= 2.0.1 sdl2 < 3.0.0" SDL_events.h SDL_PollEvent
     if disabled sdl2 && "${SDL2_CONFIG}" --version > /dev/null 2>&1; then
         sdl2_cflags=$("${SDL2_CONFIG}" --cflags)
diff --git a/fftools/ffmpeg.h b/fftools/ffmpeg.h
index 391a35cf50..db08724d09 100644
--- a/fftools/ffmpeg.h
+++ b/fftools/ffmpeg.h
@@ -62,6 +62,7 @@ enum HWAccelID {
     HWACCEL_NONE = 0,
     HWACCEL_AUTO,
     HWACCEL_GENERIC,
+    HWACCEL_ES,
 };
 
 typedef struct HWDevice {
@@ -685,6 +686,7 @@ int ffmpeg_parse_options(int argc, char **argv);
 
 int videotoolbox_init(AVCodecContext *s);
 int qsv_init(AVCodecContext *s);
+int es_init(AVCodecContext *s);
 
 HWDevice *hw_device_get_by_name(const char *name);
 int hw_device_init_from_string(const char *arg, HWDevice **dev);
diff --git a/fftools/ffmpeg_es.c b/fftools/ffmpeg_es.c
new file mode 100644
index 0000000000..0102ad052f
--- /dev/null
+++ b/fftools/ffmpeg_es.c
@@ -0,0 +1,73 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/hwcontext.h"
+#include "libavutil/pixdesc.h"
+
+#include "ffmpeg.h"
+
+static void es_uninit(AVCodecContext *avctx)
+{
+    InputStream *ist = avctx->opaque;
+    av_buffer_unref(&ist->hw_frames_ctx);
+}
+
+int es_init(AVCodecContext *avctx)
+{
+    InputStream *ist = avctx->opaque;
+    AVHWFramesContext *frames_ctx;
+    int ret;
+
+    av_log(avctx, AV_LOG_VERBOSE, "Initializing esw decode hwaccel\n");
+
+    if (!hw_device_ctx) {
+        ret = av_hwdevice_ctx_create(&hw_device_ctx, AV_HWDEVICE_TYPE_ES,
+                                     ist->hwaccel_device, NULL, 0);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Error creating a ESW device\n");
+            return ret;
+        }
+    }
+
+    av_buffer_unref(&ist->hw_frames_ctx);
+    ist->hw_frames_ctx = av_hwframe_ctx_alloc(hw_device_ctx);
+    if (!ist->hw_frames_ctx) {
+        av_log(avctx, AV_LOG_ERROR, "Error creating a ESW frames context\n");
+        return AVERROR(ENOMEM);
+    }
+
+    frames_ctx = (AVHWFramesContext*)ist->hw_frames_ctx->data;
+
+    frames_ctx->format = AV_PIX_FMT_ES;
+    frames_ctx->sw_format = avctx->sw_pix_fmt;
+    frames_ctx->width = avctx->width;
+    frames_ctx->height = avctx->height;
+
+    av_log(avctx, AV_LOG_INFO, "Initializing ESW frames context: sw_format = %s, width = %d, height = %d\n",
+           av_get_pix_fmt_name(frames_ctx->sw_format), frames_ctx->width, frames_ctx->height);
+
+    ret = av_hwframe_ctx_init(ist->hw_frames_ctx);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Error initializing a ESW frame pool\n");
+        return ret;
+    }
+
+    ist->hwaccel_uninit = es_uninit;
+
+    return 0;
+}
diff --git a/fftools/ffmpeg_opt.c b/fftools/ffmpeg_opt.c
index 6e18a4a23e..8a7b58fe74 100644
--- a/fftools/ffmpeg_opt.c
+++ b/fftools/ffmpeg_opt.c
@@ -985,7 +985,13 @@ static void add_input_streams(OptionsContext *o, AVFormatContext *ic)
                     "with old commandlines. This behaviour is DEPRECATED and will be removed "
                     "in the future. Please explicitly set \"-hwaccel_output_format qsv\".\n");
                 ist->hwaccel_output_format = AV_PIX_FMT_QSV;
-            } else if (hwaccel_output_format) {
+            } else if (!hwaccel_output_format && hwaccel && !strcmp(hwaccel, "es")) {
+                av_log(NULL, AV_LOG_WARNING,
+                    "WARNING: defaulting hwaccel_output_format to es for compatibility "
+                    "with old commandlines. This behaviour is DEPRECATED and will be removed "
+                    "in the future. Please explicitly set \"-hwaccel_output_format es\".\n");
+                ist->hwaccel_output_format = AV_PIX_FMT_ES;
+            }else if (hwaccel_output_format) {
                 ist->hwaccel_output_format = av_get_pix_fmt(hwaccel_output_format);
                 if (ist->hwaccel_output_format == AV_PIX_FMT_NONE) {
                     av_log(NULL, AV_LOG_FATAL, "Unrecognised hwaccel output "
diff --git a/fftools/ffplay.c b/fftools/ffplay.c
index 9242047f5c..1011415fdb 100644
--- a/fftools/ffplay.c
+++ b/fftools/ffplay.c
@@ -390,6 +390,7 @@ static const struct TextureFormatEntry {
     { AV_PIX_FMT_YUV420P,        SDL_PIXELFORMAT_IYUV },
     { AV_PIX_FMT_YUYV422,        SDL_PIXELFORMAT_YUY2 },
     { AV_PIX_FMT_UYVY422,        SDL_PIXELFORMAT_UYVY },
+    { AV_PIX_FMT_NV12,           SDL_PIXELFORMAT_NV12},
     { AV_PIX_FMT_NONE,           SDL_PIXELFORMAT_UNKNOWN },
 };
 
@@ -2503,7 +2504,7 @@ static int audio_open(void *opaque, AVChannelLayout *wanted_channel_layout, int
     }
     while (next_sample_rate_idx && next_sample_rates[next_sample_rate_idx] >= wanted_spec.freq)
         next_sample_rate_idx--;
-    wanted_spec.format = AUDIO_S16SYS;
+    wanted_spec.format = AUDIO_S32SYS;
     wanted_spec.silence = 0;
     wanted_spec.samples = FFMAX(SDL_AUDIO_MIN_BUFFER_SIZE, 2 << av_log2(wanted_spec.freq / SDL_AUDIO_MAX_CALLBACKS_PER_SEC));
     wanted_spec.callback = sdl_audio_callback;
@@ -2524,9 +2525,9 @@ static int audio_open(void *opaque, AVChannelLayout *wanted_channel_layout, int
         av_channel_layout_default(wanted_channel_layout, wanted_spec.channels);
     }
     if (spec.format != AUDIO_S16SYS) {
-        av_log(NULL, AV_LOG_ERROR,
+        av_log(NULL, AV_LOG_WARNING,
                "SDL advised audio format %d is not supported!\n", spec.format);
-        return -1;
+        //return -1;
     }
     if (spec.channels != wanted_spec.channels) {
         av_channel_layout_uninit(wanted_channel_layout);
@@ -2538,7 +2539,7 @@ static int audio_open(void *opaque, AVChannelLayout *wanted_channel_layout, int
         }
     }
 
-    audio_hw_params->fmt = AV_SAMPLE_FMT_S16;
+    audio_hw_params->fmt = AV_SAMPLE_FMT_S32;
     audio_hw_params->freq = spec.freq;
     if (av_channel_layout_copy(&audio_hw_params->ch_layout, wanted_channel_layout) < 0)
         return -1;
@@ -3332,6 +3333,7 @@ static void event_loop(VideoState *cur_stream)
                 toggle_audio_display(cur_stream);
 #endif
                 break;
+/*
             case SDLK_PAGEUP:
                 if (cur_stream->ic->nb_chapters <= 1) {
                     incr = 600.0;
@@ -3382,6 +3384,7 @@ static void event_loop(VideoState *cur_stream)
                         stream_seek(cur_stream, (int64_t)(pos * AV_TIME_BASE), (int64_t)(incr * AV_TIME_BASE), 0);
                     }
                 break;
+*/
             default:
                 break;
             }
@@ -3416,6 +3419,7 @@ static void event_loop(VideoState *cur_stream)
                     break;
                 x = event.motion.x;
             }
+            /*
                 if (seek_by_bytes || cur_stream->ic->duration <= 0) {
                     uint64_t size =  avio_size(cur_stream->ic->pb);
                     stream_seek(cur_stream, size*x/cur_stream->width, 0, 1);
@@ -3439,7 +3443,7 @@ static void event_loop(VideoState *cur_stream)
                     if (cur_stream->ic->start_time != AV_NOPTS_VALUE)
                         ts += cur_stream->ic->start_time;
                     stream_seek(cur_stream, ts, 0, 0);
-                }
+                }*/
             break;
         case SDL_WINDOWEVENT:
             switch (event.window.event) {
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 457ec58377..ceddb1b5d6 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -26,6 +26,7 @@ HEADERS = ac3_parser.h                                                  \
           videotoolbox.h                                                \
           vorbis_parser.h                                               \
           xvmc.h                                                        \
+          es_codec_private.h                                            \
 
 OBJS = ac3_parser.o                                                     \
        adts_parser.o                                                    \
@@ -1062,6 +1063,21 @@ OBJS-$(CONFIG_LIBDAV1D_DECODER)           += libdav1d.o
 OBJS-$(CONFIG_LIBDAVS2_DECODER)           += libdavs2.o
 OBJS-$(CONFIG_LIBFDK_AAC_DECODER)         += libfdk-aacdec.o
 OBJS-$(CONFIG_LIBFDK_AAC_ENCODER)         += libfdk-aacenc.o
+OBJS-$(CONFIG_ES_AAC_DECODER)             += es_audio_dec.o
+OBJS-$(CONFIG_ES_AAC_ENCODER)             += es_audio_enc.o
+OBJS-$(CONFIG_ES_MP3_DECODER)             += es_audio_dec.o
+OBJS-$(CONFIG_ES_AMRNB_DECODER)           += es_audio_dec.o
+OBJS-$(CONFIG_ES_AMRNB_ENCODER)           += es_audio_enc.o
+OBJS-$(CONFIG_ES_AMRWB_DECODER)           += es_audio_dec.o
+OBJS-$(CONFIG_ES_AMRWB_ENCODER)           += es_audio_enc.o
+OBJS-$(CONFIG_ES_G711ALAW_DECODER)        += es_audio_dec.o
+OBJS-$(CONFIG_ES_G711ALAW_ENCODER)        += es_audio_enc.o
+OBJS-$(CONFIG_ES_G711MULAW_DECODER)       += es_audio_dec.o
+OBJS-$(CONFIG_ES_G711MULAW_ENCODER)       += es_audio_enc.o
+OBJS-$(CONFIG_ES_G722_DECODER)            += es_audio_dec.o
+OBJS-$(CONFIG_ES_G722_ENCODER)            += es_audio_enc.o
+OBJS-$(CONFIG_ES_G726_DECODER)            += es_audio_dec.o
+OBJS-$(CONFIG_ES_G726_ENCODER)            += es_audio_enc.o
 OBJS-$(CONFIG_LIBGSM_DECODER)             += libgsmdec.o
 OBJS-$(CONFIG_LIBGSM_ENCODER)             += libgsmenc.o
 OBJS-$(CONFIG_LIBGSM_MS_DECODER)          += libgsmdec.o
@@ -1108,6 +1124,12 @@ OBJS-$(CONFIG_LIBXAVS_ENCODER)            += libxavs.o
 OBJS-$(CONFIG_LIBXAVS2_ENCODER)           += libxavs2.o
 OBJS-$(CONFIG_LIBXVID_ENCODER)            += libxvid.o
 OBJS-$(CONFIG_LIBZVBI_TELETEXT_DECODER)   += libzvbi-teletextdec.o ass.o
+OBJS-$(CONFIG_ES_CODEC)                   += es_common.o esqueue.o
+OBJS-$(CONFIG_ES_DECODE)                  += esdec_common.o esdec_wrapper.o esdecbuffer.o esdec_internal.o
+OBJS-$(CONFIG_ES_VIDEO_DECODER)           += esdecode.o esdecapi.o
+OBJS-$(CONFIG_ESVE)                       += esenc_h26x.o esenc_common.o esenc_vid.o esenc_vid_internal.o esenc_vid_buffer.o
+OBJS-$(CONFIG_JPEG_ES_ENCODER)            += es_jpegenc.o esenc_common.o
+OBJS-$(CONFIG_JPEG_ES_DECODER)            += esjdecode.o esjdecapi.o
 
 # parsers
 OBJS-$(CONFIG_AAC_LATM_PARSER)         += latm_parser.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index bdfc2f6f45..9c0cfb2e77 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -34,6 +34,15 @@
 #include "codec_id.h"
 #include "codec_internal.h"
 
+#ifdef ESW_FF_ENHANCEMENT
+extern const FFCodec ff_h264_es_decoder;
+extern const FFCodec ff_hevc_es_decoder;
+extern const FFCodec ff_h264_es_encoder;
+extern const FFCodec ff_h265_es_encoder;
+extern const FFCodec ff_jpeg_es_encoder;
+extern const FFCodec ff_jpeg_es_decoder;
+#endif
+
 extern const FFCodec ff_a64multi_encoder;
 extern const FFCodec ff_a64multi5_encoder;
 extern const FFCodec ff_aasc_decoder;
@@ -749,6 +758,21 @@ extern const FFCodec ff_libdav1d_decoder;
 extern const FFCodec ff_libdavs2_decoder;
 extern const FFCodec ff_libfdk_aac_encoder;
 extern const FFCodec ff_libfdk_aac_decoder;
+extern const FFCodec ff_es_aac_decoder;
+extern const FFCodec ff_es_aac_encoder;
+extern const FFCodec ff_es_mp3_decoder;
+extern const FFCodec ff_es_amrnb_decoder;
+extern const FFCodec ff_es_amrnb_encoder;
+extern const FFCodec ff_es_amrwb_decoder;
+extern const FFCodec ff_es_amrwb_encoder;
+extern const FFCodec ff_es_g711alaw_decoder;
+extern const FFCodec ff_es_g711alaw_encoder;
+extern const FFCodec ff_es_g711mulaw_decoder;
+extern const FFCodec ff_es_g711mulaw_encoder;
+extern const FFCodec ff_es_g722_decoder;
+extern const FFCodec ff_es_g722_encoder;
+extern const FFCodec ff_es_g726_decoder;
+extern const FFCodec ff_es_g726_encoder;
 extern const FFCodec ff_libgsm_encoder;
 extern const FFCodec ff_libgsm_decoder;
 extern const FFCodec ff_libgsm_ms_encoder;
diff --git a/libavcodec/es_audio_dec.c b/libavcodec/es_audio_dec.c
new file mode 100644
index 0000000000..043a7d6c2f
--- /dev/null
+++ b/libavcodec/es_audio_dec.c
@@ -0,0 +1,276 @@
+#include "libavutil/channel_layout.h"
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "avcodec.h"
+#include "codec_internal.h"
+#include "decode.h"
+#include "internal.h"
+#include "adp_amr.h"
+#include "adp_itut_gxx.h"
+#include "adp_aac.h"
+#include "codec_api.h"
+#include "CodecTypes.h"
+
+#define DEFAULT_G722_BIT_RATE       64000
+#define DEFAULT_G726_BIT_RATE       32000
+#define MAX_BUFFER_SIZE             16384
+#define MAX_STREAM_LEN              2048
+
+typedef struct ESADECContext {
+    const AVClass *class;
+    int chan_id;
+    int bit_rate;
+    char *buffer;
+    int buffer_size;
+    uint8_t stream[MAX_STREAM_LEN * 2];
+    uint32_t offset;
+    AVChannelLayout downmix_layout;
+} ESADECContext;
+
+static const AVOption options[] = {
+    { "bit_rate", "Set bit rate", offsetof(ESADECContext, bit_rate), AV_OPT_TYPE_INT,
+      {.i64 = 0}, 0, INT_MAX, AV_OPT_FLAG_DECODING_PARAM },
+    { NULL },
+};
+
+static es_codec_type convert_codec_id_to_type(enum AVCodecID codec_id)
+{
+    switch (codec_id) {
+        case AV_CODEC_ID_AAC:
+            return AAC;
+        case AV_CODEC_ID_MP3:
+        case AV_CODEC_ID_MP2:
+            return MP3;
+        case AV_CODEC_ID_PCM_ALAW:
+        case AV_CODEC_ID_PCM_MULAW:
+            return G711;
+        case AV_CODEC_ID_ADPCM_G722:
+            return G722;
+        case AV_CODEC_ID_ADPCM_G726:
+            return G726;
+        case AV_CODEC_ID_AMR_NB:
+        case AV_CODEC_ID_AMR_WB:
+            return AMR;
+        default:
+            return UNKNOW;
+    }
+}
+
+static void *get_audio_decoder_attr(AVCodecContext *avctx, enum AVCodecID codec_id)
+{
+    ESADECContext *s = (ESADECContext *)avctx->priv_data;
+    void *attr = NULL;
+
+    if (AV_CODEC_ID_AMR_NB == codec_id || AV_CODEC_ID_AMR_WB == codec_id) {
+        audio_amr_decoder_attr *amr_attr = av_mallocz(sizeof(audio_amr_decoder_attr));
+        if (amr_attr) {
+            amr_attr->is_wb = (AV_CODEC_ID_AMR_WB == codec_id) ? 1 : 0;
+            attr = amr_attr;
+        }
+    } else if (AV_CODEC_ID_PCM_ALAW == codec_id || AV_CODEC_ID_PCM_MULAW == codec_id) {
+        audio_g711_attr *g711_attr = av_mallocz(sizeof(audio_g711_attr));
+        if (g711_attr) {
+            g711_attr->type = (AV_CODEC_ID_PCM_ALAW == codec_id) ? ALAW : ULAW;
+            attr = g711_attr;
+        }
+    } else if (AV_CODEC_ID_ADPCM_G722 == codec_id) {
+        audio_g722_attr *g722_attr = av_mallocz(sizeof(audio_g722_attr));
+        if (g722_attr) {
+            g722_attr->bit_rate = (s->bit_rate == 0) ? DEFAULT_G722_BIT_RATE : s->bit_rate;
+            attr = g722_attr;
+        }
+    } else if (AV_CODEC_ID_ADPCM_G726 == codec_id) {
+        audio_g726_attr *g726_attr = av_mallocz(sizeof(audio_g726_attr));
+        if (g726_attr) {
+            g726_attr->bit_rate = (s->bit_rate == 0) ? DEFAULT_G726_BIT_RATE : s->bit_rate;
+            attr = g726_attr;
+        }
+    } else if (AV_CODEC_ID_AAC == codec_id) {
+        audio_aacdecoder_attr *aac_attr = av_mallocz(sizeof(audio_aacdecoder_attr));
+        if (aac_attr) {
+            aac_attr->output_format = 1;
+            aac_attr->profile = avctx->profile;
+            aac_attr->trans_type = AAC_TRANS_TYPE_ADTS;
+            attr = aac_attr;
+        }
+    }
+    return attr;
+}
+
+static av_cold int ff_es_adec_init(AVCodecContext *avctx)
+{
+    static int32_t chan = 1;
+
+    /* get codec type */
+    enum AVCodecID codec_id = avctx->codec_id;
+    es_codec_type codec_type = convert_codec_id_to_type(codec_id);
+    if (codec_type == UNKNOW) {
+        av_log(avctx, AV_LOG_ERROR, "UNKNOW codec_id:0x%x\n", codec_id);
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+
+    /* init audio dec */
+    if(chan == 1) {
+        es_adec_init();
+    }
+
+    /* get codec attr */
+    void *attr = get_audio_decoder_attr(avctx, codec_id);
+    ESADECContext *s = (ESADECContext *)avctx->priv_data;
+
+    int ret = es_adec_create(chan, codec_type, attr);
+    /* free attr, NULL is safe */
+    av_free(attr);
+
+    if(0 != ret) {
+        av_log(avctx, AV_LOG_ERROR, "es_adec_create() failed:%d\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    s->chan_id = chan;
+    chan++;
+    s->buffer_size = MAX_BUFFER_SIZE;
+    s->buffer = av_malloc(s->buffer_size);
+    s->offset = 0;
+
+    return 0;
+}
+
+static av_cold int ff_es_adec_close(AVCodecContext *avctx)
+{
+    ESADECContext *s = avctx->priv_data;
+    es_adec_destroy(s->chan_id);
+    av_free(s->buffer);
+    return 0;
+}
+
+static int get_stream_info(AVCodecContext *avctx, uint8_t *data, uint32_t size, es_frame_info *frame_info)
+{
+    ESADECContext *s = avctx->priv_data;
+    int ret = es_adec_parse_packets(s->chan_id, data, size, frame_info);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "es_adec_parse_packets failed:%d\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+    // av_log(avctx, AV_LOG_INFO, "sample_rate=%d, frame_size=%d, channels=%d, bit_depth=%d, decoded_size=%d\n",
+    //        frame_info->sample_rate, frame_info->frame_size, frame_info->channels,
+    //        frame_info->bit_depth, frame_info->decoded_size);
+    avctx->sample_rate = frame_info->sample_rate;
+    avctx->frame_size  = frame_info->decoded_size / frame_info->channels / (frame_info->bit_depth / 8);
+
+    av_channel_layout_uninit(&avctx->ch_layout);
+    if (frame_info->channels == 1) {
+        avctx->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_MONO;
+    } else {
+        avctx->ch_layout = (AVChannelLayout)AV_CHANNEL_LAYOUT_STEREO;
+    }
+
+    switch (frame_info->bit_depth) {
+    case 8:
+        avctx->sample_fmt = AV_SAMPLE_FMT_U8;
+        break;
+    case 16:
+        avctx->sample_fmt = AV_SAMPLE_FMT_S16;
+        break;
+    case 32:
+        avctx->sample_fmt = AV_SAMPLE_FMT_S32;
+        break;
+    default:
+        avctx->sample_fmt = AV_SAMPLE_FMT_S16;
+        break;
+    }
+    return 0;
+}
+
+static int ff_es_adec_frame(AVCodecContext *avctx, AVFrame *frame,
+                                int *got_frame_ptr, AVPacket *avpkt)
+{
+    int ret;
+    ESADECContext *s = avctx->priv_data;
+    int32_t size = s->buffer_size;
+    es_frame_info frame_info;
+    uint8_t *pkt_data = NULL;
+    uint32_t pkt_size = 0;
+
+    if (AV_CODEC_ID_MP3 == avctx->codec_id) {
+        memcpy(s->stream + s->offset, avpkt->data, avpkt->size);
+        pkt_size = s->offset;
+        pkt_data = s->stream;
+        s->offset = avpkt->size;
+    } else {
+        pkt_data = avpkt->data;
+        pkt_size = avpkt->size;
+    }
+
+    if (pkt_size == 0) {
+        return avpkt->size;
+    }
+
+    if ((ret = get_stream_info(avctx, pkt_data, pkt_size, &frame_info)) < 0) {
+        av_log(s, AV_LOG_ERROR, "get_stream_info failed:%d\n", ret);
+        return ret;
+    }
+
+    ret = es_adec_decode_stream(s->chan_id, pkt_data, pkt_size, s->buffer, &size);
+    if (0 != ret){
+        av_log(s, AV_LOG_ERROR, "es_adec_decode_stream failed: %d\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    if (AV_CODEC_ID_MP3 == avctx->codec_id) {
+        memmove(s->stream, s->stream + pkt_size, avpkt->size);
+    }
+
+    if (size == 0) {
+        return avpkt->size;
+    }
+
+    frame->nb_samples = size / frame_info.channels / (frame_info.bit_depth / 8);
+
+    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
+        av_log(s, AV_LOG_ERROR, "cannot get buffer for decode, ret: %d\n", ret);
+        return ret;
+    }
+
+    memcpy(frame->extended_data[0], s->buffer, size);
+
+    *got_frame_ptr = 1;
+    return avpkt->size;
+}
+
+static av_cold void ff_es_adec_flush(AVCodecContext *avctx)
+{
+
+}
+
+#define ES_AUDIO_DEC(ctype, CTYPE)                                                                  \
+    static const AVClass es_##ctype##_decoder_class = {                                             \
+        .class_name = #ctype "_esadec",                                                             \
+        .item_name = av_default_item_name,                                                          \
+        .option = options,                                                                          \
+        .version = LIBAVUTIL_VERSION_INT,                                                           \
+    };                                                                                              \
+    const FFCodec ff_es_##ctype##_decoder = {                                                       \
+        .p.name = "es_" #ctype,                                                                     \
+        .p.long_name = NULL_IF_CONFIG_SMALL("Es " #ctype " decoder"),                               \
+        .p.type = AVMEDIA_TYPE_AUDIO,                                                               \
+        .p.id = AV_CODEC_ID_##CTYPE,                                                                \
+        .priv_data_size = sizeof(ESADECContext),                                                    \
+        .p.priv_class = &es_##ctype##_decoder_class,                                                \
+        .init = ff_es_adec_init,                                                                    \
+        .close = ff_es_adec_close,                                                                  \
+        FF_CODEC_DECODE_CB(ff_es_adec_frame),                                                       \
+        .flush = ff_es_adec_flush,                                                                  \
+        .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,                             \
+        .p.wrapper_name = "esadec",                                                                 \
+    };
+
+ES_AUDIO_DEC(aac, AAC)
+ES_AUDIO_DEC(mp3, MP3)
+ES_AUDIO_DEC(amrnb, AMR_NB)
+ES_AUDIO_DEC(amrwb, AMR_WB)
+ES_AUDIO_DEC(g711alaw, PCM_ALAW)
+ES_AUDIO_DEC(g711mulaw, PCM_MULAW)
+ES_AUDIO_DEC(g722, ADPCM_G722)
+ES_AUDIO_DEC(g726, ADPCM_G726)
+
diff --git a/libavcodec/es_audio_enc.c b/libavcodec/es_audio_enc.c
new file mode 100644
index 0000000000..31a6ad81c2
--- /dev/null
+++ b/libavcodec/es_audio_enc.c
@@ -0,0 +1,346 @@
+#include "libavutil/channel_layout.h"
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "avcodec.h"
+#include "codec_internal.h"
+#include "encode.h"
+#include "internal.h"
+#include "adp_amr.h"
+#include "adp_itut_gxx.h"
+#include "adp_aac.h"
+#include "codec_api.h"
+
+#define AMR_NB_SAMPLES_PER_FRAME     160
+#define AMR_WB_SAMPLES_PER_FRAME     320
+#define GXX_SAMPLES_PER_FRAME        160
+#define AAC_LC_SAMPLES_PER_FRAME     1024
+
+#define MAX_PACKET_SIZE              16384
+
+#define DEBUG_DUMP 0
+
+typedef struct ESAENCContext {
+    const AVClass *class;
+    int chan_id;
+    int bit_rate;
+    int afterburner;
+    int vbr;
+    int eld_sbr;
+} ESAENCContext;
+
+static const AVOption aac_options[] = {
+    { "afterburner", "Afterburner (improved quality)", offsetof(ESAENCContext, afterburner), AV_OPT_TYPE_INT,
+      { .i64 = 1 }, 0, 1, AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM },
+    { "vbr", "VBR mode (1-5)", offsetof(ESAENCContext, vbr), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 5,
+      AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM },
+    { "eld_sbr", "Enable SBR for ELD (for SBR in other configurations, use the -profile parameter)",
+      offsetof(ESAENCContext, eld_sbr), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1,
+      AV_OPT_FLAG_AUDIO_PARAM | AV_OPT_FLAG_ENCODING_PARAM },
+    { NULL },
+};
+
+static const AVOption amrnb_options[] = { { NULL } };
+
+static const AVOption amrwb_options[] = { { NULL } };
+
+static const AVOption g711alaw_options[] = { { NULL } };
+
+static const AVOption g711mulaw_options[] = { { NULL } };
+
+static const AVOption g722_options[] = { { NULL } };
+
+static const AVOption g726_options[] = { { NULL } };
+
+static es_codec_type convert_codec_id_to_type(enum AVCodecID codec_id);
+static void *get_audio_encoder_attr(AVCodecContext *avctx, enum AVCodecID codec_id);
+
+static es_codec_type convert_codec_id_to_type(enum AVCodecID codec_id)
+{
+    switch (codec_id) {
+        case AV_CODEC_ID_AAC:
+            return AAC;
+        case AV_CODEC_ID_MP3:
+            return MP3;
+        case AV_CODEC_ID_PCM_ALAW:
+        case AV_CODEC_ID_PCM_MULAW:
+            return G711;
+        case AV_CODEC_ID_ADPCM_G722:
+            return G722;
+        case AV_CODEC_ID_ADPCM_G726:
+            return G726;
+        case AV_CODEC_ID_AMR_NB:
+        case AV_CODEC_ID_AMR_WB:
+            return AMR;
+        default:
+            return UNKNOW;
+    }
+}
+
+static void *get_audio_encoder_attr(AVCodecContext *avctx, enum AVCodecID codec_id)
+{
+    ESAENCContext *s = (ESAENCContext *)avctx->priv_data;
+    void *attr = NULL;
+
+    if (AV_CODEC_ID_AMR_NB == codec_id || AV_CODEC_ID_AMR_WB == codec_id) {
+        audio_amr_encoder_attr *amr_attr = av_mallocz(sizeof(audio_amr_encoder_attr));
+        if (amr_attr) {
+            amr_attr->is_wb = (AV_CODEC_ID_AMR_WB == codec_id) ? 1 : 0;
+            amr_attr->bit_rate = avctx->bit_rate;
+            attr = amr_attr;
+        }
+    } else if (AV_CODEC_ID_PCM_ALAW == codec_id || AV_CODEC_ID_PCM_MULAW == codec_id) {
+        audio_g711_attr *g711_attr = av_mallocz(sizeof(audio_g711_attr));
+        if (g711_attr) {
+            g711_attr->type = (AV_CODEC_ID_PCM_ALAW == codec_id) ? ALAW : ULAW;
+            attr = g711_attr;
+        }
+    } else if (AV_CODEC_ID_ADPCM_G722 == codec_id) {
+        audio_g722_attr *g722_attr = av_mallocz(sizeof(audio_g722_attr));
+        if (g722_attr) {
+            g722_attr->bit_rate = avctx->bit_rate;
+            attr = g722_attr;
+        }
+    } else if (AV_CODEC_ID_ADPCM_G726 == codec_id) {
+        audio_g726_attr *g726_attr = av_mallocz(sizeof(audio_g726_attr));
+        if (g726_attr) {
+            g726_attr->bit_rate = avctx->bit_rate;
+            attr = g726_attr;
+        }
+    } else if (AV_CODEC_ID_AAC == codec_id) {
+        audio_aacenc_attr *aac_attr = av_mallocz(sizeof(audio_aacenc_attr));
+        if (aac_attr) {
+            aac_attr->bit_rate = avctx->bit_rate;
+            aac_attr->aot = avctx->profile + 1;
+            aac_attr->sbr = s->eld_sbr;
+            aac_attr->channels = avctx->ch_layout.nb_channels;
+            aac_attr->vbr = s->vbr;
+            aac_attr->sample_rate = avctx->sample_rate;
+            aac_attr->afterburner = s->afterburner;
+            attr = aac_attr;
+        }
+    }
+    return attr;
+}
+
+static int set_frame_size(AVCodecContext *avctx)
+{
+    switch (avctx->codec_id) {
+        case AV_CODEC_ID_AMR_WB:
+            avctx->frame_size = AMR_WB_SAMPLES_PER_FRAME;
+            break;
+        case AV_CODEC_ID_AMR_NB:
+            avctx->frame_size = AMR_NB_SAMPLES_PER_FRAME;
+            break;
+        case AV_CODEC_ID_AAC:{
+            if (FF_PROFILE_AAC_LOW == avctx->profile) {
+                avctx->frame_size = AAC_LC_SAMPLES_PER_FRAME;
+            } else {
+                av_log(avctx, AV_LOG_ERROR, "Not support AAC profile: %d\n", avctx->frame_size);
+            }
+            break;
+        }
+        case AV_CODEC_ID_PCM_ALAW:
+        case AV_CODEC_ID_PCM_MULAW:
+        case AV_CODEC_ID_ADPCM_G722:
+        case AV_CODEC_ID_ADPCM_G726:
+            avctx->frame_size = GXX_SAMPLES_PER_FRAME;
+            break;
+        default:
+            // Handle other codec IDs
+            break;
+    }
+    return 0;
+}
+
+static av_cold int ff_es_aenc_init(AVCodecContext *avctx)
+{
+    static int32_t chan = 1;
+
+    /* get codec type */
+    enum AVCodecID codec_id = avctx->codec_id;
+    es_codec_type codec_type = convert_codec_id_to_type(codec_id);
+    if (codec_type == UNKNOW) {
+        av_log(avctx, AV_LOG_ERROR, "UNKNOW codec_id:0x%x\n", codec_id);
+        return AVERROR_ENCODER_NOT_FOUND;
+    }
+
+    /* init audio dec */
+    if(chan == 1) {
+        es_aenc_init();
+    }
+
+    if (AV_CODEC_ID_AAC == codec_id) {
+        if (FF_PROFILE_AAC_LOW != avctx->profile) {
+            av_log(avctx, AV_LOG_DEBUG, "Only support AAC-LC, use AAC_LOW auto\n");
+            avctx->profile = FF_PROFILE_AAC_LOW;
+        }
+    }
+
+    /* get codec attr */
+    void *attr = get_audio_encoder_attr(avctx, codec_id);
+    ESAENCContext *s = (ESAENCContext *)avctx->priv_data;
+
+    int ret = es_aenc_create(chan, codec_type, attr);
+    /* free attr, NULL is safe */
+    av_free(attr);
+
+    if(0 != ret) {
+        av_log(avctx, AV_LOG_ERROR, "es_aenc_create() failed:%d\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    s->chan_id = chan;
+    chan++;
+
+    set_frame_size(avctx);
+
+    return 0;
+}
+
+static av_cold int ff_es_aenc_close(AVCodecContext *avctx)
+{
+    ESAENCContext *s = avctx->priv_data;
+    es_aenc_destroy(s->chan_id);
+    return 0;
+}
+
+#if DEBUG_DUMP
+static int dump_data(const char *path, const void *buf, size_t bytes)
+{
+    if (!path) {
+        return 0;
+    }
+
+    FILE *fp = fopen(path, "a+");
+    if (fp) {
+        fwrite((char *)buf, 1, bytes, fp);
+        fclose(fp);
+    }
+
+    return 0;
+}
+
+static const char* get_codec_suffix(AVCodecContext *avctx)
+{
+    const char *suffix = "";
+
+    switch (avctx->codec_id) {
+        case AV_CODEC_ID_AAC:
+            suffix = ".aac";
+            break;
+        case AV_CODEC_ID_MP3:
+            suffix = ".mp3";
+            break;
+        case AV_CODEC_ID_AMR_NB:
+        case AV_CODEC_ID_AMR_WB:
+            suffix = ".amr";
+            break;
+        case AV_CODEC_ID_PCM_ALAW:
+        case AV_CODEC_ID_PCM_MULAW:
+            suffix = ".wav";
+            break;
+        case AV_CODEC_ID_ADPCM_G722:
+            suffix = ".g722";
+            break;
+        case AV_CODEC_ID_ADPCM_G726:
+            suffix = ".g726";
+            break;
+        default:
+            break;
+    }
+    return suffix;
+}
+#endif
+
+static int ff_es_aenc_frame(AVCodecContext *avctx, AVPacket *avpkt,
+                               const AVFrame *frame, int *got_packet_ptr)
+{
+    int ret;
+    ESAENCContext *s = avctx->priv_data;
+    int32_t size = 0;
+
+    if ((ret = ff_alloc_packet(avctx, avpkt, MAX_PACKET_SIZE)) < 0) {
+        return ret;
+    }
+
+    ret = es_aenc_encode_frame(s->chan_id, frame->data[0], frame->linesize[0], avpkt->data, &size);
+    if (0 != ret){
+        av_log(s, AV_LOG_ERROR, "es_aenc_encode_frame failed:%d\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+    // av_log(avctx, AV_LOG_INFO, "linesize=%d, size=%d\n", frame->linesize[0], size);
+#if DEBUG_DUMP
+    dump_data("./dump_before_encode.raw", frame->data[0], frame->linesize[0]);
+    char output_filename[256];
+    snprintf(output_filename, sizeof(output_filename), "dump_after_encode%s", get_codec_suffix(avctx));
+    dump_data(output_filename, avpkt->data, size);
+#endif
+
+    avpkt->size = size;
+    *got_packet_ptr = 1;
+    return 0;
+}
+
+static const int amrnb_sample_rates[] = { 8000, 0 };
+
+static const int amrwb_sample_rates[] = { 16000, 0 };
+
+static const int g711alaw_sample_rates[] = { 8000, 0 };
+
+static const int g711mulaw_sample_rates[] = { 8000, 0 };
+
+static const int g722_sample_rates[] = { 16000, 0 };
+
+static const int g726_sample_rates[] = { 8000, 0 };
+
+static const int aac_sample_rates[] = { 48000, 44100, 32000, 24000, 22050, 16000, 8000, 0 };
+
+static const AVChannelLayout amrnb_ch_layouts[2] = { AV_CHANNEL_LAYOUT_MONO, { 0 } };
+
+static const AVChannelLayout amrwb_ch_layouts[2] = { AV_CHANNEL_LAYOUT_MONO, { 0 } };
+
+static const AVChannelLayout g711alaw_ch_layouts[2] = { AV_CHANNEL_LAYOUT_MONO, { 0 } };
+
+static const AVChannelLayout g711mulaw_ch_layouts[2] = { AV_CHANNEL_LAYOUT_MONO, { 0 } };
+
+static const AVChannelLayout g722_ch_layouts[2] = { AV_CHANNEL_LAYOUT_MONO, { 0 } };
+
+static const AVChannelLayout g726_ch_layouts[2] = { AV_CHANNEL_LAYOUT_MONO, { 0 } };
+
+static const AVChannelLayout aac_ch_layouts[3] = {
+    AV_CHANNEL_LAYOUT_MONO,
+    AV_CHANNEL_LAYOUT_STEREO,
+    { 0 },
+};
+
+#define ES_AUDIO_ENC(ctype, CTYPE)                                                                  \
+    static const AVClass es_##ctype##_encoder_class = {                                             \
+        .class_name = #ctype "_esaenc",                                                             \
+        .item_name = av_default_item_name,                                                          \
+        .option = ctype##_options,                                                                          \
+        .version = LIBAVUTIL_VERSION_INT,                                                           \
+    };                                                                                              \
+    const FFCodec ff_es_##ctype##_encoder = {                                                       \
+        .p.name = "es_" #ctype,                                                                     \
+        .p.long_name = NULL_IF_CONFIG_SMALL("Es " #ctype " encoder"),                               \
+        .p.type = AVMEDIA_TYPE_AUDIO,                                                               \
+        .p.id = AV_CODEC_ID_##CTYPE,                                                                \
+        .priv_data_size = sizeof(ESAENCContext),                                                    \
+        .p.priv_class = &es_##ctype##_encoder_class,                                                \
+        .init = ff_es_aenc_init,                                                                    \
+        .close = ff_es_aenc_close,                                                                  \
+        FF_CODEC_ENCODE_CB(ff_es_aenc_frame),                                                       \
+        .p.wrapper_name = "esaenc",                                                                 \
+        .p.sample_fmts = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE },    \
+        .p.ch_layouts = ctype##_ch_layouts,                                                       \
+        .p.supported_samplerates = ctype##_sample_rates,                                          \
+    };
+
+ES_AUDIO_ENC(amrnb, AMR_NB)
+ES_AUDIO_ENC(amrwb, AMR_WB)
+ES_AUDIO_ENC(g711alaw, PCM_ALAW)
+ES_AUDIO_ENC(g711mulaw, PCM_MULAW)
+ES_AUDIO_ENC(g722, ADPCM_G722)
+ES_AUDIO_ENC(g726, ADPCM_G726)
+ES_AUDIO_ENC(aac, AAC)
+
diff --git a/libavcodec/es_codec_private.h b/libavcodec/es_codec_private.h
new file mode 100644
index 0000000000..78c4b14070
--- /dev/null
+++ b/libavcodec/es_codec_private.h
@@ -0,0 +1,60 @@
+
+
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#ifndef AVCODEC_VSV_PRIVATE_H
+#define AVCODEC_VSV_PRIVATE_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "libavutil/pixfmt.h"
+
+
+struct AVBufferRef;
+#define ES_DEC_MAX_OUT_COUNT 3
+#define DEFAULT_FRAME_PP_INDEX  0
+
+typedef struct _OutPutInfo {
+  #define VIDEO_MAX_PLANES 4
+    int32_t enabled;
+    int fd;
+    uint32_t width;
+    uint32_t height;
+    enum AVPixelFormat format;
+    int32_t key_frame;
+    int32_t n_planes;
+    uint32_t *virtual_address;
+    size_t bus_address;
+    size_t size;
+    size_t offset[VIDEO_MAX_PLANES];
+    int32_t stride[VIDEO_MAX_PLANES];
+} OutPutInfo;
+
+typedef struct _DecPicturePri {
+  uint32_t pic_count;
+  int32_t default_index;
+  int32_t stride_align;
+  OutPutInfo *default_pic;
+  void *hwpic;
+  struct AVBufferRef *ctx_buf;
+  OutPutInfo pictures[ES_DEC_MAX_OUT_COUNT];
+} DecPicturePri;
+
+#endif //AVCODEC_VSV_PRIVATE_H
\ No newline at end of file
diff --git a/libavcodec/es_common.c b/libavcodec/es_common.c
new file mode 100644
index 0000000000..d147e8bdda
--- /dev/null
+++ b/libavcodec/es_common.c
@@ -0,0 +1,359 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "es_common.h"
+#include "avcodec.h"
+
+/* parse gstreamer cjson para about crop*/
+int ff_codec_get_crop(char *str, CropInfo *crop_info) {
+    char *p;
+
+    if (!str || !crop_info) {
+        return -1;
+    }
+    if (((p = strstr(str, "cx")) == NULL) && ((p = strstr(str, "cy")) == NULL) && ((p = strstr(str, "cw")) == NULL)
+        && ((p = strstr(str, "ch")) == NULL)) {
+        return 0;
+    }
+
+    if ((p = strstr(str, "cx")) != NULL) {
+        crop_info->crop_xoffset = atoi(p + 3);
+    } else {
+        return -1;
+    }
+
+    if ((p = strstr(str, "cy")) != NULL) {
+        crop_info->crop_yoffset = atoi(p + 3);
+    } else {
+        return -1;
+    }
+
+    if ((p = strstr(str, "cw")) != NULL) {
+        crop_info->crop_width = atoi(p + 3);
+    } else {
+        return -1;
+    }
+
+    if ((p = strstr(str, "ch")) != NULL) {
+        crop_info->crop_height = atoi(p + 3);
+    } else {
+        return -1;
+    }
+
+    return 0;
+}
+
+int es_codec_get_crop(char *str, CropInfo *crop_info) {
+    if (!str || !crop_info) {
+        return -1;
+    }
+
+    if (sscanf(str,
+               "%dx%dx%dx%d",
+               &crop_info->crop_xoffset,
+               &crop_info->crop_yoffset,
+               &crop_info->crop_width,
+               &crop_info->crop_height)
+        != 4) {
+        return -1;
+    }
+
+    return 0;
+}
+
+int es_codec_get_scale(char *str, ScaleInfo *scale_info) {
+    if (!str || !scale_info) {
+        return -1;
+    }
+
+    if (strchr(str, ':')) {
+        if (sscanf(str, "%d:%d", &scale_info->scale_width, &scale_info->scale_height) != 2) {
+            return -1;
+        }
+    } else {
+        scale_info->scale_width = scale_info->scale_height = atoi(str);
+    }
+
+    return 0;
+}
+
+static int ff_dec_scale_is_valid(int value) {
+    if ((value == -1) || (value == -2) || (value == -4) || (value == -8) || (value >= 0)) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
+/* parse gstreamer cjson para about scale*/
+int ff_dec_get_scale(char *str, ScaleInfo *scale_info, int pp_idx) {
+    char *p;
+
+    if (!str || !scale_info) {
+        return -1;
+    }
+
+    if (((p = strstr(str, "sw")) == NULL) && ((p = strstr(str, "sh")) == NULL)) {
+        return 0;
+    }
+
+    if (pp_idx == 0) {
+        av_log(NULL, AV_LOG_ERROR, "pp0 not support scale!");
+        return -2;
+    }
+
+    if ((p = strstr(str, "sw")) != NULL) {
+        scale_info->scale_width = atoi(p + 3);
+    } else {
+        return -1;
+    }
+
+    if (!ff_dec_scale_is_valid(scale_info->scale_width)) {
+        av_log(NULL, AV_LOG_ERROR, "pp1 only support scale width config 1/2/4/8!");
+        return -1;
+    }
+
+    if ((p = strstr(str, "sh")) != NULL) {
+        scale_info->scale_height = atoi(p + 3);
+    } else {
+        return -1;
+    }
+
+    if (!ff_dec_scale_is_valid(scale_info->scale_height)) {
+        av_log(NULL, AV_LOG_ERROR, "pp1 only support scale height config 1/2/4/8!");
+        return -1;
+    }
+
+    return 0;
+}
+
+DumpHandle *ff_codec_dump_file_open(const char *dump_path, int duration, DumpParas *paras) {
+    DumpHandle *dump_handle = NULL;
+    char file_path[PATH_MAX];
+    struct timeb sys_time;
+    char time_char[128];
+    struct tm *tm;
+    int ret;
+
+    if (!dump_path) {
+        av_log(NULL, AV_LOG_ERROR, "error !!! dump path is null\n");
+        return NULL;
+    }
+
+    if (!paras) {
+        av_log(NULL, AV_LOG_ERROR, "error !!! paras is null\n");
+        return NULL;
+    }
+
+    ret = access(dump_path, 0);
+    if (ret == -1) {
+        av_log(NULL, AV_LOG_INFO, "dump_path: %s does not exist\n", dump_path);
+        if (mkdir(dump_path, 0731) == -1) {
+            av_log(NULL, AV_LOG_ERROR, "create dump_path: %s failed errno: %d\n", dump_path, errno);
+            return NULL;
+        }
+    } else {
+        av_log(NULL, AV_LOG_INFO, "dump_path: %s exist\n", dump_path);
+    }
+
+    if (duration <= 0) {
+        av_log(NULL, AV_LOG_ERROR, "invalid dump_time: %d\n", duration);
+        return NULL;
+    }
+
+    // get local time
+    ftime(&sys_time);
+    tm = localtime(&sys_time);
+    strftime(time_char, sizeof(time_char), "%y%m%d%H%M%S", tm);
+
+    dump_handle = (DumpHandle *)malloc(sizeof(DumpHandle));
+    if (!dump_handle) {
+        av_log(NULL, AV_LOG_ERROR, "dump_handle malloc failed\n");
+        return NULL;
+    }
+
+    dump_handle->stop_dump_time = av_gettime_relative() + duration * 1000;
+
+    if (!paras->pic_stride && !paras->pic_stride_ch && !paras->fmt) {
+        snprintf(file_path,
+                 sizeof(file_path),
+                 "%s/%s_%s_%dms_%dx%d.%s",
+                 dump_path,
+                 paras->prefix_name,
+                 time_char,
+                 duration,
+                 paras->width,
+                 paras->height,
+                 paras->suffix_name);
+    } else if (!paras->pic_stride && !paras->pic_stride_ch) {
+        snprintf(file_path,
+                 sizeof(file_path),
+                 "%s/%s_%s_%dms_%dx%d_%s.%s",
+                 dump_path,
+                 paras->prefix_name,
+                 time_char,
+                 duration,
+                 paras->width,
+                 paras->height,
+                 paras->fmt,
+                 paras->suffix_name);
+    } else {
+        snprintf(file_path,
+                 sizeof(file_path),
+                 "%s/%s_%s_%s_%dms_%dx%d_%dx%d(stride)_%s.%s",
+                 dump_path,
+                 paras->prefix_name,
+                 paras->ppu_channel,
+                 time_char,
+                 duration,
+                 paras->width,
+                 paras->height,
+                 paras->pic_stride,
+                 paras->pic_stride_ch,
+                 paras->fmt,
+                 paras->suffix_name);
+    }
+
+    dump_handle->fp = fopen(file_path, "ab+");
+    if (dump_handle->fp) {
+        av_log(NULL, AV_LOG_INFO, "open %s success\n", file_path);
+    } else {
+        dump_handle->fp = NULL;
+        free(dump_handle);
+        av_log(NULL, AV_LOG_ERROR, "open %s failed\n", file_path);
+        return NULL;
+    }
+
+    return dump_handle;
+}
+
+int ff_codec_dump_file_close(DumpHandle **dump_handle) {
+    if (!dump_handle || !(*dump_handle)) {
+        return 0;
+    }
+    fflush((*dump_handle)->fp);
+    fclose((*dump_handle)->fp);
+    (*dump_handle)->fp = NULL;
+    free(*dump_handle);
+    *dump_handle = NULL;
+    return 0;
+}
+
+// if now_time > end_time, return 1
+int ff_codec_compara_timeb(int64_t end_time) {
+    int64_t now_time;
+    now_time = av_gettime_relative();
+
+    if ((now_time - end_time) > 0) {
+        return 1;
+    } else {
+        return 0;
+    }
+}
+
+int ff_codec_dump_bytes_to_file(void *data, int size, DumpHandle *dump_handle) {
+    int len = 0;
+
+    if (!dump_handle || !dump_handle->fp) {
+        av_log(NULL, AV_LOG_ERROR, " invalid dump_handle\n");
+        return FAILURE;
+    }
+
+    if (!data || size <= 0) {
+        return FAILURE;
+    }
+
+    if (ff_codec_compara_timeb(dump_handle->stop_dump_time) > 0) {
+        av_log(NULL, AV_LOG_INFO, "data dump stop\n");
+        return ERR_TIMEOUT;
+    } else {
+        len = fwrite(data, 1, size, dump_handle->fp);
+        fflush(dump_handle->fp);
+        if (len != size) {
+            av_log(NULL, AV_LOG_ERROR, "write data to file error !!! len: %d, data size: %d\n", len, size);
+        }
+    }
+
+    return len;
+}
+
+const char *ff_vsv_encode_get_fmt_char(enum AVPixelFormat pix_fmt) {
+    switch (pix_fmt) {
+        case AV_PIX_FMT_YUV420P:
+            return "yuv420p";
+        case AV_PIX_FMT_NV12:
+            return "nv12";
+        case AV_PIX_FMT_NV21:
+            return "nv21";
+        case AV_PIX_FMT_UYVY422:
+            return "uyvy422";
+        case AV_PIX_FMT_YUYV422:
+            return "yuyv422";
+        case AV_PIX_FMT_YUV420P10LE:
+            return "I010";
+        case AV_PIX_FMT_P010LE:
+            return "p010";
+        default:
+            return "unknown";
+    }
+}
+
+int ff_es_codec_add_fd_to_side_data(AVFrame *frame, uint64_t fd) {
+    int ret = SUCCESS;
+    AVFrameSideData *sd = NULL;
+
+    if (!frame) {
+        av_log(NULL, AV_LOG_ERROR, "frame is null\n");
+        return FAILURE;
+    }
+
+    av_log(NULL, AV_LOG_DEBUG, "add side data: fd = %lx\n", fd);
+    sd = av_frame_new_side_data(frame, SIDE_DATA_TYPE_MEM_FRAME_FD, sizeof(fd));
+    if (sd && sd->data) {
+        memcpy(sd->data, &fd, sizeof(fd));
+    } else {
+        ret = FAILURE;
+        av_log(NULL, AV_LOG_ERROR, "av_frame_new_side_data faild sd: %p\n", sd);
+    }
+
+    return ret;
+}
+
+int ff_es_codec_memcpy_block(void *src, void *dst, size_t data_size) {
+    if (!src || !dst) {
+        return AVERROR(EINVAL);
+    }
+    memcpy(dst, src, data_size);
+
+    return 0;
+}
+
+int ff_es_codec_memcpy_by_line(uint8_t *src, uint8_t *dst, int src_linesize, int dst_linesize, int linecount) {
+    int copy_size;
+    if (!src || !dst) {
+        return AVERROR(EINVAL);
+    }
+
+    copy_size = FFMIN(src_linesize, dst_linesize);
+    for (int i = 0; i < linecount; i++) {
+        memcpy(dst + i * dst_linesize, src + i * src_linesize, copy_size);
+    }
+
+    return 0;
+}
\ No newline at end of file
diff --git a/libavcodec/es_common.h b/libavcodec/es_common.h
new file mode 100644
index 0000000000..857ef29d3c
--- /dev/null
+++ b/libavcodec/es_common.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ES_COMMON_H
+#define AVCODEC_ES_COMMON_H
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <time.h>
+#include <sys/timeb.h>
+#include "libavutil/time.h"
+#include <linux/limits.h>
+#include <unistd.h>
+#include <libavutil/pixfmt.h>
+#include <libavutil/frame.h>
+
+#ifndef SUCCESS
+#define SUCCESS (0)
+#endif
+
+#ifndef FAILURE
+#define FAILURE (-1)
+#endif
+
+#ifndef ERR_TIMEOUT
+#define ERR_TIMEOUT (-2)
+#endif
+
+#ifndef TRUE
+#define TRUE (1)
+#endif
+
+#ifndef FALSE
+#define FALSE (0)
+#endif
+
+#define ES_VID_DEC_MAX_OUT_COUNT 2
+
+// define side_data type
+enum _SideDataType {
+    SIDE_DATA_TYPE_BASE = 0x12340000,
+    SIDE_DATA_TYPE_SLICE_SIZE,            // slice size
+    SIDE_DATA_TYPE_FORCE_IDR,             // force idr
+    SIDE_DATA_TYPE_INSERT_SPS_PPS,        // insert sps pps
+    SIDE_DATA_TYPE_RC,                    // RC
+    SIDE_DATA_TYPE_ROI_AREA,              // roi area, 8 areas
+    SIDE_DATA_TYPE_CU_MAP,                // roi cu map or skip cu map
+    SIDE_DATA_TYPE_MEM_FRAME_FD,          // fd in within avframe
+    SIDE_DATA_TYPE_MEM_FRAME_FD_RELEASE,  // fd release within avframe
+
+    SIDE_DATA_TYPE_JENC_BASE = 0x12345000,
+    SIDE_DATA_TYPE_JENC_THUMBNAIL,       // input thumbnail
+    SIDE_DATA_TYPE_JENC_ROI_AREA,        // input regions of intereset area
+    SIDE_DATA_TYPE_JENC_NON_ROI_FILTER,  // non roi filter
+};
+
+typedef enum ESDecCodec {
+    ES_HEVC,
+    ES_H264_H10P,
+    ES_H264,
+    ES_JPEG,
+} ESDecCodec;
+
+typedef struct {
+    int crop_xoffset;
+    int crop_yoffset;
+    int crop_width;
+    int crop_height;
+} CropInfo;
+
+typedef struct {
+    int scale_width;
+    int scale_height;
+} ScaleInfo;
+
+typedef struct {
+    int width;
+    int height;
+    int pic_stride;    /**< picture stride for luma */
+    int pic_stride_ch; /**< picture stride for chroma */
+    char *ppu_channel;
+    char *prefix_name;
+    char *suffix_name;
+    char *fmt;
+} DumpParas;
+
+typedef struct {
+    int64_t stop_dump_time;
+    FILE *fp;
+} DumpHandle;
+
+int ff_codec_get_crop(char *str, CropInfo *crop_info);
+
+int ff_dec_get_scale(char *str, ScaleInfo *scale_info, int pp_idx);
+
+int es_codec_get_crop(char *str, CropInfo *crop_info);
+
+int es_codec_get_scale(char *str, ScaleInfo *scale_info);
+
+DumpHandle *ff_codec_dump_file_open(const char *dump_path, int duration, DumpParas *paras);
+
+int ff_codec_compara_timeb(int64_t end_time);
+
+int ff_codec_dump_file_close(DumpHandle **dump_handle);
+
+int ff_codec_dump_bytes_to_file(void *data, int size, DumpHandle *dump_handle);
+
+const char *ff_vsv_encode_get_fmt_char(enum AVPixelFormat pix_fmt);
+
+int ff_es_codec_add_fd_to_side_data(AVFrame *frame, uint64_t fd);
+
+int ff_es_codec_memcpy_block(void *src, void *dst, size_t data_size);
+
+int ff_es_codec_memcpy_by_line(uint8_t *src, uint8_t *dst, int src_linesize, int dst_linesize, int linecount);
+
+#endif
diff --git a/libavcodec/es_jpeg_decode.c b/libavcodec/es_jpeg_decode.c
new file mode 100644
index 0000000000..ef3acf2203
--- /dev/null
+++ b/libavcodec/es_jpeg_decode.c
@@ -0,0 +1,2453 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "es_jpeg_decode.h"
+#include "jpegdecapi.h"
+#include "libavutil/hwcontext_es.h"
+#include "esdec_wrapper.h"
+
+#ifdef MODEL_SIMULATION
+#include <deccfg.h>
+extern u32 g_hw_build_id;
+extern u32 g_hw_id;
+extern u32 g_hw_ver;
+#endif
+
+static uint32_t find_dec_pic_wait_consume_index(VSVDECContext *dec_ctx,
+                                                uint8_t *data)
+{
+    uint32_t i;
+
+    pthread_mutex_lock(&dec_ctx->consume_mutex);
+    for (i = 0; i < MAX_WAIT_FOR_CONSUME_BUFFERS; i++) {
+        if (dec_ctx->wait_for_consume_list[i].pic
+            == (struct DecPicturePpu *)data)
+            break;
+    }
+
+    assert(i < dec_ctx->wait_consume_num);
+    pthread_mutex_unlock(&dec_ctx->consume_mutex);
+    return i;
+}
+
+
+
+static uint32_t find_dec_pic_wait_consume_empty_index(VSVDECContext *dec_ctx)
+{
+    uint32_t i;
+
+    pthread_mutex_lock(&dec_ctx->consume_mutex);
+    for (i = 0; i < MAX_WAIT_FOR_CONSUME_BUFFERS; i++) {
+        if (dec_ctx->wait_for_consume_list[i].wait_for_consume == 0)
+        break;
+    }
+
+    assert(i < MAX_WAIT_FOR_CONSUME_BUFFERS);
+    pthread_mutex_unlock(&dec_ctx->consume_mutex);
+
+    return i;
+}
+
+uint32_t ff_es_jpeg_dec_del_pic_wait_consume_list(VSVDECContext *dec_ctx,
+                                              uint8_t *data)
+{
+    uint32_t id;
+    id = find_dec_pic_wait_consume_index(dec_ctx,data);
+
+    pthread_mutex_lock(&dec_ctx->consume_mutex);
+    if(id < MAX_WAIT_FOR_CONSUME_BUFFERS) {
+        dec_ctx->wait_for_consume_list[id].pic = NULL;
+        dec_ctx->wait_for_consume_list[id].wait_for_consume = 0;
+        if(dec_ctx->wait_consume_num > 0)
+            dec_ctx->wait_consume_num--;
+        av_log(NULL, AV_LOG_DEBUG,
+               "ff_es_jpeg_dec_del_pic_wait_consume_list pic(@ %p) @ %d \n",
+               data, id);
+    }
+    pthread_mutex_unlock(&dec_ctx->consume_mutex);
+    return id;
+}
+
+static uint32_t add_dec_pic_wait_consume_list(VSVDECContext *dec_ctx, void *data)
+{
+    uint32_t id;
+
+    id = find_dec_pic_wait_consume_empty_index(dec_ctx);
+    av_log(NULL, AV_LOG_DEBUG, "add_dec_pic_wait_consume_list pic(@ %p) @ %d \n",
+           data, id);
+
+    pthread_mutex_lock(&dec_ctx->consume_mutex);
+    dec_ctx->wait_for_consume_list[id].pic = (struct DecPicturePpu *)data;
+    dec_ctx->wait_for_consume_list[id].wait_for_consume = 1;
+    if(dec_ctx->wait_consume_num < MAX_WAIT_FOR_CONSUME_BUFFERS)
+        dec_ctx->wait_consume_num++;
+    assert(id < MAX_WAIT_FOR_CONSUME_BUFFERS);
+    pthread_mutex_unlock(&dec_ctx->consume_mutex);
+    return id;
+}
+
+static void report_dec_pic_info( VSVDECContext *dec_ctx,  struct DecPicture *picture)
+{
+    char info_string[2048];
+    static const char* pic_types[] = {"        IDR", "Non-IDR (P)", "Non-IDR (B)"};
+
+    av_log(dec_ctx, AV_LOG_DEBUG, "PIC %2d/%2d, type %s, ",
+                              dec_ctx->pic_display_number,
+                              picture->picture_info.pic_id,
+                              picture->picture_info.pic_coding_type);
+    if (picture->picture_info.cycles_per_mb) {
+        av_log(dec_ctx, AV_LOG_DEBUG,
+                              " %4d cycles / mb,",
+                              picture->picture_info.cycles_per_mb);
+    }
+
+    av_log(dec_ctx, AV_LOG_DEBUG,
+            " %d x %d, Crop: (%d, %d), %d x %d %s",
+            picture->sequence_info.pic_width,
+            picture->sequence_info.pic_height,
+            picture->sequence_info.crop_params.crop_left_offset,
+            picture->sequence_info.crop_params.crop_top_offset,
+            picture->sequence_info.crop_params.crop_out_width,
+            picture->sequence_info.crop_params.crop_out_height,
+            picture->picture_info.is_corrupted ? "CORRUPT" : "");
+
+    av_log(dec_ctx, AV_LOG_DEBUG, "%s\n", info_string);
+}
+
+uint32_t ff_es_jpeg_dec_find_empty_index(VSVDECContext *dec_ctx)
+{
+    uint32_t i;
+    for (i = 0; i < MAX_BUFFERS; i++) {
+        if (dec_ctx->output_memory_list.output_memory[i].virtual_address == 0)
+            break;
+    }
+
+    assert(i < MAX_BUFFERS);
+    return i;
+}
+
+void ff_es_jpeg_dec_release_ext_buffers(VSVDECContext *dec_ctx)
+{
+    int dma_fd;
+
+    if(!dec_ctx) {
+        av_log(dec_ctx, AV_LOG_ERROR, "dec_ctx is nullptr\n");
+    }
+
+    pthread_mutex_lock(&dec_ctx->ext_buffer_control);
+    for(int i = 0; i < dec_ctx->output_memory_list.size; i++) {
+        ESJpegOutputMemory *memory = &dec_ctx->output_memory_list.output_memory[i];
+
+        dma_fd = ESDecGetDmaBufFd(&memory->mem);
+        av_log(dec_ctx,
+            AV_LOG_DEBUG,
+            "Freeing buffer virtual_address:%p, dma_fd:%d, memory size: %d\n",
+            (void *)memory->virtual_address,
+            dma_fd,
+            memory->mem.size);
+
+        for (int index = 0; index < ES_VID_DEC_MAX_OUT_COUNT; index++) {
+            if (memory->fd[index] >= 0 && memory->fd[index] != dma_fd) {
+                av_log(dec_ctx, AV_LOG_DEBUG, "close  pp_fd[%d]: %d\n", index, memory->fd[index]);
+                close(memory->fd[index]);
+                memory->fd[index] = -1;
+            }
+        }
+
+        if (dec_ctx->pp_enabled)
+            DWLFreeLinear(dec_ctx->dwl_inst, &memory->mem);
+        else
+            DWLFreeRefFrm(dec_ctx->dwl_inst, &memory->mem);
+
+        DWLmemset(&memory->mem, 0, sizeof(memory->mem));
+
+        memory->virtual_address = NULL;
+    }
+    pthread_mutex_unlock(&dec_ctx->ext_buffer_control);
+}
+
+void ff_es_pri_picture_info_free(void *opaque, uint8_t *data)
+{
+    av_free(data);
+}
+void ff_es_data_free(void *opaque, uint8_t *data)
+{
+    return;
+}
+
+
+void jpeg_dec_set_default_dec_config(AVCodecContext *avctx)
+{
+    VSVDECContext *dec_ctx = avctx->priv_data;
+
+    dec_ctx->avctx = avctx;
+    //ff_es_jpeg_dec_init_log_header(avctx);
+    dec_ctx->align = ff_es_jpeg_get_align(dec_ctx->out_stride);
+    dec_ctx->service_merge_disable = DEC_X170_SERVICE_MERGE_DISABLE;
+    dec_ctx->output_picture_endian = DEC_X170_OUTPUT_PICTURE_ENDIAN;
+    dec_ctx->clock_gating = DEC_X170_INTERNAL_CLOCK_GATING;
+    dec_ctx->latency_comp = DEC_X170_LATENCY_COMPENSATION;
+    dec_ctx->bus_burst_length = DEC_X170_BUS_BURST_LENGTH;
+    dec_ctx->asic_service_priority = DEC_X170_ASIC_SERVICE_PRIORITY;
+    dec_ctx->data_discard = DEC_X170_DATA_DISCARD_ENABLE;
+    dec_ctx->tiled_output = DEC_REF_FRM_RASTER_SCAN;
+    dec_ctx->dpb_mode = DEC_DPB_FRAME;
+    dec_ctx->dwl_init.client_type = DWL_CLIENT_TYPE_JPEG_DEC;
+
+    pthread_mutex_init(&dec_ctx->ext_buffer_control, NULL);
+
+    // memset(dec_ctx->ext_buffers, 0, sizeof(dec_ctx->ext_buffers));
+    dec_ctx->buffer_release_flag = 1;
+    dec_ctx->cycle_count = 0;
+    dec_ctx->enable_mc = 0;
+    dec_ctx->min_buffer_num = 0;
+    dec_ctx->last_pic_flag = 0;
+    dec_ctx->hdrs_rdy = 0;
+    dec_ctx->stream_mem_index = 0;
+    dec_ctx->pic_display_number = 0;
+    dec_ctx->got_package_number = 0;
+    dec_ctx->pic_decode_number = 0;
+    dec_ctx->prev_width = 0;
+    dec_ctx->prev_height = 0;
+    dec_ctx->closed = 0;
+    dec_ctx->extra_buffer_num = 0;
+    dec_ctx->dump_pkt_count = 0;
+    dec_ctx->dump_frame_count[0] = 0;
+    dec_ctx->dump_frame_count[1] = 0;
+    dec_ctx->frame_dump_handle[0] = NULL;
+    dec_ctx->frame_dump_handle[1] = NULL;
+    dec_ctx->pkt_dump_handle = NULL;
+    dec_ctx->thum_exist = 0;
+    dec_ctx->thum_out = 0;
+    dec_ctx->task_existed = 0;
+
+    dec_ctx->vsv_dec_config.align = dec_ctx->align;
+    dec_ctx->vsv_dec_config.dec_image_type = JPEGDEC_IMAGE;
+    memset(dec_ctx->vsv_dec_config.ppu_cfg, 0, sizeof(dec_ctx->vsv_dec_config.ppu_cfg));
+    memset(dec_ctx->vsv_dec_config.delogo_params, 0, sizeof(dec_ctx->vsv_dec_config.delogo_params));
+
+    // init output buffer list
+    dec_ctx->output_memory_list.size = 0;
+    memset(dec_ctx->output_memory_list.output_memory, 0, sizeof(dec_ctx->output_memory_list.output_memory));
+
+#ifdef MODEL_SIMULATION
+    g_hw_build_id = 0x1FB1;
+    g_hw_ver = 19001;
+    g_hw_id = 1000;
+#endif
+
+    dec_ctx->frame = av_frame_alloc();
+    if (!dec_ctx->frame) {
+        av_log(avctx, AV_LOG_ERROR, "av_frame_alloc failed\n");
+    }
+}
+
+enum DecRet jpegdec_consumed(void* inst, struct DecPicturePpu *pic) {
+    JpegDecOutput jpic;
+    u32 i;
+
+    DWLmemset(&jpic, 0, sizeof(JpegDecOutput));
+
+    for (i = 0; i < DEC_MAX_OUT_COUNT;i++) {
+        jpic.pictures[i].output_picture_y = pic->pictures[i].luma;
+    }
+
+    return JpegDecPictureConsumed(inst, &jpic);
+}
+
+int ff_esdec_get_next_picture(AVCodecContext *avctx, AVFrame *frame) {
+    VSVDECContext *dec_ctx = avctx->priv_data;
+    enum DecRet ret;
+    int i;
+    ret = jpeg_next_picture(avctx, dec_ctx->dec_inst, &dec_ctx->pic);
+    av_log(avctx, AV_LOG_DEBUG, "JpegNextPicture return: %d\n", ret);
+
+    if (ret == DEC_PIC_RDY) {
+        dec_ctx->pic_display_number++;
+        for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+            if(dec_ctx->pic.pictures[i].luma.virtual_address != NULL) {
+                av_log(avctx, AV_LOG_DEBUG, "Dec pic rdy, %d -> %d x %d -luma.virtual_address=%p"
+                                            "-luma.bus_address=%ld -luma.size=%d stride=%d"
+                                            "-sequence_info.pic_height=%d -sequence_info.pic_width=%d \n",
+                                            i,
+                                            dec_ctx->pic.pictures[i].pic_width,
+                                            dec_ctx->pic.pictures[i].pic_height,
+                                            dec_ctx->pic.pictures[i].luma.virtual_address,
+                                            dec_ctx->pic.pictures[i].luma.bus_address,
+                                            dec_ctx->pic.pictures[i].luma.size,
+                                            dec_ctx->pic.pictures[i].sequence_info.pic_stride,
+                                            dec_ctx->pic.pictures[i].sequence_info.pic_height,
+                                            dec_ctx->pic.pictures[i].sequence_info.pic_width);
+            }
+        }
+
+        // create frame file
+        for ( int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++)
+            if(!dec_ctx->frame_dump_handle[i])
+                ff_es_jpeg_init_frame_dump_handle(dec_ctx);
+        ff_es_jpeg_frame_dump(dec_ctx);
+
+        if (dec_ctx->thumb_mode == Decode_Pic_Thumb && dec_ctx->thum_exist && dec_ctx->thum_out)
+            ff_es_jpeg_dec_output_thum(avctx, frame, &dec_ctx->pic);
+        else
+            ff_es_jpeg_dec_output_frame(avctx, frame, &dec_ctx->pic);
+
+        av_log(avctx, AV_LOG_DEBUG,
+                "%d got frame :size=%dx%d,data[0]=%p,data[1]=%p,buf[0]=%p\n",
+                dec_ctx->pic_display_number,
+                frame->width,
+                frame->height,
+                frame->data[0],
+                frame->data[1],
+                frame->buf[0]);
+
+        jpegdec_consumed(dec_ctx->dec_inst, &dec_ctx->pic);
+
+    } else if (ret == DEC_END_OF_STREAM) {
+        av_log(avctx, AV_LOG_DEBUG, "End of stream!\n");
+        dec_ctx->last_pic_flag = 1;
+        return AVERROR_EOF;
+    }
+    return 0;
+}
+
+enum ESJpegCode ff_es_jpeg_decoder(AVCodecContext *avctx,
+                                   struct DecInputParameters *jpeg_in,
+                                   AVFrame *frame) {
+    VSVDECContext *dec_ctx = avctx->priv_data;
+    int ret = 0;
+
+    do {
+        ret = jpeg_decode(avctx,(void* )dec_ctx->dec_inst, jpeg_in);
+
+        ff_es_jpeg_dec_print_return(avctx, ret);
+
+        switch (ret) {
+        case DEC_PIC_RDY:
+            ff_esdec_get_next_picture( avctx, frame);
+            break;
+        case DEC_SCAN_PROCESSED:
+            av_log(avctx, AV_LOG_DEBUG, "\t-JPEG: DEC_SCAN_PROCESSED\n");
+            ret = jpeg_next_picture(avctx,dec_ctx->dec_inst, &dec_ctx->pic);
+            av_log(avctx, AV_LOG_DEBUG, "jpegNextPicture return: %d\n", ret);
+            if (ret == DEC_PIC_RDY) {
+                dec_ctx->pic_display_number++;
+                if (dec_ctx->thumb_mode == Decode_Pic_Thumb && dec_ctx->thum_exist && dec_ctx->thum_out)
+                    ff_es_jpeg_dec_output_thum(avctx, frame, &dec_ctx->pic);
+                else
+                    ff_es_jpeg_dec_output_frame(avctx, frame, &dec_ctx->pic);
+                av_log(avctx, AV_LOG_DEBUG,
+                        "%d got frame :data[0]=%p,data[1]=%p buf[0]=%p,buf[1]=%p \n",
+                        dec_ctx->pic_display_number, frame->data[0], frame->data[1],
+                        frame->buf[0], frame->buf[1]);
+
+                jpegdec_consumed(dec_ctx->dec_inst, &dec_ctx->pic);
+            } else if (ret == DEC_END_OF_STREAM) {
+                av_log(avctx, AV_LOG_DEBUG, "End of stream!\n");
+                dec_ctx->last_pic_flag = 1;
+                break;
+            }
+            break;
+        case DEC_SLICE_RDY:
+            av_log(avctx, AV_LOG_DEBUG, "\t-JPEG: DEC_SLICE_RDY\n");
+            break;
+        case DEC_NO_DECODING_BUFFER:
+            usleep(10000);
+        case DEC_WAITING_FOR_BUFFER:
+            dec_ctx->extra_buffer_num = 0;
+            return ES_MORE_BUFFER;
+        case DEC_STRM_PROCESSED:
+            av_log(avctx, AV_LOG_DEBUG, "\t-JPEG: DEC_STRM_PROCESSED\n");
+            break;
+        case DEC_STRM_ERROR:
+            ff_esdec_get_next_picture( avctx, frame);
+            return ES_ERROR;
+        default:
+            av_log(avctx, AV_LOG_ERROR, "jpegdecode return: %d\n", ret);
+            return ES_ERROR;
+        }
+    } while (ret != DEC_PIC_RDY);
+
+    return ES_OK;
+}
+
+int jpeg_init(VSVDECContext *dec_ctx)
+{
+    struct DecConfig config = dec_ctx->vsv_dec_config;
+    struct JpegDecConfig dec_cfg;
+    enum DecRet jpeg_ret;
+
+    dec_ctx->dwl_inst = (void *)DWLInit(&dec_ctx->dwl_init);
+    if (dec_ctx->dwl_inst == NULL) {
+        av_log(dec_ctx, AV_LOG_ERROR, "DWL Init failed\n");
+        return -1;
+    } else {
+        av_log(dec_ctx, AV_LOG_DEBUG, "DWL Init success\n");
+    }
+
+    if ((dec_ctx->decode_mode & DEC_LOW_LATENCY) != 0) {
+        dec_ctx->low_latency = 1;
+    }
+
+    dec_cfg.decoder_mode = DEC_NORMAL;
+    if (dec_ctx->low_latency)
+        dec_cfg.decoder_mode = DEC_LOW_LATENCY;
+
+    dec_cfg.align = config.align;
+    if (dec_ctx->enable_mc)
+        dec_cfg.mcinit_cfg.mc_enable = 1;
+    else
+        dec_cfg.mcinit_cfg.mc_enable = 0;
+    dec_cfg.mcinit_cfg.stream_consumed_callback = NULL;
+    memcpy(dec_cfg.ppu_config, config.ppu_cfg, sizeof(config.ppu_cfg));
+    memcpy(dec_cfg.delogo_params, config.delogo_params, sizeof(config.delogo_params));
+
+    jpeg_ret = JpegDecInit(&dec_ctx->dec_inst, dec_ctx->dwl_inst, &dec_cfg);
+
+    return jpeg_ret;
+}
+
+enum DecRet jpeg_dec_get_info(VSVDECContext *dec_ctx)
+{
+    void *inst = (void* )dec_ctx->dec_inst;
+    struct DecSequenceInfo *info = &dec_ctx->sequence_info;
+    JpegDecInput jpeg_input;
+    enum DecRet rv;
+    JpegDecImageInfo image_info;
+
+    jpeg_input.stream_buffer = info->jpeg_input_info.stream_buffer;
+    jpeg_input.stream_length = info->jpeg_input_info.strm_len;
+    jpeg_input.buffer_size = info->jpeg_input_info.buffer_size;
+    jpeg_input.stream = info->jpeg_input_info.stream;
+
+    DWLmemset(&image_info, 0, sizeof(image_info));
+
+    rv = JpegDecGetImageInfo(inst, &jpeg_input, &image_info);
+
+    if(rv != DEC_OK) {
+        return rv;
+    }
+
+    info->scaled_width = image_info.display_width;
+    info->scaled_height = image_info.display_height;
+    info->pic_width = image_info.output_width;
+    info->pic_height = image_info.output_height;
+    info->scaled_width_thumb = image_info.display_width_thumb;
+    info->scaled_height_thumb = image_info.display_height_thumb;
+    info->pic_width_thumb = image_info.output_width_thumb;
+    info->pic_height_thumb = image_info.output_height_thumb;
+    info->output_format = image_info.output_format;
+    info->output_format_thumb = image_info.output_format_thumb;
+    info->coding_mode = image_info.coding_mode;
+    info->coding_mode_thumb = image_info.coding_mode_thumb;
+    info->thumbnail_type = image_info.thumbnail_type;
+    info->img_max_dec_width = image_info.img_max_dec_width;
+    info->img_max_dec_height = image_info.img_max_dec_height;
+    /* update the alignment setting in "image_info" data structure and output picture width */
+    info->pic_width = NEXT_MULTIPLE(info->pic_width, ALIGN(dec_ctx->vsv_dec_config.align));
+    info->pic_width_thumb = NEXT_MULTIPLE(info->pic_width_thumb, ALIGN(dec_ctx->vsv_dec_config.align));
+
+    return rv;
+}
+
+enum DecRet jpeg_dec_set_info(const void *inst, struct DecConfig config)
+{
+    struct JpegDecConfig dec_cfg;
+    dec_cfg.dec_image_type = config.dec_image_type;
+    dec_cfg.align = config.align;
+
+    DWLmemcpy(dec_cfg.ppu_config, config.ppu_cfg, sizeof(config.ppu_cfg));
+    DWLmemcpy(dec_cfg.delogo_params, config.delogo_params, sizeof(config.delogo_params));
+
+    return JpegDecSetInfo(inst, &dec_cfg);
+}
+
+enum DecRet jpeg_get_buffer_info(void *inst, struct DecBufferInfo *buf_info) 
+{
+    struct DecBufferInfo hbuf;
+    enum DecRet rv;
+    rv = JpegDecGetBufferInfo(inst, &hbuf);
+
+    buf_info->next_buf_size = hbuf.next_buf_size;
+    buf_info->buf_num = hbuf.buf_num;
+    buf_info->buf_to_free = hbuf.buf_to_free;
+
+    return rv;
+}
+
+enum DecRet jpeg_decode(AVCodecContext *avctx,void* inst, struct DecInputParameters* jpeg_in)
+{
+    enum DecRet rv;
+    JpegDecInput jpeg_input;
+    JpegDecOutput jpeg_out;
+    DWLmemset(&jpeg_input, 0, sizeof(jpeg_input));
+    DWLmemset(&jpeg_out, 0, sizeof(jpeg_out));
+
+    jpeg_input.stream_buffer =jpeg_in->stream_buffer;
+    jpeg_input.stream_length = jpeg_in->strm_len;
+    jpeg_input.buffer_size = jpeg_in->buffer_size;
+    jpeg_input.dec_image_type = jpeg_in->dec_image_type;
+    jpeg_input.slice_mb_set = jpeg_in->slice_mb_set;
+    jpeg_input.ri_count = jpeg_in->ri_count;
+    jpeg_input.ri_array = jpeg_in->ri_array;
+    jpeg_input.picture_buffer_y = jpeg_in->picture_buffer_y;
+    jpeg_input.picture_buffer_cb_cr = jpeg_in->picture_buffer_cb_cr;
+    jpeg_input.picture_buffer_cr = jpeg_in->picture_buffer_cr;
+    jpeg_input.p_user_data = jpeg_in->p_user_data;
+    jpeg_input.stream = jpeg_in->stream;
+
+    rv = JpegDecDecode(inst, &jpeg_input, &jpeg_out);
+
+    return rv;
+}
+
+enum DecRet jpeg_next_picture(AVCodecContext *avctx,const void *inst, struct DecPicturePpu *pic)
+{
+    enum DecRet rv;
+    JpegDecOutput jpic;
+    JpegDecImageInfo info;
+    u32 stride, stride_ch, i;
+    VSVDECContext *dec_ctx  = avctx->priv_data;
+
+    memset(&jpic, 0, sizeof(JpegDecOutput));
+    memset(pic, 0, sizeof(struct DecPicturePpu));
+    rv = JpegDecNextPicture(inst, &jpic, &info);
+
+    if (rv != DEC_PIC_RDY)
+        return rv;
+    for (i = 0; i < DEC_MAX_OUT_COUNT; i++)
+    {
+        stride = jpic.pictures[i].pic_stride;
+        stride_ch = jpic.pictures[i].pic_stride_ch;
+
+        pic->pictures[i].picture_info.cycles_per_mb = jpic.cycles_per_mb;
+        pic->pictures[i].luma = jpic.pictures[i].output_picture_y;
+        pic->pictures[i].chroma = jpic.pictures[i].output_picture_cb_cr;
+        pic->pictures[i].chroma_cr = jpic.pictures[i].output_picture_cr;
+        pic->pictures[i].sequence_info.pic_width = jpic.pictures[i].output_width;
+        pic->pictures[i].sequence_info.pic_height = jpic.pictures[i].output_height;
+        pic->pictures[i].sequence_info.scaled_width = jpic.pictures[i].display_width;
+        pic->pictures[i].sequence_info.scaled_height = jpic.pictures[i].display_height;
+        pic->pictures[i].sequence_info.pic_width_thumb = jpic.pictures[i].output_width_thumb;
+        pic->pictures[i].sequence_info.pic_height_thumb = jpic.pictures[i].output_height_thumb;
+        pic->pictures[i].sequence_info.scaled_width_thumb = jpic.pictures[i].display_width_thumb;
+        pic->pictures[i].sequence_info.scaled_height_thumb = jpic.pictures[i].display_height_thumb;
+        pic->pictures[i].sequence_info.bit_depth_luma = jpic.bit_depth;
+        pic->pictures[i].sequence_info.bit_depth_chroma = jpic.bit_depth;
+
+        if(dec_ctx->thum_out == 0){
+            pic->pictures[i].pic_width = jpic.pictures[i].display_width;
+            pic->pictures[i].pic_height = jpic.pictures[i].display_height;
+        }else{
+            pic->pictures[i].pic_width = jpic.pictures[i].display_width_thumb;
+            pic->pictures[i].pic_height = jpic.pictures[i].display_height_thumb;
+        }
+
+        if (IS_PIC_TILE(jpic.pictures[i].output_format)) {
+            pic->pictures[i].luma.size = stride * (NEXT_MULTIPLE(pic->pictures[i].pic_height, 4) / 4);
+            pic->pictures[i].chroma.size = stride_ch * (NEXT_MULTIPLE(pic->pictures[i].pic_height / 2, 4) / 4);
+        } else if (IS_PIC_PLANAR(jpic.pictures[i].output_format)) {
+            pic->pictures[i].luma.size = stride * pic->pictures[i].pic_height;
+            pic->pictures[i].chroma.size = stride_ch * pic->pictures[i].pic_height;
+        } else if (jpic.pictures[i].output_format == DEC_OUT_FRM_RFC) {
+            pic->pictures[i].luma.size = stride * pic->pictures[i].pic_height / 4;
+            pic->pictures[i].chroma.size = stride_ch * pic->pictures[i].pic_height / 8;
+        } else {
+            pic->pictures[i].luma.size = stride * pic->pictures[i].pic_height;
+            if (!IS_PIC_RGB(jpic.pictures[i].output_format))
+                pic->pictures[i].chroma.size = stride_ch * pic->pictures[i].pic_height / 2;
+        }
+
+        pic->pictures[i].pic_stride = jpic.pictures[i].pic_stride;
+        pic->pictures[i].pic_stride_ch = jpic.pictures[i].pic_stride_ch;
+        pic->pictures[i].picture_info.format = jpic.pictures[i].output_format;
+#ifdef SUPPORT_DEC400
+        pic->pictures[i].dec400_luma_table = jpic.pictures[i].dec400_luma_table;
+        pic->pictures[i].dec400_chroma_table = jpic.pictures[i].dec400_chroma_table;
+
+#endif
+    }
+    pic->pictures[0].sequence_info.output_format = info.output_format;
+    pic->pictures[0].sequence_info.output_format_thumb = info.output_format_thumb;
+    pic->pictures[0].sequence_info.coding_mode = info.coding_mode;
+    pic->pictures[0].sequence_info.coding_mode_thumb = info.coding_mode_thumb;
+    pic->pictures[0].sequence_info.thumbnail_type = info.thumbnail_type;
+
+    return rv;
+}
+
+int ff_es_jpeg_allocate_input_buffer(VSVDECContext *dec_ctx) {
+    uint32_t n_cores;
+    int ret = 0;
+
+#ifdef MODEL_SIMULATION
+    n_cores = DWLReadAsicCoreCount();
+#else
+    n_cores = DWLReadAsicCoreCount(dec_ctx->dwl_init.client_type);
+#endif
+    /* number of stream buffers to allocate */
+    dec_ctx->allocated_buffers = n_cores + 1;
+
+    if (dec_ctx->allocated_buffers < NUM_OF_STREAM_BUFFERS) {
+        dec_ctx->allocated_buffers = NUM_OF_STREAM_BUFFERS;
+    } else if (dec_ctx->allocated_buffers > MAX_STRM_BUFFERS) {
+        dec_ctx->allocated_buffers = MAX_STRM_BUFFERS;
+    }
+
+    for (int i = 0; i < dec_ctx->allocated_buffers; i++) {
+        dec_ctx->stream_mem[i].mem_type = DWL_MEM_TYPE_DMA_HOST_TO_DEVICE | DWL_MEM_TYPE_CPU ;
+        if (DWLMallocLinear(dec_ctx->dwl_inst, JPEG_INPUT_BUFFER_SIZE, dec_ctx->stream_mem + i) != DWL_OK) {
+            av_log(dec_ctx, AV_LOG_ERROR, "Unable to allocate stream buffer memory!\n");
+            ret = -1;
+            break;
+        } else {
+            av_log(dec_ctx, AV_LOG_DEBUG,
+                    "Alloc memory for %d stream ,addr = 0x%p, size is 0x%x OK\n",
+                    i,
+                    dec_ctx->stream_mem[i].virtual_address,
+                    dec_ctx->stream_mem[i].size);
+        }
+    }
+
+    return ret;
+}
+
+void ff_es_jpeg_dwl_output_mempry_free(void *opaque, uint8_t *data) {
+    ESJpegOutputMemory *memory = (ESJpegOutputMemory *)data;
+    if (!opaque || !memory) {
+        av_log(NULL, AV_LOG_ERROR, "error !!! opaque or mem is null mem: %p\n", memory);
+        return;
+    }
+    av_log(NULL, AV_LOG_DEBUG, "dwl output memory free size: %d, virtual_address: %p\n", memory->mem.size, memory->mem.virtual_address);
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (memory->fd[i] >= 0) {
+            av_log(NULL, AV_LOG_DEBUG, "output buffer close  pp_fd[%d]: %d\n", i, memory->fd[i]);
+            close(memory->fd[i]);
+            memory->fd[i] = -1;
+        }
+    }
+
+    DWLFreeLinear(opaque, &memory->mem);
+}
+
+int ff_es_jpeg_output_buffer_fd_split(void *dwl_inst,
+                                      void *dec_inst,
+                                      ESJpegOutputMemory *memory,
+                                      struct DecConfig *dec_config) {
+    int ret = SUCCESS;
+    int dma_fd;
+    int pp_count = 0;
+    struct ESDecoderWrapper esjdec;
+
+    if (ESDecIsSimulation()) {
+        return SUCCESS;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        memory->fd[i] = -1;
+    }
+
+    if (!dwl_inst || !dec_inst || !memory || !dec_config) {
+        av_log(NULL, AV_LOG_ERROR,
+                  "error !!! dwl_inst: %p, dec_inst: %p, memory: %p, dec_config: %p\n",
+                  dwl_inst,
+                  dec_inst,
+                  memory,
+                  dec_config);
+
+        return FAILURE;
+    }
+
+    esjdec.codec = DEC_JPEG;
+    esjdec.inst = dec_inst;
+
+    dma_fd = ESDecGetDmaBufFd(&memory->mem);
+    if (dma_fd < 0) {
+       av_log(NULL, AV_LOG_ERROR, "dma fd is error dma_fd: %d\n", dma_fd);
+        return FAILURE;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (dec_config->ppu_cfg[i].enabled) {
+            memory->fd[i] = dma_fd;
+            pp_count++;
+        }
+    }
+    av_log(NULL, AV_LOG_DEBUG, "pp_count: %d\n", pp_count);
+
+    if (pp_count == ES_VID_DEC_MAX_OUT_COUNT) {
+        ret = ESDecGetDmaFdSplit(dwl_inst, &esjdec, dma_fd, memory->fd, ES_VID_DEC_MAX_OUT_COUNT);
+    }
+
+    return ret;
+}
+
+int ff_es_jpeg_allocate_output_buffer(VSVDECContext *dec_ctx,
+                                      struct DecBufferInfo *buf_info) {
+    struct DecConfig *config = &dec_ctx->vsv_dec_config;
+    struct DWLLinearMem *mem;
+    int output_buf_num = 0;
+    int ret = 0;
+
+    av_log(dec_ctx, AV_LOG_INFO, "allocate output buffer\n");
+
+    if(buf_info->next_buf_size && !dec_ctx->extra_buffer_num) {//&& !add_external_buffer
+        /* Only add minimum required buffers at first. */
+        dec_ctx->buffer_size = buf_info->next_buf_size;
+
+        if (buf_info->buf_num < JPEG_OUTPUT_BUFFER_NUM) {
+            output_buf_num = JPEG_OUTPUT_BUFFER_NUM;
+        } else {
+            output_buf_num = buf_info->buf_num;
+        }
+
+        for(int i = 0; i < output_buf_num; i++) {
+            uint32_t id;
+            ESJpegOutputMemory *memory;
+
+            memory = &dec_ctx->output_memory_list.output_memory[i];
+            mem = &memory->mem;
+#ifdef ENABLE_FPGA_VERIFICATION
+            mem.mem_type = DWL_MEM_TYPE_DMA_DEVICE_TO_HOST |
+                        DWL_MEM_TYPE_DPB;
+#else
+            mem->mem_type = DWL_MEM_TYPE_DPB;
+#endif
+            if (dec_ctx->pp_enabled)
+                ret = DWLMallocLinear(dec_ctx->dwl_inst, buf_info->next_buf_size, mem);
+            else
+                ret = DWLMallocRefFrm(dec_ctx->dwl_inst, buf_info->next_buf_size, mem);
+            if (ret || mem->virtual_address == NULL) {
+                dec_ctx->output_memory_list.size = i;
+                av_log(dec_ctx, AV_LOG_ERROR, "index: %d virtual_address is null\n", i);
+                return -1;
+            }
+
+            ff_es_jpeg_output_buffer_fd_split(dec_ctx->dwl_inst,
+                                              dec_ctx->dec_inst,
+                                              memory,
+                                              config);
+
+            memset(mem->virtual_address, 0, mem->size);
+
+            ret = JpegDecAddBuffer(dec_ctx->dec_inst, mem);
+
+            av_log(dec_ctx, AV_LOG_DEBUG, "DecAddBuffer ret %d\n", ret);
+            if(ret != DEC_OK) {
+                int dma_fd = ESDecGetDmaBufFd(&memory->mem);
+                for (int index = 0; index < ES_VID_DEC_MAX_OUT_COUNT; index++) {
+                    if (memory->fd[index] >= 0 && memory->fd[index] != dma_fd) {
+                        av_log(dec_ctx,
+                               AV_LOG_ERROR,
+                               "DecAddBuffer error, close  pp_fd[%d]: %d\n",
+                               index, memory->fd[index]);
+                        close(memory->fd[index]);
+                        memory->fd[index] = -1;
+                    }
+                }
+                if (dec_ctx->pp_enabled)
+                    DWLFreeLinear(dec_ctx->dwl_inst, mem);
+                else
+                    DWLFreeRefFrm(dec_ctx->dwl_inst, mem);
+            } else {
+                id = ff_es_jpeg_dec_find_empty_index(dec_ctx);
+                dec_ctx->output_memory_list.output_memory[i].virtual_address = mem->virtual_address;
+                dec_ctx->buffer_consumed[id] = 1;
+                if (id >= dec_ctx->output_memory_list.size)
+                    dec_ctx->output_memory_list.size++;
+            }
+        }
+        dec_ctx->extra_buffer_num = 1;
+        for(int i = 0; i < dec_ctx->output_memory_list.size; i++) {
+            av_log(dec_ctx, AV_LOG_DEBUG, "output_memory[%d].fd[0]: %lx\n",
+                                        i, dec_ctx->output_memory_list.output_memory[i].fd[0]);
+            av_log(dec_ctx, AV_LOG_DEBUG, "output_memory[%d].fd[0]: %lx\n",
+                                        i, dec_ctx->output_memory_list.output_memory[i].fd[1]);
+        }
+    }
+
+    return 0;
+}
+
+static void ff_es_jpeg_fill_planes(OutPutInfo *pri_picture, struct DecPicture *pic)
+{
+    if (!pri_picture || !pic) {
+        av_log(NULL, AV_LOG_ERROR, "info  or picture is null out: %p\n", &pic);
+        return;
+    }
+
+    pri_picture->key_frame = (pic->picture_info.pic_coding_type == DEC_PIC_TYPE_I);
+    pri_picture->width = pic->pic_width;
+    pri_picture->height = pic->pic_height;
+    pri_picture->bus_address = pic->luma.bus_address;
+    pri_picture->virtual_address = pic->luma.virtual_address;
+    pri_picture->format = ff_codec_decfmt_to_pixfmt(pic->picture_info.format);
+    switch(pri_picture->format) {
+        case AV_PIX_FMT_NV12:
+        case AV_PIX_FMT_NV21:
+        case AV_PIX_FMT_P010LE:{
+            pri_picture->n_planes = 2;
+            pri_picture->stride[0] = pic->pic_stride;
+            pri_picture->stride[1] = pic->pic_stride_ch;
+            pri_picture->offset[0] = 0;
+            pri_picture->offset[1] = pic->pic_stride * pic->pic_height;
+            pri_picture->size = pri_picture->offset[1] * 3 / 2;
+            av_log(NULL, AV_LOG_DEBUG, "format: %d width: %d, height: %d, stride: %d, size: %zu\n",
+                                        pri_picture->format, pri_picture->width, pri_picture->height,
+                                        pri_picture->stride[0], pri_picture->size);
+            break;
+        }
+        case AV_PIX_FMT_YUV420P:
+        case AV_PIX_FMT_YUV420P10LE:{
+            pri_picture->n_planes = 3;
+            pri_picture->offset[0] = 0;
+            pri_picture->stride[0] = pic->pic_stride;
+            pri_picture->offset[1] = pic->pic_stride * pic->pic_height;
+            pri_picture->stride[1] = pic->pic_stride_ch;
+            pri_picture->offset[2] = pri_picture->offset[1] +
+                                     pic->pic_stride_ch * pic->pic_height / 2;
+            pri_picture->stride[2] = pri_picture->stride[1];
+            pri_picture->size = pri_picture->offset[1] + pic->pic_stride_ch * pic->pic_height;
+            av_log(NULL, AV_LOG_DEBUG, "format: %d width: %d, height: %d, stride: %d, size: %zu\n",
+                                        pri_picture->format, pri_picture->width,
+                                        pri_picture->height, pri_picture->stride[0],
+                                        pri_picture->size);
+            break;
+        }
+        case AV_PIX_FMT_GRAY8:
+        case AV_PIX_FMT_RGB24:
+        case AV_PIX_FMT_BGR24:
+        case AV_PIX_FMT_ARGB:
+        case AV_PIX_FMT_ABGR:
+        case AV_PIX_FMT_0RGB:
+        case AV_PIX_FMT_0BGR:
+            pri_picture->n_planes = 1;
+            pri_picture->stride[0] = pic->pic_stride;
+            pri_picture->offset[0] = 0;
+            pri_picture->size = pic->pic_stride * pic->pic_height;
+            av_log(NULL, AV_LOG_INFO, "format: %d width: %d, height: %d, stride: %d, size: %zu\n",
+                                       pri_picture->format, pri_picture->width, pri_picture->height,
+                                       pri_picture->stride[0], pri_picture->size);
+            break;
+
+        default:{
+        }
+    }
+}
+
+static ESJpegOutputMemory *ff_es_jpeg_find_memory_by_picture(VSVDECContext *dec_ctx, struct DecPicturePpu *pic) {
+    ESJpegOutputMemory *memory = NULL;
+    uint32_t *virtual_address = NULL;
+    if (!dec_ctx || !pic) {
+        av_log(NULL, AV_LOG_ERROR, "ctx or out_buffers or picture is null\n");
+        return NULL;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (pic->pictures[i].luma.virtual_address != NULL) {
+            virtual_address = pic->pictures[i].luma.virtual_address;
+            av_log(NULL, AV_LOG_DEBUG, "index: %d, virtual_address: %p\n", i, pic->pictures[i].luma.virtual_address);
+            break;
+        }
+    }
+
+    if (!virtual_address) {
+        av_log(NULL, AV_LOG_ERROR, "find virtual_address failed from picture\n");
+        return NULL;
+    }
+
+    for (int i = 0; i < dec_ctx->output_memory_list.size; i++) {
+        memory = &dec_ctx->output_memory_list.output_memory[i];
+        if (memory->virtual_address == virtual_address) {
+            av_log(NULL, AV_LOG_DEBUG, "find output buffer i: %d, virtual_address: %p\n", i, virtual_address);
+            break;
+        }
+    }
+
+    if (!memory) {
+        av_log(NULL, AV_LOG_ERROR, "find buffer failed virtual_address: %p\n", virtual_address);
+    }
+
+    return memory;
+}
+
+static void ff_es_jpeg_fill_out_frame(VSVDECContext *dec_ctx, AVFrame *frame, struct DecPicturePpu *pic)
+{
+    int index = -1;
+    DecPicturePri *pri_pic = NULL;
+    OutPutInfo *info = NULL;
+    uint64_t dma_fd;
+    ESJpegOutputMemory *memory;
+
+    if (!frame || !pic) {
+        av_log(NULL, AV_LOG_ERROR, "frame or pic is null out: %p", frame);
+        return;
+    }
+
+    pri_pic = av_mallocz(sizeof(*pri_pic));
+    if (!pri_pic){
+        av_log(NULL, AV_LOG_ERROR, "pri_pic av mallocz failed");
+        return;
+    }
+
+    memory = ff_es_jpeg_find_memory_by_picture(dec_ctx, pic);
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        pri_pic->pictures[i].enabled = pic->pictures[i].pp_enabled;
+        if (pic->pictures[i].pp_enabled) {
+            report_dec_pic_info(dec_ctx, &pic->pictures[i]);
+            pri_pic->pic_count++;
+            pri_pic->pictures[i].fd = memory->fd[i];
+            ff_es_jpeg_fill_planes(&pri_pic->pictures[i], &pic->pictures[i]);
+            if (i == dec_ctx->pp_out) {
+                pri_pic->default_index = i;
+                pri_pic->default_pic = &pri_pic->pictures[i];
+            } else if (index == -1) {
+                index = i;
+            }
+        }
+    }
+
+    if (pri_pic->pic_count > 0){
+        if (!pri_pic->default_pic) {
+            pri_pic->default_index = index;
+            pri_pic->default_pic = &pri_pic->pictures[index];
+            av_log(NULL, AV_LOG_WARNING, "DEFAULT_INDEX: %d, real pic_index: %d", dec_ctx->pp_out, index);
+        }
+        info = pri_pic->default_pic;
+        frame->format = info->format;
+        frame->width = info->width;
+        frame->height = info->height;
+        frame->key_frame = info->key_frame;
+        for(int i = 0; i < info->n_planes; i++)
+        {
+            frame->data[i] = (uint8_t *)info->virtual_address + info->offset[i];
+            frame->linesize[i] = info->stride[i];
+        }
+        if (ESDecIsSimulation()){
+            dma_fd = (uint64_t)info->virtual_address;
+        }
+        else{
+            dma_fd = (uint64_t)info->fd;
+        }
+        av_log(NULL, AV_LOG_INFO, "sned dma_fd: %lx\n", dma_fd);
+        ff_es_codec_add_fd_to_side_data(frame, dma_fd);
+
+        frame->buf[0] = av_buffer_create((uint8_t *)pri_pic,
+                                sizeof(DecPicturePri),
+                                dec_ctx->data_free,
+                                dec_ctx, AV_BUFFER_FLAG_READONLY);
+    } else {
+        av_log(NULL, AV_LOG_ERROR, "error !!! no picture");
+    }
+}
+
+int ff_es_jpeg_dec_output_frame(AVCodecContext *avctx, AVFrame *out,
+                            struct DecPicturePpu *decoded_pic)
+{
+    int ret = -1;
+    int i;
+    VSVDECContext *dec_ctx  = avctx->priv_data;
+    AVVSVFramesContext *frame_hwctx;
+    AVHWFramesContext *hwframe_ctx;
+    struct DecPicturePpu *pic = av_mallocz(sizeof(*pic));
+    DecPicturePri *pri_pic = av_mallocz(sizeof(*pri_pic));
+
+    if(!pic)
+        return AVERROR(ENOMEM);
+
+    memset(pri_pic, 0, sizeof(DecPicturePri));
+    memcpy(pic, decoded_pic, sizeof(struct DecPicturePpu));
+
+    av_log(avctx, AV_LOG_DEBUG, "dec output pic @: %p\n",pic);
+
+    dec_ctx->cycle_count += pic->pictures[0].picture_info.cycles_per_mb;
+
+    ret = ff_decode_frame_props(avctx, out);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "ff_decode_frame_props failed\n");
+        return ret;
+    }
+
+    out->opaque_ref = av_buffer_allocz(sizeof(VSVFramePriv));
+
+    if (out->opaque_ref == NULL)
+        goto err_exit;
+    out->opaque = out->opaque_ref->data;
+
+    for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        PpUnitConfig * pp = &dec_ctx->vsv_dec_config.ppu_cfg[i];
+        if (pp->enabled == 1) {
+            pic->pictures[i].pp_enabled = 1;
+            pri_pic->pic_count++;
+            av_log(avctx, AV_LOG_DEBUG,
+                   "pic.pictures[%d].pp_enabled = %d\n",
+                   i,pic->pictures[i].pp_enabled);
+        } else {
+            pic->pictures[i].pp_enabled = 0;
+        }
+    }
+
+    for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        av_log(avctx, AV_LOG_DEBUG,
+               "pic.pictures[%d].pp_enabled = %d,bit_depth_luma=%d ,pic.pictures[%d].luma.virtual_address=%p\n",
+               i,pic->pictures[i].pp_enabled,pic->pictures[i].sequence_info.bit_depth_luma,i,pic->pictures[i].luma.virtual_address);
+    }
+
+    ff_es_jpeg_fill_out_frame(dec_ctx, out, pic);
+
+    if (out->buf[0] == NULL) {
+        goto err_exit;
+    }
+
+    add_dec_pic_wait_consume_list(dec_ctx, pic);
+
+    return 0;
+err_exit:
+
+    return -1;
+}
+
+int ff_es_jpeg_dec_output_thum(AVCodecContext *avctx, AVFrame *out,
+                            struct DecPicturePpu *decoded_pic)
+{
+    int ret = -1;
+    int i;
+    VSVDECContext *dec_ctx  = avctx->priv_data;
+    AVVSVFramesContext *frame_hwctx;
+    AVHWFramesContext *hwframe_ctx;
+    struct DecPicturePpu *pic = av_mallocz(sizeof(*pic));
+    DecPicturePri *pri_pic;
+    ESJpegOutputMemory *memory;
+
+    if (!pic)
+        return AVERROR(ENOMEM);
+
+    if (!out || !out->data) {
+        av_log(avctx, AV_LOG_ERROR, "output frame is invaild");
+        goto err_exit;
+    }
+    pri_pic = (DecPicturePri *)out->buf[0]->data;
+
+    memcpy(pic, decoded_pic, sizeof(struct DecPicturePpu));
+
+    av_log(avctx, AV_LOG_DEBUG, "dec output pic @: %p\n",pic);
+    report_dec_pic_info(avctx, pic);
+
+    dec_ctx->cycle_count += pic->pictures[0].picture_info.cycles_per_mb;
+
+    PpUnitConfig * pp = &dec_ctx->vsv_dec_config.ppu_cfg[dec_ctx->pp_out];
+    if (pp->enabled == 1) {
+        pic->pictures[dec_ctx->pp_out].pp_enabled = 1;
+        pri_pic->pic_count++;
+        av_log(avctx, AV_LOG_DEBUG,
+                "thumbnail default output pic.pictures[%d].pp_enabled = %d\n",
+                dec_ctx->pp_out,
+                pic->pictures[dec_ctx->pp_out].pp_enabled);
+    } else {
+        pic->pictures[dec_ctx->pp_out].pp_enabled = 0;
+        av_log(avctx, AV_LOG_ERROR,
+                "thumbnail default output pictures[%d].pp_enabled = %d\n",
+                dec_ctx->pp_out,
+                pic->pictures[dec_ctx->pp_out].pp_enabled);
+        goto err_exit;
+    }
+
+    memory = ff_es_jpeg_find_memory_by_picture(dec_ctx, pic);
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (i == dec_ctx->pp_out) {
+            if (pic->pictures[i].pp_enabled) {
+                pri_pic->pic_count++;
+                pri_pic->pictures[2].enabled = 1;
+                pri_pic->pictures[2].fd = memory->fd[i];
+                ff_es_jpeg_fill_planes(&pri_pic->pictures[2], &pic->pictures[dec_ctx->pp_out]);
+            }
+            break;
+        }
+    }
+
+    add_dec_pic_wait_consume_list(dec_ctx, pic);
+
+    return 0;
+err_exit:
+
+    return -1;
+}
+
+int ff_es_jpeg_dec_send_avpkt_to_decode_buffer(AVCodecContext *avctx, AVPacket *avpkt,
+                                           struct DWLLinearMem stream_buffer)
+{
+    //VSVDECContext *dec_ctx  = avctx->priv_data;
+    int ret = 0;
+
+    if (avpkt->data && avpkt->size)
+        memcpy((uint8_t*)stream_buffer.virtual_address, avpkt->data, avpkt->size);
+    //stream_buffer.bus_address
+//#ifdef  NEW_MEM_ALLOC
+    //if( stream_buffer.bus_address_rc != 0) {
+        //ret = dwl_edma_rc2ep_nolink(dec_ctx->dwl_inst, stream_buffer.bus_address_rc,
+                                    //stream_buffer.bus_address, stream_buffer.size);
+    //}
+//#endif
+
+    return ret;
+}
+
+void ff_es_jpeg_dec_init_dec_input_paras(AVPacket *avpkt,
+                                         VSVDECContext *dec_ctx,
+                                         struct DecInputParameters *jpeg_in) {
+    DWLmemset(jpeg_in, 0, sizeof(*jpeg_in));
+    jpeg_in->stream_buffer.virtual_address = (u32 *) dec_ctx->stream_mem[dec_ctx->stream_mem_index].virtual_address;
+    jpeg_in->stream_buffer.bus_address =  (addr_t)dec_ctx->stream_mem[dec_ctx->stream_mem_index].bus_address;
+    jpeg_in->stream_buffer.logical_size = dec_ctx->stream_mem[dec_ctx->stream_mem_index].logical_size;
+    jpeg_in->stream = (u8 *) dec_ctx->stream_mem[dec_ctx->stream_mem_index].virtual_address;
+    jpeg_in->strm_len = avpkt->size;
+    if(dec_ctx->low_latency) {
+        jpeg_in->strm_len = dec_ctx->sw_hw_bound;
+    }
+    jpeg_in->buffer_size = 0;
+    jpeg_in->dec_image_type = JPEGDEC_IMAGE;
+}
+
+void ff_es_jpeg_set_ppu_output_format(VSVDECContext *dec_ctx, struct DecConfig *config){
+    int i;
+
+    for(i = 0;  i< ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if(config->ppu_cfg[i].enabled == 1 ) {
+
+            enum DecPictureFormat dstpicfmt = ff_codec_pixfmt_to_decfmt(dec_ctx->output_format[i]);
+
+            av_log(NULL,AV_LOG_DEBUG,"[%s:%d]  dec_ctx->output_format[%d]; %d  dstpicfmt: %d\n",
+                                       __func__,__LINE__, i,
+                                       dec_ctx->output_format[i],dstpicfmt);
+
+            switch (dstpicfmt) {
+                case DEC_OUT_FRM_NV21SP:
+                    config->ppu_cfg[i].cr_first = 1;
+                    break;
+
+                case DEC_OUT_FRM_YUV420SP:
+                    // todo
+                    break;
+
+                case DEC_OUT_FRM_YUV420P:
+                    config->ppu_cfg[i].planar = 1;
+                    break;
+
+                case DEC_OUT_FRM_YUV400:
+                    config->ppu_cfg[i].monochrome = 1;
+                    break;
+
+                case DEC_OUT_FRM_RGB888:
+                case DEC_OUT_FRM_BGR888:
+                case DEC_OUT_FRM_XRGB888:
+                case DEC_OUT_FRM_XBGR888:
+                    config->ppu_cfg[i].rgb = 1;
+                    config->ppu_cfg[i].rgb_format = dstpicfmt;
+                    break;
+
+                case DEC_OUT_FRM_ARGB888:
+                case DEC_OUT_FRM_ABGR888:
+                    config->ppu_cfg[i].rgb = 1;
+                    config->ppu_cfg[i].rgb_stan = BT709;
+                    config->ppu_cfg[i].rgb_alpha = 255;
+                    config->ppu_cfg[i].rgb_format = dstpicfmt;
+                    break;
+
+                default:
+                    av_log(NULL,AV_LOG_ERROR,"[%s:%d] set ppu[%d] output_format failed,"
+                                             "avctx->output_format: %d dstpicfmt: %d\n",
+                                              __func__, __LINE__, i,
+                                              dec_ctx->output_format[i], dstpicfmt);
+                    break;
+            }
+        }
+    }
+}
+
+int ff_es_jpeg_parse_ppset(VSVDECContext *dec_ctx, CropInfo *crop_info, ScaleInfo *scale_info) {
+    int i;
+
+    for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        av_log(dec_ctx, AV_LOG_DEBUG, "dec_ctx->pp_setting[%d]: %s", i, dec_ctx->pp_setting[i]);
+
+        if (dec_ctx->pp_setting[i] || dec_ctx->crop_set[i] || (i == 1 && dec_ctx->scale_set)) {
+            int ret = 0;
+
+            if (dec_ctx->pp_setting[i]) {
+                ret = ff_codec_get_crop(dec_ctx->pp_setting[i], crop_info + i);
+            } else if (dec_ctx->crop_set[i]) {
+                ret = es_codec_get_crop(dec_ctx->crop_set[i], crop_info + i);
+            }
+            if (ret < 0) {
+                av_log(dec_ctx, AV_LOG_ERROR, "picture_%d crop config error, please check!", i);
+            }
+
+            if( i == 0)
+                continue;
+
+            ret = 0;
+            if (dec_ctx->pp_setting[i]) {
+                ret = ff_dec_get_scale(dec_ctx->pp_setting[i], scale_info + i, i);
+            } else if (dec_ctx->scale_set) {
+                ret = es_codec_get_scale(dec_ctx->scale_set, scale_info + i);
+            }
+            if (ret < 0) {
+                av_log(dec_ctx, AV_LOG_ERROR, "picture_%d scale config error, please check!", i);
+            }
+        }
+    }
+
+    return 0;
+}
+
+int ff_es_jpeg_set_ppu_crop_and_scale(VSVDECContext *dec_ctx, struct DecConfig *config)
+{
+    CropInfo crop_paras[ES_VID_DEC_MAX_OUT_COUNT];
+    ScaleInfo scale_paras[ES_VID_DEC_MAX_OUT_COUNT];
+    int i;
+    int pp_enabled = 0;
+
+    memset(crop_paras, 0, sizeof(CropInfo) * ES_VID_DEC_MAX_OUT_COUNT);
+    memset(scale_paras, 0, sizeof(ScaleInfo) * ES_VID_DEC_MAX_OUT_COUNT);
+
+    int ret = ff_es_jpeg_parse_ppset(dec_ctx, &crop_paras, &scale_paras);
+    if (ret < 0)
+        return -1;
+
+    //set crop paras
+    for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        // if config->ppu_cfg[i].enabled==0, crop is not assigned
+        if (!config->ppu_cfg[i].enabled||
+            (crop_paras[i].crop_xoffset == 0 && crop_paras[i].crop_yoffset == 0
+            && crop_paras[i].crop_width == 0 && crop_paras[i].crop_height == 0)) {
+            continue;
+        }
+
+        pp_enabled = 1;
+        config->ppu_cfg[i].crop.enabled = 1;
+        config->ppu_cfg[i].crop.set_by_user = 1;
+        config->ppu_cfg[i].crop.x = crop_paras[i].crop_xoffset;
+        config->ppu_cfg[i].crop.y = crop_paras[i].crop_yoffset;
+        config->ppu_cfg[i].crop.width = crop_paras[i].crop_width;
+        config->ppu_cfg[i].crop.height = crop_paras[i].crop_height;
+
+        av_log(NULL,AV_LOG_DEBUG,"[%s:%d]  ppu_cfg[%d].crop.x: %d  "
+                                           "ppu_cfg[%d].crop.y: %d  "
+                                           "ppu_cfg[%d].crop.width: %d  "
+                                           "ppu_cfg[%d].crop.height: %d\n",
+                                           __func__,__LINE__,
+                                           i,config->ppu_cfg[i].crop.x,
+                                           i,config->ppu_cfg[i].crop.y,
+                                           i,config->ppu_cfg[i].crop.width,
+                                           i,config->ppu_cfg[i].crop.height);
+    }
+
+    //set scale paras,pp0 not support scale
+    for (i = 1; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        // if config->ppu_cfg[i].enabled==0, scale is not assigned
+        if (!config->ppu_cfg[i].enabled||
+            scale_paras[i].scale_width == 0 && scale_paras[i].scale_height == 0) {
+            continue;
+        }
+        pp_enabled = 1;
+
+        if (!(scale_paras[i].scale_width == 0 && scale_paras[i].scale_height == 0)) {
+            config->ppu_cfg[i].scale.enabled = 1;
+            config->ppu_cfg[i].scale.width = scale_paras[i].scale_width;
+            config->ppu_cfg[i].scale.height = scale_paras[i].scale_height;
+            av_log(NULL,AV_LOG_DEBUG,"[%s:%d]  ppu_cfg[%d].scale.width: %d   "
+                                           "ppu_cfg[%d].scale.height: %d",
+                                           __func__, __LINE__,
+                                           i, config->ppu_cfg[i].scale.width,
+                                           i, config->ppu_cfg[i].scale.height);
+        }
+    }
+
+    dec_ctx->pp_enabled = pp_enabled;
+
+    return 0;
+}
+
+int ff_es_jpeg_get_align(uint32_t stride) {
+    switch (stride)
+    {
+        case 1:
+            return DEC_ALIGN_1B;
+        case 8:
+            return DEC_ALIGN_8B;
+        case 16:
+            return DEC_ALIGN_16B;
+        case 32:
+            return DEC_ALIGN_32B;
+        case 64:
+            return DEC_ALIGN_64B;
+        case 128:
+            return DEC_ALIGN_128B;
+        case 256:
+            return DEC_ALIGN_256B;
+        case 512:
+            return DEC_ALIGN_512B;
+        case 1024:
+            return DEC_ALIGN_1024B;
+        case 2048:
+            return DEC_ALIGN_2048B;
+
+        default:
+            av_log(NULL,AV_LOG_ERROR,"invaild stride: %d\n", stride);
+    }
+    return DEC_ALIGN_64B;
+}
+
+int ff_es_jpeg_init_frame_dump_handle(VSVDECContext *dec_ctx) {
+    int ret = 0;
+
+    for ( int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if(dec_ctx->cfg_pp_enabled[i] == 1 && dec_ctx->frame_dump[i] && !dec_ctx->frame_dump_handle[i]) {
+            DumpParas paras;
+            paras.width = dec_ctx->pic.pictures[i].pic_width;
+            paras.height = dec_ctx->pic.pictures[i].pic_height;
+            paras.pic_stride = dec_ctx->pic.pictures[i].pic_stride;
+            paras.pic_stride_ch = dec_ctx->pic.pictures[i].pic_stride_ch;
+            paras.prefix_name = "jdec";
+
+            if (i == 0)
+                paras.ppu_channel = "pp0";
+            else
+                paras.ppu_channel = "pp01";
+
+            if (IS_PIC_RGB_FMT(dec_ctx->pic.pictures[i].picture_info.format))
+                paras.suffix_name = "rgb";
+            else
+                paras.suffix_name = "yuv";
+
+            paras.fmt = ff_codec_decfmt_to_char(dec_ctx->pic.pictures[i].picture_info.format);
+
+            dec_ctx->frame_dump_handle[i] = ff_codec_dump_file_open(dec_ctx->dump_path, dec_ctx->frame_dump_time[i], &paras);
+
+        }
+    }
+
+    return ret;
+}
+
+int ff_es_jpeg_init_pkt_dump_handle(VSVDECContext *dec_ctx) {
+    int ret = 0;
+    struct DecSequenceInfo *info = &dec_ctx->sequence_info;
+    DumpParas paras;
+
+    if(dec_ctx->packet_dump && !dec_ctx->pkt_dump_handle) {
+        paras.width = info->pic_width;
+        paras.height = info->pic_height;
+        paras.pic_stride = 0;
+        paras.pic_stride_ch = 0;
+        paras.prefix_name = "jdec";
+        paras.suffix_name = "jpeg";
+        paras.fmt = NULL;
+        dec_ctx->pkt_dump_handle = ff_codec_dump_file_open(dec_ctx->dump_path, dec_ctx->packet_dump_time, &paras);
+    }
+
+    return ret;
+}
+
+int ff_es_jpeg_frame_dump(VSVDECContext *dec_ctx) {
+    int ret = 0;
+    for ( int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if(dec_ctx->cfg_pp_enabled[i] == 1 && dec_ctx->frame_dump[i]) {
+            if (dec_ctx->frame_dump_handle[i]) {
+                ret = ff_codec_dump_data_to_file_by_decpicture(&dec_ctx->pic.pictures[i], dec_ctx->frame_dump_handle[i]);
+                if (ret == ERR_TIMEOUT) {
+                    av_log(NULL, AV_LOG_INFO, "frame dump timeout\n");
+                    ff_codec_dump_file_close(&dec_ctx->frame_dump_handle[i]);
+                    dec_ctx->frame_dump[i] = 0;
+                    return 0;
+                } else if (ret < 0) {
+                    av_log(NULL, AV_LOG_ERROR, "write file error\n");
+                    return -1;
+                }
+            } else {
+                av_log(NULL, AV_LOG_ERROR,"fp is not inited\n");
+                return -1;
+            }
+        }
+    }
+
+    return 0;
+}
+
+int ff_es_jpeg_pkt_dump(VSVDECContext *dec_ctx) {
+    int ret = 0;
+    if(dec_ctx->packet_dump) {
+        if (dec_ctx->pkt_dump_handle) {
+            ret = ff_codec_dump_bytes_to_file(dec_ctx->avpkt.data, dec_ctx->avpkt.size,  dec_ctx->pkt_dump_handle);
+            if (ret == ERR_TIMEOUT) {
+                av_log(NULL, AV_LOG_INFO, "pkt dump timeout\n");
+                ff_codec_dump_file_close(&dec_ctx->pkt_dump_handle);
+                dec_ctx->packet_dump = 0;
+                return 0;
+            } else if (ret < 0) {
+                av_log(NULL, AV_LOG_ERROR, "write frame into file failed\n");
+                return -1;
+            }
+        } else {
+            av_log(NULL, AV_LOG_ERROR, "fp is not inited\n");
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+void ff_es_jpeg_dec_update_dec_input_paras(VSVDECContext *dec_ctx,
+                                            struct DecInputParameters *jpeg_in)
+{
+    if(dec_ctx->sequence_info.thumbnail_type == JPEGDEC_THUMBNAIL_JPEG) {
+        if (dec_ctx->thumb_mode == Only_Decode_Thumb) {
+            jpeg_in->dec_image_type =JPEGDEC_THUMBNAIL;
+            dec_ctx->thum_out = 1;
+        } else {
+            jpeg_in->dec_image_type = JPEGDEC_IMAGE;
+        }
+        dec_ctx->thum_exist = 1;
+        av_log(NULL, AV_LOG_DEBUG, "thumbnail exits\n");
+    } else if((dec_ctx->sequence_info.thumbnail_type == JPEGDEC_NO_THUMBNAIL)
+                ||(dec_ctx->sequence_info.thumbnail_type == JPEGDEC_THUMBNAIL_NOT_SUPPORTED_FORMAT)) {
+        jpeg_in->dec_image_type = JPEGDEC_IMAGE;
+    }
+}
+
+int ff_es_jpeg_dec_modify_thum_config_by_sequence_info(AVCodecContext *avctx)
+{
+    VSVDECContext *dec_ctx  = avctx->priv_data;
+    struct DecSequenceInfo *image_info = &dec_ctx->sequence_info;
+    struct DecConfig *config = &dec_ctx->vsv_dec_config;
+    int i;
+
+    u32 display_width = (image_info->scaled_width + 1) & ~0x1;
+    u32 display_height = (image_info->scaled_height + 1) & ~0x1;
+    u32 display_width_thumb = (image_info->scaled_width_thumb + 1) & ~0x1;
+    u32 display_height_thumb = (image_info->scaled_height_thumb + 1) & ~0x1;
+    u32 crop_width_thumb = 0;
+    u32 crop_height_thumb = 0;
+
+    if (!config->ppu_cfg[0].crop.set_by_user) {
+      config->ppu_cfg[0].crop.width = dec_ctx->thum_out ? display_width_thumb: display_width;
+      config->ppu_cfg[0].crop.height = dec_ctx->thum_out ? display_height_thumb: display_height;
+      config->ppu_cfg[0].crop.enabled = 1;
+    }
+    u32 crop_w = config->ppu_cfg[0].crop.width;
+    u32 crop_h = config->ppu_cfg[0].crop.height;
+
+    crop_width_thumb = NEXT_MULTIPLE(crop_w - 1, 2);
+    crop_height_thumb = NEXT_MULTIPLE(crop_h - 1, 2);
+    image_info->pic_width = NEXT_MULTIPLE(crop_width_thumb, ALIGN(config->align));
+    image_info->pic_width_thumb = NEXT_MULTIPLE(crop_width_thumb, ALIGN(config->align));
+    image_info->pic_height = crop_height_thumb;
+    image_info->pic_height_thumb = crop_height_thumb;
+
+    if (dec_ctx->thum_out == 1) {
+        for (i = 0; i < DEC_MAX_PPU_COUNT; i++) {
+            if (!config->ppu_cfg[i].enabled)
+                    continue;
+            if (config->ppu_cfg[i].scale.enabled == 1) {
+                config->ppu_cfg[i].scale.scale_by_ratio = 0;
+                config->ppu_cfg[i].scale.width = image_info->scaled_width_thumb;
+                config->ppu_cfg[i].scale.height = image_info->scaled_height_thumb;
+            }
+            if (config->ppu_cfg[i].crop.enabled == 1) {
+                config->ppu_cfg[i].crop.enabled = 0;
+                config->ppu_cfg[i].crop.set_by_user = 0;
+            }
+        }
+    }
+    return 0;
+}
+
+bool check_scale_value( uint32_t v) {
+    if (v == -1 || v == -2 || v == -4 || v == -8) {
+        return TRUE;
+    }
+    return FALSE;
+}
+
+int ff_es_jpeg_dec_modify_config_by_sequence_info(AVCodecContext *avctx)
+{
+    VSVDECContext *dec_ctx  = avctx->priv_data;
+    enum DecRet rv_info;
+
+    /* process pp size -1/-2/-4/-8. */
+    struct DecConfig *config = &dec_ctx->vsv_dec_config;
+    int i;
+    uint32_t alignh = dec_ctx->sequence_info.is_interlaced ? 4 : 2;
+    uint32_t alignw = 2;
+
+    uint32_t original_width = dec_ctx->sequence_info.pic_width;
+    uint32_t original_height = dec_ctx->sequence_info.pic_height;
+
+    //crop
+    for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (config->ppu_cfg[i].enabled && config->ppu_cfg[i].crop.enabled) {
+            if (config->ppu_cfg[i].crop.x > original_width ||
+                config->ppu_cfg[i].crop.y > original_height ||
+                ((config->ppu_cfg[i].crop.x + config->ppu_cfg[i].crop.width) > original_width) ||
+                ((config->ppu_cfg[i].crop.x + config->ppu_cfg[i].crop.height) > original_height)) {
+                av_log(avctx,AV_LOG_ERROR,"invalid crop config, original_width: %d original_height: %d\n",
+                    original_width, original_height);
+                return -1;
+            }
+
+            // check value
+            if(config->ppu_cfg[i].crop.width < 48 || config->ppu_cfg[i].crop.height < 48) {
+                av_log(avctx,AV_LOG_ERROR,"pp%d invalid crop config, crop.width: %d crop.height: %d, "
+                                               "request values equal to or more than 48\n",
+                                               i, config->ppu_cfg[i].crop.width, config->ppu_cfg[i].crop.height);
+                return -1;
+            }
+
+            if ((config->ppu_cfg[i].crop.width % 2) || (config->ppu_cfg[i].crop.height % 2)) {
+                av_log(avctx,AV_LOG_ERROR,"pp%d invalid crop config, crop.width: %d crop.height: %d, request values is even\n",
+                                               i, config->ppu_cfg[i].crop.width, config->ppu_cfg[i].crop.height);
+                config->ppu_cfg[i].crop.width = NEXT_MULTIPLE(config->ppu_cfg[i].crop.width, alignw);
+                config->ppu_cfg[i].crop.height = NEXT_MULTIPLE(config->ppu_cfg[i].crop.height, alignh);
+                //return -1;
+            }
+        }
+    }
+
+    // scale
+    for (i = 1; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (config->ppu_cfg[i].enabled && config->ppu_cfg[i].scale.enabled) {
+            if (check_scale_value(config->ppu_cfg[i].scale.width) ||
+                check_scale_value(config->ppu_cfg[i].scale.height)) {
+
+                if (config->ppu_cfg[i].scale.width == -1
+                    && config->ppu_cfg[i].scale.height == -1) {
+                    rv_info = DEC_INFOPARAM_ERROR;
+                    break;
+                }
+
+                if (config->ppu_cfg[i].crop.enabled) {
+                    if (config->ppu_cfg[i].crop.width != original_width) {
+                        original_width = config->ppu_cfg[i].crop.width;
+                    }
+                    if (config->ppu_cfg[i].crop.height != original_height) {
+                        original_height = config->ppu_cfg[i].crop.height;
+                    }
+                }
+
+                av_log(avctx,AV_LOG_DEBUG,"original_width = %d, original_height = %d\n",
+                    original_width, original_height);
+
+                if (config->ppu_cfg[i].scale.width == -1 &&
+                    !check_scale_value(config->ppu_cfg[i].scale.height) &&
+                    config->ppu_cfg[i].scale.height > 0) {
+                    config->ppu_cfg[i].scale.width =
+                        NEXT_MULTIPLE((original_width
+                                    * config->ppu_cfg[i].scale.height)/original_height, alignw);
+                    config->ppu_cfg[i].scale.height =
+                        NEXT_MULTIPLE(config->ppu_cfg[i].scale.height, alignh);
+                } else if (config->ppu_cfg[i].scale.height == -1 &&
+                        !check_scale_value(config->ppu_cfg[i].scale.width) &&
+                        config->ppu_cfg[i].scale.width > 0) {
+                    config->ppu_cfg[i].scale.width =
+                        NEXT_MULTIPLE(config->ppu_cfg[i].scale.width, alignw);
+                    config->ppu_cfg[i].scale.height =
+                        NEXT_MULTIPLE((original_height
+                                    * config->ppu_cfg[i].scale.width)/original_width, alignh);
+                } else if (check_scale_value(config->ppu_cfg[i].scale.width) &&
+                        check_scale_value(config->ppu_cfg[i].scale.height)) {
+                    config->ppu_cfg[i].scale.scale_by_ratio = 1;
+                    config->ppu_cfg[i].scale.ratio_x = -config->ppu_cfg[i].scale.width;
+                    config->ppu_cfg[i].scale.ratio_y = -config->ppu_cfg[i].scale.height;
+                    config->ppu_cfg[i].scale.width = 0;
+                    config->ppu_cfg[i].scale.height = 0;
+                } else {
+                    rv_info = DEC_INFOPARAM_ERROR;
+                    av_log(avctx,AV_LOG_ERROR,"invalid scale config, scale.width: %d scale.height: %d\n",
+                    config->ppu_cfg[i].scale.width, config->ppu_cfg[i].scale.height);
+                    break;
+                }
+            } else if (config->ppu_cfg[i].scale.width > 0 && config->ppu_cfg[i].scale.width > 0) {
+                if(config->ppu_cfg[i].scale.width > original_width ||
+                    config->ppu_cfg[i].scale.height > original_height) {
+                    av_log(avctx,AV_LOG_ERROR,"invalid scale config, scale.width: %d scale.height: %d\n",
+                    config->ppu_cfg[i].scale.width, config->ppu_cfg[i].scale.height);
+                    return -1;
+                }
+            } else if (config->ppu_cfg[i].scale.width != 0 && config->ppu_cfg[i].scale.height != 0){
+                av_log(avctx,AV_LOG_ERROR,"invalid scale config, scale.width: %d scale.height: %d\n",
+                    config->ppu_cfg[i].scale.width, config->ppu_cfg[i].scale.height);
+                return -1;
+            }
+        }
+    }
+
+#if 0
+    //-JpegDecImageInfo does not have a crop_Params structure, so this operation is not required
+    /* Ajust user cropping params based on cropping params from sequence info. */
+    if (dec_ctx->sequence_info.crop_params.crop_left_offset != 0
+        || dec_ctx->sequence_info.crop_params.crop_top_offset != 0
+        || dec_ctx->sequence_info.crop_params.crop_out_width != dec_ctx->sequence_info.pic_width
+        || dec_ctx->sequence_info.crop_params.crop_out_height != dec_ctx->sequence_info.pic_height) {
+            for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+                if (!config->ppu_cfg[i].enabled)
+                    continue;
+
+            if (!config->ppu_cfg[i].crop.enabled) {
+                config->ppu_cfg[i].crop.x = dec_ctx->sequence_info.crop_params.crop_left_offset;
+                config->ppu_cfg[i].crop.y = dec_ctx->sequence_info.crop_params.crop_top_offset;
+                config->ppu_cfg[i].crop.width =
+                    NEXT_MULTIPLE(dec_ctx->sequence_info.crop_params.crop_out_width, 2);
+                config->ppu_cfg[i].crop.height =
+                    NEXT_MULTIPLE(dec_ctx->sequence_info.crop_params.crop_out_height, 2);
+            } else {
+                config->ppu_cfg[i].crop.x += dec_ctx->sequence_info.crop_params.crop_left_offset;
+                config->ppu_cfg[i].crop.y += dec_ctx->sequence_info.crop_params.crop_top_offset;
+                if(!config->ppu_cfg[i].crop.width)
+                    config->ppu_cfg[i].crop.width =
+                        dec_ctx->sequence_info.crop_params.crop_out_width;
+                if(!config->ppu_cfg[i].crop.height)
+                    config->ppu_cfg[i].crop.height =
+                        dec_ctx->sequence_info.crop_params.crop_out_height;
+            }
+            config->ppu_cfg[i].enabled = 1;
+            config->ppu_cfg[i].crop.enabled = 1;
+        }
+    }
+    //The validity of the ppu_cfg parameter is checked by CheckPpUnitConfig in JpegDecSetInfo
+    for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (config->ppu_cfg[i].crop.enabled) {
+            if ((config->ppu_cfg[i].scale.width > config->ppu_cfg[i].crop.width)
+                || (config->ppu_cfg[i].scale.height > config->ppu_cfg[i].crop.height)
+                || (config->ppu_cfg[i].crop.width > dec_ctx->sequence_info.crop_params.crop_out_width)
+                || (config->ppu_cfg[i].crop.height > dec_ctx->sequence_info.crop_params.crop_out_height)) {
+                    return -1;
+            }
+        } else {
+            if ((config->ppu_cfg[i].scale.width > dec_ctx->sequence_info.crop_params.crop_out_width)
+                || (config->ppu_cfg[i].scale.height > dec_ctx->sequence_info.crop_params.crop_out_height)) {
+                    return -1;
+            }
+        }
+    }
+#endif
+#if 0
+    {
+        // for bypass mode or 10bit case use pp0 datapath for performance
+        if (config->ppu_cfg[0].enabled == 2) {
+            av_log(avctx,AV_LOG_DEBUG,
+                   "dec_ctx->sequence_info.bit_depth_luma = %d, dec_ctx->sequence_info.bit_depth_chroma = %d\n",
+                    dec_ctx->sequence_info.bit_depth_luma, dec_ctx->sequence_info.bit_depth_chroma);
+            if (dec_ctx->sequence_info.bit_depth_luma > 8
+                || dec_ctx->sequence_info.bit_depth_chroma > 8) {
+                av_log(avctx,AV_LOG_DEBUG,"adaptive to enable pp0\n");
+                config->ppu_cfg[0].enabled = 1;
+            } else {
+                av_log(avctx,AV_LOG_DEBUG,"adaptive to disable pp0\n");
+                config->ppu_cfg[0].enabled = 0;
+            }
+        }
+    }
+
+    //check PP setting legal
+    rv_info = DEC_OK;
+    for(i=0; i<4; i++) {
+        if(config->ppu_cfg[i].enabled == 1) {
+            if(ppmax_output_pic_h[i] == 0 ) {
+                if((config->ppu_cfg[i].scale.height > dec_ctx->sequence_info.pic_height)
+                    ||(config->ppu_cfg[i].scale.width > dec_ctx->sequence_info.pic_width)) {
+                    av_log(avctx,AV_LOG_DEBUG,
+                           "PP[%d] Height setting is illegal: %d > MAX (%d)\n",i,
+                           config->ppu_cfg[i].scale.height,ppmax_output_pic_h[i]==0
+                           ? dec_ctx->sequence_info.pic_height : ppmax_output_pic_h[i]);
+                    rv_info = DEC_INFOPARAM_ERROR;
+                    break;
+                }
+            } else {
+                if((config->ppu_cfg[i].scale.height > ppmax_output_pic_h[i])
+                    ||(config->ppu_cfg[i].scale.width > ppmax_output_pic_h[i])) {
+                    av_log(avctx,AV_LOG_DEBUG,
+                           "PP[%d] Height setting is illegal: %d > MAX (%d)\n",i,
+                           config->ppu_cfg[i].scale.height,ppmax_output_pic_h[i]==0
+                           ? dec_ctx->sequence_info.pic_height : ppmax_output_pic_h[i]);
+                    rv_info = DEC_INFOPARAM_ERROR;
+                    break;
+                }
+            }
+        }
+    }
+    if(rv_info == DEC_INFOPARAM_ERROR) {
+        return -1;
+    }
+
+    if(dec_ctx->disable_dec400) {
+        //disable all shaper for pp
+        ff_es_jpeg_dec_disable_all_pp_shaper(&dec_ctx->vsv_dec_config);
+    } else {
+        //check SR ratio capability
+        if(dec_ctx->sequence_info.pic_height > 1088)
+            shaper_en_num = 3;
+        else
+            shaper_en_num = 2;
+
+        for(i=0; i<4; i++) {
+            sr[i] = (double)max_output_pic_h[i]/max_input_pic_h;
+            sr_sum += sr[i];
+        }
+
+        for(i=0; i<4; i++) {
+            if(config->ppu_cfg[i].enabled == 1) {
+                //10bit stream disable shaper when shaper_enabled = 2
+                if((i == 0)&&(config->ppu_cfg[i].shaper_enabled == 2)) {
+                    if((dec_ctx->sequence_info.bit_depth_luma > 8)
+                        ||(dec_ctx->sequence_info.bit_depth_chroma > 8)) {
+                        config->ppu_cfg[i].shaper_enabled = 0;//disable when 10bit
+                        continue;
+                    } else {
+                        config->ppu_cfg[i].shaper_enabled = 1;//enable when 8bit
+                    }
+                }
+
+                if (config->ppu_cfg[i].scale.enabled == 0) {
+                    sr_p[i] = 1;
+                } else if (config->ppu_cfg[i].crop.enabled) {
+                    sr_p[i] = (double)config->ppu_cfg[i].scale.height/config->ppu_cfg[i].crop.height;
+                } else {
+                    sr_p[i] = (double)config->ppu_cfg[i].scale.height/dec_ctx->sequence_info.pic_height;
+                }
+                sr_p_sum += sr_p[i];
+            }
+            av_log(avctx,AV_LOG_DEBUG,"PP%d enabled=%d,SR_sum=%f,SR_P_sum=%f\n",
+                   i,config->ppu_cfg[i].enabled,sr_sum,sr_p_sum);
+            if((shaper_en_num > 0)
+               &&(sr_p_sum < sr_sum)
+               &&(config->ppu_cfg[i].enabled == 1)) {
+                config->ppu_cfg[i].shaper_enabled = 1;
+                shaper_en_num --;
+            } else
+              config->ppu_cfg[i].shaper_enabled = 0;
+        }
+
+    }
+    av_log(avctx,AV_LOG_DEBUG,"in %s : %d ppu cfg :\n",__func__,__LINE__);
+
+    if(dec_ctx->sequence_info.is_interlaced) {
+        config->ppu_cfg[0].enabled = 1;
+        for(int i=0;i<4;i++) {
+            if(config->ppu_cfg[i].enabled == 1) {
+                config->ppu_cfg[i].tiled_e = 0;
+                config->ppu_cfg[i].shaper_enabled = 0;
+                config->ppu_cfg[i].align = DEC_ALIGN_1024B;
+            }
+        }
+    }
+#endif
+
+    ff_es_jpeg_ppu_print(config);
+
+    return 0;
+}
+
+void ff_es_jpeg_ppu_print(struct DecConfig *config){
+
+    for(int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (config->ppu_cfg[i].enabled) {
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].tiled_e = %d\n", i,
+               config->ppu_cfg[i].tiled_e);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].scale.enabled = %d\n",
+                i, config->ppu_cfg[i].scale.enabled);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].scale.scale_by_ratio = %d\n",
+                i, config->ppu_cfg[i].scale.scale_by_ratio);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].scale.ratio_x = %d\n",
+                i, config->ppu_cfg[i].scale.ratio_x);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].scale.ratio_y = %d\n",
+                i, config->ppu_cfg[i].scale.ratio_y);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].scale.width = %d\n",
+                i, config->ppu_cfg[i].scale.width);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].scale.height = %d\n",
+                i, config->ppu_cfg[i].scale.height);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].crop.enabled = %d\n",
+                i, config->ppu_cfg[i].crop.enabled);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].crop.x = %d\n",
+                i, config->ppu_cfg[i].crop.x);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].crop.y = %d\n",
+                i, config->ppu_cfg[i].crop.y);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].crop.width = %d\n",
+                i, config->ppu_cfg[i].crop.width);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].crop.height = %d\n",
+                i, config->ppu_cfg[i].crop.height);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].out_p010 = %d\n",
+                i, config->ppu_cfg[i].out_p010);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].out_I010 = %d\n",
+                i, config->ppu_cfg[i].out_I010);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].align = %d\n",
+                i, config->ppu_cfg[i].align);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].shaper_enabled = %d\n",
+                i, config->ppu_cfg[i].shaper_enabled);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].cr_first = %d\n",
+                i, config->ppu_cfg[i].cr_first);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].rgb = %d\n",
+                i, config->ppu_cfg[i].rgb);
+            av_log(NULL, AV_LOG_DEBUG, "ppu_cfg[%d].rgb_format = %d\n",
+                i, config->ppu_cfg[i].rgb_format);
+        }
+    }
+}
+
+void ff_es_jpeg_dec_disable_all_pp_shaper(struct DecConfig *config)
+{
+    int i;
+    if(!config)
+        return;
+    for(i = 0; i < 4; i++)
+        config->ppu_cfg[i].shaper_enabled = 0;
+}
+
+void ff_es_jpeg_dec_init_log_header(AVCodecContext *avctx)
+{
+    VSVDECContext *dec_ctx = avctx->priv_data;
+
+#ifdef FB_SYSLOG_ENABLE
+    static char module_name[] = "DEC";
+    if(strlen(dec_ctx->module_name))
+        dec_ctx->log_header.module_name = dec_ctx->module_name;
+    else
+        dec_ctx->log_header.module_name = module_name;
+    dec_ctx->log_header.device_id = get_deviceId(dec_ctx->dev_name);
+#endif
+}
+
+int ff_es_jpeg_dec_paras_check(AVCodecContext *avctx) {
+    VSVDECContext *dec_ctx  = avctx->priv_data;
+
+    if (dec_ctx->scale_set == NULL)
+        av_log(avctx, AV_LOG_ERROR, "scale_set is null\n");
+
+    enum DecPictureFormat dstpicfmt = ff_codec_pixfmt_to_decfmt(dec_ctx->output_format[0]);
+    if(IS_PIC_RGB(dstpicfmt) && dec_ctx->cfg_pp_enabled[0] == 1) {
+        av_log(avctx, AV_LOG_ERROR, "cannot set pp0 output format as rgb.\n",dec_ctx->pp_out);
+        return -1;
+    }
+
+    if (dec_ctx->cfg_pp_enabled[0] == 1 && dec_ctx->cfg_pp_enabled[1] == 0) {
+        if(dec_ctx->pp_out == 1) {
+            av_log(avctx, AV_LOG_ERROR, "pp_out=1, pp1 disable.\n",dec_ctx->pp_out);
+            return -1;
+        }
+    } else if (dec_ctx->cfg_pp_enabled[0] == 0 && dec_ctx->cfg_pp_enabled[1] == 1) {
+        if(dec_ctx->pp_out == 0) {
+            av_log(avctx, AV_LOG_ERROR, "pp_out=0, but pp0 disable.\n",dec_ctx->pp_out);
+            return -1;
+        }
+    } else if (dec_ctx->cfg_pp_enabled[0] == 0 && dec_ctx->cfg_pp_enabled[1] == 0) {
+        av_log(avctx, AV_LOG_WARNING, "pp0,pp1 are both disable.\n",dec_ctx->pp_out);
+        return -1;
+    }
+
+    if (dec_ctx->fdump) {
+        dec_ctx->frame_dump[0] = dec_ctx->cfg_pp_enabled[0];
+        dec_ctx->frame_dump[1] = dec_ctx->cfg_pp_enabled[1];
+    }
+
+    return 0;
+}
+
+int ff_es_jpeg_dec_init_ppu_cfg(AVCodecContext *avctx,struct DecConfig *config)
+{
+    VSVDECContext *dec_ctx  = avctx->priv_data;
+    int ret = 0;
+
+    config->ppu_cfg[0].enabled = dec_ctx->cfg_pp_enabled[0];
+    config->ppu_cfg[1].enabled = dec_ctx->cfg_pp_enabled[1];
+
+    //set crop and scale
+    ret = ff_es_jpeg_set_ppu_crop_and_scale(dec_ctx, config);
+    if (ret < 0)
+        return -1;
+
+    //set output_format
+    ff_es_jpeg_set_ppu_output_format(dec_ctx, config);
+
+    dec_ctx->pp_enabled = 1;
+
+    return 0;
+}
+
+void ff_es_jpeg_dec_print_image_info(AVCodecContext *avctx,struct DecSequenceInfo * image_info) {
+  assert(image_info);
+
+  /* Select if Thumbnail or full resolution image will be decoded */
+  if(image_info->thumbnail_type == JPEGDEC_THUMBNAIL_JPEG) {
+    /* decode thumbnail */
+    av_log(avctx, AV_LOG_DEBUG, "\t-JPEG THUMBNAIL IN STREAM\n");
+    av_log(avctx, AV_LOG_DEBUG, "\t-JPEG THUMBNAIL INFO\n");
+    av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG thumbnail display resolution(W x H): %d x %d\n",
+            image_info->scaled_width_thumb, image_info->scaled_height_thumb);
+    av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG thumbnail HW decoded RESOLUTION(W x H): %d x %d\n",
+            NEXT_MULTIPLE(image_info->scaled_width_thumb, 16),
+            NEXT_MULTIPLE(image_info->scaled_height_thumb, 8));
+    av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG thumbnail OUTPUT SIZE(Stride x H): %d x %d\n",
+            image_info->pic_width_thumb, image_info->pic_height_thumb);
+
+    /* stream type */
+    switch (image_info->coding_mode_thumb) {
+    case JPEG_BASELINE:
+      av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG: STREAM TYPE: JPEG_BASELINE\n");
+      break;
+    case JPEG_PROGRESSIVE:
+      av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG: STREAM TYPE: JPEG_PROGRESSIVE\n");
+      break;
+    case JPEG_NONINTERLEAVED:
+      av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG: STREAM TYPE: JPEG_NONINTERLEAVED\n");
+      break;
+    }
+
+    if(image_info->output_format_thumb) {
+      switch (image_info->output_format_thumb) {
+      case DEC_OUT_FRM_YUV400:
+        av_log(avctx, AV_LOG_DEBUG,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV400\n");
+        break;
+      case DEC_OUT_FRM_YUV420SP:
+        av_log(avctx, AV_LOG_DEBUG,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV420SP\n");
+        break;
+      case DEC_OUT_FRM_YUV422SP:
+        av_log(avctx, AV_LOG_DEBUG,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV422SP\n");
+        break;
+      case DEC_OUT_FRM_YUV440:
+        av_log(avctx, AV_LOG_DEBUG,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV440\n");
+        break;
+      case DEC_OUT_FRM_YUV411SP:
+        av_log(avctx, AV_LOG_DEBUG,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV411SP\n");
+        break;
+      case DEC_OUT_FRM_YUV444SP:
+        av_log(avctx, AV_LOG_DEBUG,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV444SP\n");
+        break;
+      default:
+        av_log(avctx, AV_LOG_DEBUG,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: NOT SUPPORT\n");
+        break;
+      }
+    }
+  } else if(image_info->thumbnail_type == JPEGDEC_NO_THUMBNAIL) {
+    /* decode full image */
+    av_log(avctx, AV_LOG_DEBUG,
+            "\t-NO THUMBNAIL IN STREAM ==> Decode full resolution image\n");
+  } else if(image_info->thumbnail_type == JPEGDEC_THUMBNAIL_NOT_SUPPORTED_FORMAT) {
+    /* decode full image */
+    av_log(avctx, AV_LOG_DEBUG,
+            "\tNot SUPPORTED THUMBNAIL IN STREAM ==> Decode full resolution image\n");
+  }
+
+  av_log(avctx, AV_LOG_DEBUG, "\t-JPEG FULL RESOLUTION INFO\n");
+  av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG display resolution(W x H): %d x %d\n",
+          image_info->scaled_width, image_info->scaled_height);
+  av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG HW decoded RESOLUTION(W x H): %d x %d\n",
+          NEXT_MULTIPLE(image_info->scaled_width, 8),
+          NEXT_MULTIPLE(image_info->scaled_height, 8));
+  av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG OUTPUT SIZE(Stride x H): %d x %d\n",
+          image_info->pic_width, image_info->pic_height);
+  if(image_info->output_format) {
+    switch (image_info->output_format) {
+    case DEC_OUT_FRM_YUV400:
+      av_log(avctx, AV_LOG_DEBUG,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV400\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_0_0 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV420SP:
+      av_log(avctx, AV_LOG_DEBUG,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV420SP\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_2_0 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV422SP:
+      av_log(avctx, AV_LOG_DEBUG,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV422SP\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_2_2 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV440:
+      av_log(avctx, AV_LOG_DEBUG,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV440\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_4_0 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV411SP:
+      av_log(avctx, AV_LOG_DEBUG,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV411SP\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_1_1 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV444SP:
+      av_log(avctx, AV_LOG_DEBUG,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV444SP\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_4_4 = 1;
+#endif
+      break;
+    default:
+      av_log(avctx, AV_LOG_DEBUG,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: NOT SUPPORT\n");
+      break;
+    }
+  }
+
+  /* stream type */
+switch (image_info->coding_mode) {
+  case JPEG_BASELINE:
+    av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG: STREAM TYPE: JPEG_BASELINE\n");
+    break;
+  case JPEG_PROGRESSIVE:
+    av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG: STREAM TYPE: JPEG_PROGRESSIVE\n");
+#ifdef ASIC_TRACE_SUPPORT
+    decoding_tools.progressive = 1;
+#endif
+    break;
+  case JPEG_NONINTERLEAVED:
+    av_log(avctx, AV_LOG_DEBUG, "\t\t-JPEG: STREAM TYPE: JPEG_NONINTERLEAVED\n");
+    break;
+  }
+
+  if(image_info->thumbnail_type == JPEGDEC_THUMBNAIL_JPEG) {
+    av_log(avctx, AV_LOG_DEBUG, "\t-JPEG ThumbnailType: JPEG\n");
+#ifdef ASIC_TRACE_SUPPORT
+    decoding_tools.thumbnail = 1;
+#endif
+  } else if(image_info->thumbnail_type == JPEGDEC_NO_THUMBNAIL)
+    av_log(avctx, AV_LOG_DEBUG, "\t-JPEG ThumbnailType: NO THUMBNAIL\n");
+  else if(image_info->thumbnail_type == JPEGDEC_THUMBNAIL_NOT_SUPPORTED_FORMAT)
+    av_log(avctx, AV_LOG_DEBUG, "\t-JPEG ThumbnailType: NOT SUPPORTED THUMBNAIL\n");
+}
+
+static enum AVPixelFormat ff_es_jpeg_get_format(VSVDECContext *dec_ctx) {
+    enum AVPixelFormat format = AV_PIX_FMT_NV12;
+    if (!dec_ctx) {
+        av_log(dec_ctx, AV_LOG_ERROR, "dec_ctx is null\n");
+        return AV_PIX_FMT_NONE;
+    }
+
+    for (int i = 0; i < DEC_MAX_PPU_COUNT; i++) {
+        if (dec_ctx->cfg_pp_enabled[i] && dec_ctx->pp_out == i) {
+            format = dec_ctx->output_format[i];
+            av_log(dec_ctx, AV_LOG_DEBUG, "target pp: %d, format: %d\n", i, format);
+            break;
+        }
+    }
+
+    return format;
+}
+
+int ff_es_jpeg_dec_init_hwctx(AVCodecContext *avctx)
+{
+    int ret=0;
+    AVHWFramesContext *hw_frames_ctx;
+    VSVDECContext *dec_ctx = avctx->priv_data;
+
+    avctx->sw_pix_fmt = ff_es_jpeg_get_format(dec_ctx);
+    enum AVPixelFormat pix_fmts[3] = {AV_PIX_FMT_ES, avctx->sw_pix_fmt, AV_PIX_FMT_NONE};
+    avctx->pix_fmt = ff_get_format(avctx, pix_fmts);
+    av_log(avctx, AV_LOG_INFO,
+             "avctx sw_pix_fmt: %s, pix_fmt: %s\n",
+             av_get_pix_fmt_name(avctx->sw_pix_fmt),
+             av_get_pix_fmt_name(avctx->pix_fmt));
+
+    if (avctx->hw_frames_ctx) {
+        dec_ctx->hwframe = av_buffer_ref(avctx->hw_frames_ctx);
+        if (!dec_ctx->hwframe) {
+            ret = AVERROR(ENOMEM);
+            goto error;
+        }
+    } else {
+        av_log(avctx, AV_LOG_TRACE, "%s(%d) avctx->hw_device_ctx = %p\n",
+                          __FUNCTION__, __LINE__, avctx->hw_device_ctx);
+        if (avctx->hw_device_ctx) {
+            dec_ctx->hwdevice = av_buffer_ref(avctx->hw_device_ctx);
+            av_log(avctx, AV_LOG_TRACE, "%s(%d) dec_ctx->hwdevice = %p\n",
+                                __FUNCTION__, __LINE__, dec_ctx->hwdevice);
+            if (!dec_ctx->hwdevice) {
+                ret = AVERROR(ENOMEM);
+                goto error;
+            }
+        } else {
+            ret = av_hwdevice_ctx_create(&dec_ctx->hwdevice,
+                                         AV_HWDEVICE_TYPE_ES,
+                                         "es",
+                                         NULL,
+                                         0);
+            if (ret < 0)
+                goto error;
+        }
+
+        dec_ctx->hwframe = av_hwframe_ctx_alloc(dec_ctx->hwdevice);
+        if (!dec_ctx->hwframe) {
+            av_log(avctx, AV_LOG_ERROR, "av_hwframe_ctx_alloc failed\n");
+            ret = AVERROR(ENOMEM);
+            goto error;
+        }
+
+        hw_frames_ctx = (AVHWFramesContext *)dec_ctx->hwframe->data;
+        hw_frames_ctx->format = AV_PIX_FMT_ES;
+        hw_frames_ctx->sw_format = avctx->sw_pix_fmt;
+    }
+
+    if (avctx->pix_fmt == AV_PIX_FMT_ES) {
+        dec_ctx->extra_hw_frames = avctx->extra_hw_frames > 1 ? avctx->extra_hw_frames : 1;
+    }
+    av_log(avctx, AV_LOG_INFO,
+             "dec_ctx extra_hw_frames: %d, avctx extra_hw_frames: %d\n",
+             dec_ctx->extra_hw_frames,
+             avctx->extra_hw_frames);
+    return 0;
+error:
+    av_log(avctx, AV_LOG_ERROR, "av_hwframe_ctx_init failed\n");
+    return ret;
+}
+
+int ff_es_dec_drop_pkt(AVCodecContext *avctx, AVPacket *avpkt)
+{
+    VSVDECContext *dec_ctx = avctx->priv_data;
+
+    if (!dec_ctx->pic_decode_number) {
+        return 0;
+    }
+
+    if (dec_ctx->got_package_number % (dec_ctx->drop_frame_interval + 1) == 0) {
+        av_log(avctx, AV_LOG_DEBUG, "drop pkt number: %d\n", dec_ctx->got_package_number);
+        av_packet_unref(avpkt);
+        return -1;
+    } else {
+        // frame->pts = dec_ctx->pic_decode_number;
+        dec_ctx->pic_decode_number++;
+    }
+    return 0;
+}
+
+void ff_es_jpeg_dec_print_return(AVCodecContext *avctx,enum DecRet jpeg_ret) {
+    static enum DecRet prev_retval = 0xFFFFFF;
+
+    switch (jpeg_ret) {
+    case DEC_PIC_RDY:
+        av_log(avctx, AV_LOG_DEBUG, "JpegDecDecode API returned : DEC_PIC_RDY\n");
+        break;
+    case DEC_OK:
+        av_log(avctx, AV_LOG_DEBUG, "JpegDecDecode API returned : DEC_OK\n");
+        break;
+    case DEC_ERROR:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : DEC_ERROR\n");
+        break;
+    case DEC_HW_TIMEOUT:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : JPEGDEC_HW_TIMEOUT\n");
+        break;
+    case DEC_UNSUPPORTED:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : DEC_UNSUPPORTED\n");
+        break;
+    case DEC_PARAM_ERROR:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : DEC_PARAM_ERROR\n");
+        break;
+    case DEC_MEMFAIL:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : DEC_MEMFAIL\n");
+        break;
+    case DEC_INITFAIL:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : DEC_INITFAIL\n");
+        break;
+    case DEC_HW_BUS_ERROR:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : DEC_HW_BUS_ERROR\n");
+        break;
+    case DEC_SYSTEM_ERROR:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : DEC_SYSTEM_ERROR\n");
+        break;
+    case DEC_DWL_ERROR:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : DEC_DWL_ERROR\n");
+        break;
+    case DEC_INVALID_STREAM_LENGTH:
+        av_log(avctx, AV_LOG_ERROR,
+                "JpegDecDecode API returned : DEC_INVALID_STREAM_LENGTH\n");
+        break;
+    case DEC_STRM_ERROR:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned : DEC_STRM_ERROR\n");
+        break;
+    case DEC_INVALID_INPUT_BUFFER_SIZE:
+        av_log(avctx, AV_LOG_ERROR,
+                "JpegDecDecode API returned : DEC_INVALID_INPUT_BUFFER_SIZE\n");
+        break;
+    case DEC_INCREASE_INPUT_BUFFER:
+        av_log(avctx, AV_LOG_DEBUG,
+                "JpegDecDecode API returned : DEC_INCREASE_INPUT_BUFFER\n");
+        break;
+    case DEC_SLICE_MODE_UNSUPPORTED:
+        av_log(avctx, AV_LOG_ERROR,
+                "JpegDecDecode API returned : DEC_SLICE_MODE_UNSUPPORTED\n");
+        break;
+    case DEC_NO_DECODING_BUFFER:
+        if (prev_retval == DEC_NO_DECODING_BUFFER) break;
+        av_log(avctx, AV_LOG_ERROR,
+                "JpegDecDecode API returned : DEC_NO_DECODING_BUFFER\n");
+        break;
+    case DEC_WAITING_FOR_BUFFER:
+        av_log(avctx, AV_LOG_ERROR,
+                "JpegDecDecode API returned : DEC_WAITING_FOR_BUFFER\n");
+        break;
+    case DEC_FORMAT_NOT_SUPPORTED:
+        av_log(avctx, AV_LOG_ERROR,
+                "JpegDecDecode API returned : DEC_FORMAT_NOT_SUPPORTED\n");
+        break;
+    case DEC_STRM_PROCESSED:
+        av_log(avctx, AV_LOG_ERROR,
+                "JpegDecDecode API returned : DEC_STRM_PROCESSED\n");
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "JpegDecDecode API returned unknown status\n");
+        break;
+    }
+    prev_retval = jpeg_ret;
+}
+
+uint32_t ff_es_jpeg_low_latency_task_init(VSVDECContext *dec_ctx) {
+    int ret = 0;
+    dec_ctx->decode_end_flag = 1;
+    dec_ctx->sw_hw_bound = 0;
+    dec_ctx->task = NULL;
+    dec_ctx->pic_decoded == 0;
+    dec_ctx->send_strm_info.strm_bus_addr =
+                            dec_ctx->send_strm_info.strm_bus_start_addr =
+                            dec_ctx->stream_mem[dec_ctx->stream_mem_index].bus_address;
+    dec_ctx->send_strm_info.strm_vir_addr =
+                            dec_ctx->send_strm_info.strm_vir_start_addr =
+                            (u8 *)dec_ctx->stream_mem[dec_ctx->stream_mem_index].virtual_address;
+    sem_init(&dec_ctx->send_sem, 0, 0);
+    sem_init(&dec_ctx->frame_sem, 0, 0);
+    dec_ctx->task = ff_es_jpeg_run_task(ff_es_jpeg_send_bytestrm_task, dec_ctx);
+    dec_ctx->task_existed = 1;
+
+    return ret;
+}
+
+task_handle ff_es_jpeg_run_task(task_func func, void* param) {
+  int ret;
+  pthread_attr_t attr;
+  struct sched_param par;
+  pthread_t* thread_handle = malloc(sizeof(pthread_t));
+
+  pthread_attr_init(&attr);
+
+#if 0  // maybe it will be uses in haps
+  ret = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
+  assert(ret == 0);
+  ret = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);
+  par.sched_priority = 60;
+  ret = pthread_attr_setschedparam(&attr, &par);
+#endif
+
+  ret = pthread_create(thread_handle, &attr, func, param);
+  assert(ret == 0);
+
+  if(ret != 0)
+  {
+    free(thread_handle);
+    thread_handle = NULL;
+  }
+
+  return thread_handle;
+}
+
+void ff_es_jpeg_wait_for_task_completion(task_handle task) {
+  int ret = pthread_join(*((pthread_t*)task), NULL);
+  assert(ret == 0);
+  free(task);
+  task = NULL;
+}
+
+void* ff_es_jpeg_send_bytestrm_task(void* param) {
+    VSVDECContext *dec_ctx = (VSVDECContext *)param;
+    dec_ctx->decode_end_flag = 0;
+
+    addr_t start_bus_addr = dec_ctx->send_strm_info.strm_bus_addr;
+    uint32_t packet_size = LOW_LATENCY_PACKET_SIZE;
+    uint32_t send_len = 0;
+    uint32_t bytes = 0;
+    dec_ctx->pic_decoded = 0;
+
+    while(!dec_ctx->decode_end_flag) {
+        // av_log(NULL, AV_LOG_ERROR, "pkt.size: %d send_len: %d\n", dec_ctx->avpkt.size, send_len);
+        if(dec_ctx->avpkt.size - send_len > packet_size && dec_ctx->avpkt.data) {
+            bytes = packet_size;
+            memcpy((uint8_t*)dec_ctx->send_strm_info.strm_vir_addr,
+                    dec_ctx->avpkt.data + send_len,
+                    packet_size);
+            dec_ctx->send_strm_info.strm_bus_addr += packet_size;
+            send_len += packet_size;
+            dec_ctx->send_strm_info.last_flag = 0;
+            dec_ctx->send_strm_info.strm_vir_addr += packet_size;
+        } else if (dec_ctx->avpkt.data){
+            bytes = dec_ctx->avpkt.size - send_len;
+            memcpy((uint8_t*)dec_ctx->send_strm_info.strm_vir_addr,
+                    dec_ctx->avpkt.data + send_len,
+                    bytes);
+            dec_ctx->send_strm_info.strm_bus_addr += bytes;
+            send_len += bytes;
+            dec_ctx->send_strm_info.last_flag = 1;
+            dec_ctx->send_strm_info.strm_vir_addr += bytes;
+        }
+
+        if(dec_ctx->sw_hw_bound == 0) {
+            dec_ctx->sw_hw_bound =
+                ff_es_jpeg_find_imagedata(dec_ctx->send_strm_info.strm_vir_start_addr, send_len);
+            if(dec_ctx->sw_hw_bound || dec_ctx->send_strm_info.last_flag)
+            {
+                sem_post(&dec_ctx->send_sem);
+            }
+            else
+                continue;
+        }
+        JpegDecUpdateStrmInfoCtrl(dec_ctx->dec_inst,
+                                  dec_ctx->send_strm_info.last_flag,
+                                  dec_ctx->send_strm_info.strm_bus_addr);
+#ifdef ENABLE_FPGA_VERIFICATION
+        if (send_strm_len > 10000000)
+        usleep(100);
+        else
+        usleep(1000);
+#endif
+        if(dec_ctx->pic_decoded == 1) {
+            dec_ctx->pic_decoded = 0;
+            dec_ctx->send_strm_info.last_flag = 0;
+            send_len = 0;
+            sem_wait(&dec_ctx->frame_sem);
+            start_bus_addr = dec_ctx->send_strm_info.strm_bus_addr;
+            dec_ctx->sw_hw_bound = 0;
+        }
+    }
+
+    return NULL;
+}
+
+u32 ff_es_jpeg_find_imagedata(u8 * p_stream, u32 stream_length)
+{
+    u32 read_bits;
+    u32 marker_byte;
+    u32 current_byte;
+    u32 header_length;
+    /* check pointers & parameters */
+    if(p_stream == NULL)
+        return 0;
+    /* Check the stream lenth */
+    if(stream_length < 1)
+        return 0;
+
+    read_bits = 0;
+
+    /* Read decoding parameters */
+    while(read_bits  < stream_length) {
+        /* Look for marker prefix byte from stream */
+        marker_byte = p_stream[read_bits];
+        if(marker_byte == 0xFF) {
+            if(read_bits + 1 >= stream_length)
+                return 0;
+            current_byte = p_stream[read_bits + 1];
+            /* switch to certain header decoding */
+            switch (current_byte)
+            {
+                case 0xC0: //SOF0:
+                case 0xC2: //SOF2:
+                case 0xDB: //DQT:
+                case 0xC4: //DHT:
+                case 0xDD: //DRI:
+                case 0xE1: //APP1:
+                case 0xE2: //APP2:
+                case 0xE3: //APP3:
+                case 0xE4: //APP4:
+                case 0xE5: //APP5:
+                case 0xE6: //APP6:
+                case 0xE7: //APP7:
+                case 0xE8: //APP8:
+                case 0xE9: //APP9:
+                case 0xEA: //APP10:
+                case 0xEB: //APP11:
+                case 0xEC: //APP12:
+                case 0xED: //APP13:
+                case 0xEE: //APP14:
+                case 0xEF: //APP15:
+                case 0xDC: //DNL:
+                case 0xFE: //COM:
+            /*
+                case 0xC1: //SOF1:
+                case 0xC3: //SOF3:
+                case 0xC5: //SOF5:
+                case 0xC6: //SOF6:
+                case 0xC7: //SOF7:
+                case 0xC8: //SOF9:
+                case 0xCA: //SOF10:
+                case 0xCB: //SOF11:
+                case 0xCD: //SOF13:
+                case 0xCE: //SOF14:
+                case 0xCF: //SOF15:
+                case 0xCC: //DAC:
+                case 0xDE: //DHP:
+            */
+                case 0xE0: //APP0:
+                    if(read_bits + 3 >= stream_length)
+                        return 0;
+                    header_length = (p_stream[read_bits + 2] << 8) + p_stream[read_bits + 3];
+                    if((read_bits + header_length) > stream_length)
+                        return 0;
+                    if(header_length != 0)
+                        read_bits += (header_length + 1);
+                    break;
+
+                case 0xDA: //SOS:
+                    /* SOS length */
+                    if(read_bits + 3 >= stream_length)
+                        return 0;
+                    header_length = (p_stream[read_bits + 2] << 8) + p_stream[read_bits + 3];
+                    if((read_bits + header_length) > stream_length)
+                        return 0;
+                    /* jump over SOS header */
+                    if(header_length != 0)
+                        read_bits += (header_length + 1);
+
+                    if(read_bits >= stream_length)
+                        return 0;
+                    else
+                    /* return a big value to control sw */
+                        return DEC_X170_MAX_STREAM_VC8000D;
+                    break;
+                default:
+                    read_bits++;
+                    break;
+            }
+        } else {
+            read_bits++;
+        }
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/libavcodec/es_jpeg_decode.h b/libavcodec/es_jpeg_decode.h
new file mode 100644
index 0000000000..e430e6dc7a
--- /dev/null
+++ b/libavcodec/es_jpeg_decode.h
@@ -0,0 +1,399 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ES_JPEG_DECODE_H
+#define AVCODEC_ES_JPEG_DECODE_H
+
+#include "deccfg.h"
+#include "dectypes.h"
+#include "avcodec.h"
+#include "hwconfig.h"
+#include "internal.h"
+#include "decode.h"
+#include "libavutil/opt.h"
+#include "libavutil/imgutils.h"
+#include "es_codec_private.h"
+#include "es_common.h"
+#include <stdlib.h>
+#include <linux/limits.h>
+#include "esdec_common.h"
+
+#define EXTRA_BUFFERS_BASE 17
+
+#define MAX_BUFFERS 17
+#define MAX_WAIT_FOR_CONSUME_BUFFERS 100
+#define MAX_SEG_NUM 4
+
+#ifndef NEXT_MULTIPLE
+#define NEXT_MULTIPLE(value, n) (((value) + (n) - 1) & ~((n) - 1))
+#endif
+
+#ifndef ALIGN
+#define ALIGN(a) (1 << (a))
+#endif
+
+#ifdef SW_PERFORMANCE
+#define INIT_SW_PERFORMANCE   \
+  double dec_cpu_time = 0;    \
+  clock_t dec_start_time = 0; \
+  clock_t dec_end_time = 0;
+#else
+#define INIT_SW_PERFORMANCE
+#endif
+
+#ifdef SW_PERFORMANCE
+#define START_SW_PERFORMANCE dec_start_time = clock();
+#else
+#define START_SW_PERFORMANCE
+#endif
+
+#ifdef SW_PERFORMANCE
+#define END_SW_PERFORMANCE \
+  dec_end_time = clock();  \
+  dec_cpu_time += ((double)(dec_end_time - dec_start_time)) / CLOCKS_PER_SEC;
+#else
+#define END_SW_PERFORMANCE
+#endif
+
+#ifdef SW_PERFORMANCE
+#define FINALIZE_SW_PERFORMANCE printf("SW_PERFORMANCE %0.5f\n", dec_cpu_time);
+#else
+#define FINALIZE_SW_PERFORMANCE
+#endif
+
+#ifdef SW_PERFORMANCE
+#define FINALIZE_SW_PERFORMANCE_PP \
+  printf("SW_PERFORMANCE_PP %0.5f\n", dec_cpu_time);
+#else
+#define FINALIZE_SW_PERFORMANCE_PP
+#endif
+
+#ifdef FB_SYSLOG_ENABLE
+#include "syslog_sink.h"
+#define VSV_DEC_INFO_PRINT(fmt, ...) FB_SYSLOG((const void *)&dec_ctx->log_header, SYSLOG_SINK_LEV_INFO, (char *)fmt, ## __VA_ARGS__)
+#endif
+
+typedef struct {
+    int x;
+    int y;
+    int cw;
+    int ch;
+    int sw;
+    int sh;
+} Scale;
+
+
+typedef struct {
+    struct DecPicturePpu *pic;
+    uint8_t wait_for_consume;
+}VSVDecPicWaitForConsume;
+
+typedef struct _ESJpegOutputMemory {
+    int fd[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t *virtual_address;
+    struct DWLLinearMem mem;
+} ESJpegOutputMemory;
+
+typedef struct _ESJpegOutputMemoryList {
+    ESJpegOutputMemory output_memory[MAX_BUFFERS];
+    int size;
+} ESJpegOutputMemoryList;
+
+enum ThumbMode {
+    Only_Decode_Pic = 0,
+    Only_Decode_Thumb,
+    Decode_Pic_Thumb
+};
+
+enum ESJpegCode {
+    ES_ERROR = -1,
+    ES_OK = 0,
+    ES_MORE_BUFFER,
+    ES_EXIT
+};
+
+typedef const void *ESJDecInst;
+
+/* thread for low latency feature */
+typedef void* task_handle;
+typedef void* (*task_func)(void*);
+
+typedef struct {
+    const AVClass *class;
+
+    char *pp_setting[ES_VID_DEC_MAX_OUT_COUNT];
+    char *scale_set;
+    char * crop_set[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t packet_dump;
+    char *dump_path;
+    uint32_t packet_dump_time;
+    uint32_t dump_pkt_count;
+    uint32_t dump_frame_count[2];
+    time_t start_dump_time;
+    char dirpath[PATH_MAX];
+    uint32_t pmode;
+    uint32_t fmode;
+
+    DumpHandle *frame_dump_handle[ES_VID_DEC_MAX_OUT_COUNT];
+    DumpHandle *pkt_dump_handle;
+
+
+    uint32_t frame_dump[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t frame_dump_time[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t out_stride;
+    uint32_t fdump;
+    uint32_t force_8bit;
+    char *filename;
+    uint32_t drop_frame_interval;
+    // uint32_t thumbdone;
+    uint32_t thum_exist;
+
+    AVCodecContext *avctx;
+    AVBufferRef *hwdevice;
+    AVBufferRef *hwframe;
+    int extra_hw_frames;
+
+#ifdef FB_SYSLOG_ENABLE
+    LOG_INFO_HEADER log_header;
+    char module_name[16];
+#endif
+
+    uint32_t disable_dtrc;
+    uint8_t pp_units_params_from_cmd_valid;
+    uint8_t *stream_stop ;
+
+    uint32_t enable_mc;
+    uint32_t hdrs_rdy;
+    DecPicAlignment align;  /* default: 64 bytes alignment */
+    uint32_t prev_width;
+    uint32_t prev_height;
+
+    uint32_t retry;
+
+    uint32_t clock_gating;
+    uint32_t data_discard;
+    uint32_t latency_comp;
+    uint32_t output_picture_endian;
+    uint32_t bus_burst_length;
+    uint32_t asic_service_priority;
+    uint32_t output_format[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t service_merge_disable;
+
+    uint32_t tiled_output;
+    uint32_t dpb_mode;
+    uint32_t pp_enabled;
+    int32_t pp_fmt[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t cfg_pp_enabled[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t pp_out;//control output PP0 or PP
+
+    ESJDecInst dec_inst;
+    void *dwl_inst;
+    uint32_t thumb_mode;
+
+    uint32_t use_extra_buffers_num;
+    uint32_t buffer_size;
+    uint32_t num_buffers;    /* external buffers allocated yet. */
+    uint32_t min_buffer_num;
+    uint32_t add_buffer_thread_run;
+    pthread_mutex_t ext_buffer_control;
+    uint32_t buffer_consumed[MAX_BUFFERS];
+    uint32_t buffer_release_flag;
+
+    uint32_t pic_display_number;
+    uint32_t pic_decode_number;
+    uint32_t got_package_number;
+    uint32_t last_pic_flag;
+    uint32_t add_extra_flag;
+    uint32_t pic_size;
+    uint32_t decode_mode;
+    uint32_t low_latency;
+    uint32_t low_latency_sim;
+
+    struct DWLInitParam dwl_init;
+    ESJpegOutputMemoryList output_memory_list;
+
+    enum DecRet rv;
+    /* one extra stream buffer so that we can decode ahead,
+     * and be ready when core has finished
+     */
+    #define MAX_STRM_BUFFERS    (MAX_ASIC_CORES + 1)
+
+    struct DWLLinearMem stream_mem[MAX_STRM_BUFFERS];
+    long int max_strm_len;
+    uint32_t allocated_buffers;
+    uint32_t stream_mem_index;
+
+    struct DecPicturePpu pic;
+    struct DecPicturePpu pic_out;
+    uint32_t hw_ppu_initialized;
+    uint32_t cycle_count; /* Sum of average cycles/mb counts */
+    uint32_t initialized;
+    uint32_t closed;
+    VSVDecPicWaitForConsume wait_for_consume_list[MAX_WAIT_FOR_CONSUME_BUFFERS];
+    uint32_t wait_consume_num;
+    pthread_mutex_t consume_mutex;
+    void (*vsv_decode_picture_consume)(void *opaque, uint8_t *data);
+    void (*vsv_decode_pri_picture_info_free)(void *opaque, uint8_t *data);
+    void (*data_free)(void *opaque, uint8_t *data);
+    struct DecConfig vsv_dec_config;
+    struct DecSequenceInfo  sequence_info;
+    Scale scales[4];
+    uint32_t scales_num;
+    uint32_t extra_buffer_num; //record extra buffer count
+    uint32_t thum_out;//whether to output thumbnails 0-output only original image 1-output only thumbnails
+
+    uint32_t pic_decoded;
+    sem_t send_sem;
+    sem_t frame_sem;
+    uint32_t decode_end_flag;
+    uint32_t strm_len;
+    uint32_t sw_hw_bound;
+    uint32_t tmp_len;
+    struct strmInfo send_strm_info;
+    task_handle task;  // for low-latency thread
+    uint32_t task_existed; // for low-latency thread
+    AVPacket avpkt;
+    AVFrame *frame;
+
+}VSVDECContext;
+
+int ff_es_jpeg_dec_init_hwctx(AVCodecContext *avctx);
+
+uint32_t ff_es_jpeg_dec_del_pic_wait_consume_list(VSVDECContext *dec_ctx, uint8_t *data);
+
+int ff_es_jpeg_dec_parse_scale(AVCodecContext *avctx);
+
+int ff_es_jpeg_dec_output_frame(AVCodecContext *avctx,
+                                AVFrame *out,
+                                struct DecPicturePpu *decoded_pic);
+
+int ff_es_jpeg_dec_output_thum(AVCodecContext *avctx,
+                               AVFrame *out,
+                               struct DecPicturePpu *decoded_pic);
+
+int ff_es_jpeg_dec_send_avpkt_to_decode_buffer(AVCodecContext *avctx,
+                                              AVPacket *avpkt,
+                                              struct DWLLinearMem stream_buffer);
+
+void ff_es_jpeg_dec_print_return(AVCodecContext *avctx, enum DecRet jpeg_ret);
+
+void ff_es_jpeg_dec_disable_all_pp_shaper(struct DecConfig *config);
+
+void ff_es_jpeg_dec_release_ext_buffers(VSVDECContext *dec_ctx);
+
+uint32_t ff_es_jpeg_dec_find_empty_index(VSVDECContext *dec_ctx);
+
+void ff_es_jpeg_dec_performance_report(AVCodecContext *avctx);
+
+int ff_es_jpeg_dec_set_buffer_number_for_trans(AVCodecContext *avctx);
+
+void jpeg_dec_set_default_dec_config(AVCodecContext *avctx);
+
+enum DecRet jpegdec_consumed(void* inst, struct DecPicturePpu *pic);
+
+int ff_esdec_get_next_picture(AVCodecContext *avctx, AVFrame *frame);
+
+enum  ESJpegCode ff_es_jpeg_decoder(AVCodecContext *avctx, struct DecInputParameters *jpeg_in, AVFrame *frame);
+
+int jpeg_init(VSVDECContext *dec_ctx);
+
+enum DecRet jpeg_dec_get_info(VSVDECContext *dec_ctx);
+
+enum DecRet jpeg_dec_set_info(const void *inst, struct DecConfig config);
+
+enum DecRet jpeg_get_buffer_info(void *inst, struct DecBufferInfo *buf_info);
+
+enum DecRet jpeg_decode(AVCodecContext *avctx,void* inst, struct DecInputParameters* jpeg_in);
+
+enum DecRet jpeg_next_picture(AVCodecContext *avctx,const void *inst, struct DecPicturePpu *pic);
+
+void ff_es_jpeg_dwl_output_mempry_free(void *opaque, uint8_t *data);
+
+int ff_es_jpeg_output_buffer_fd_split(void *dwl_inst,
+                                      void *dec_inst,
+                                      ESJpegOutputMemory *memory,
+                                      struct DecConfig *dec_config);
+
+int ff_es_jpeg_allocate_output_buffer(VSVDECContext *dec_ctx,
+                                      struct DecBufferInfo *buf_info);
+
+int ff_es_jpeg_allocate_input_buffer(VSVDECContext *dec_ctx);
+
+int ff_es_jpeg_dec_modify_thum_config_by_sequence_info(AVCodecContext *avctx);
+
+int ff_es_jpeg_dec_modify_config_by_sequence_info(AVCodecContext *avctx);
+
+void ff_es_jpeg_dec_init_log_header(AVCodecContext *avctx);
+
+int ff_es_jpeg_dec_init_ppu_cfg(AVCodecContext *avctx,struct DecConfig *config);
+
+void ff_es_jpeg_dec_init_dec_input_paras(AVPacket *avpkt,
+                                         VSVDECContext *dec_ctx,
+                                         struct DecInputParameters *jpeg_in);
+
+void ff_es_jpeg_dec_update_dec_input_paras(VSVDECContext *dec_ctx,
+                                           struct DecInputParameters *jpeg_in);
+
+void ff_es_jpeg_dec_print_image_info(AVCodecContext *avctx, struct DecSequenceInfo * image_info);
+
+void ff_es_jpeg_ppu_print(struct DecConfig *config);
+
+void ff_es_pri_picture_info_free(void *opaque, uint8_t *data);
+
+void ff_es_data_free(void *opaque, uint8_t *data);
+
+void ff_es_jpeg_set_ppu_output_format(VSVDECContext *dec_ctx, struct DecConfig *config);
+
+int ff_es_jpeg_parse_ppset(VSVDECContext *dec_ctx, CropInfo *crop_info, ScaleInfo *scale_info);
+
+int ff_es_jpeg_set_ppu_crop_and_scale(VSVDECContext *dec_ctx, struct DecConfig *config);
+
+bool check_scale_value( uint32_t v);
+
+int ff_es_jpeg_get_align(uint32_t stride);
+
+int ff_es_jpeg_dec_paras_check(AVCodecContext *avctx);
+
+int ff_es_check_pixfmt(enum AVPixelFormat pixfmt);
+
+int ff_es_jpeg_init_frame_dump_handle(VSVDECContext *dec_ctx);
+
+int ff_es_jpeg_init_pkt_dump_handle(VSVDECContext *dec_ctx);
+
+int ff_es_jpeg_frame_dump(VSVDECContext *dec_ctx);
+
+int ff_es_jpeg_pkt_dump(VSVDECContext *dec_ctx);
+
+int ff_codec_dump_data_to_file_by_decpicture(struct DecPicture *pic, DumpHandle *dump_handle);
+
+int ff_es_dec_drop_pkt(AVCodecContext *avctx, AVPacket *avpkt);
+
+/* func for low latency feature */
+void ff_es_jpeg_wait_for_task_completion(task_handle task);
+
+uint32_t ff_es_jpeg_low_latency_task_init(VSVDECContext *dec_ctx);
+
+task_handle ff_es_jpeg_run_task(task_func func, void* param);
+
+void* ff_es_jpeg_send_bytestrm_task(void* param);
+
+uint32_t ff_es_jpeg_find_imagedata(u8 * p_stream, u32 stream_length);
+
+#endif
diff --git a/libavcodec/es_jpegdec.c b/libavcodec/es_jpegdec.c
new file mode 100644
index 0000000000..874d1a76a0
--- /dev/null
+++ b/libavcodec/es_jpegdec.c
@@ -0,0 +1,507 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+// #include "vsv_decode.h"
+#include "es_jpeg_decode.h"
+#include "jpegdecapi.h"
+#include "libavutil/hwcontext_es.h"
+
+#define NEXT_MULTIPLE(value, n) (((value) + (n) - 1) & ~((n) - 1))
+#define ALIGN(a) (1 << (a))
+
+static void jpeg_picture_consume(void *opaque, uint8_t *data)
+{
+    VSVDECContext *dec_ctx = opaque;
+    struct DecPicturePpu pic = *((struct DecPicturePpu *)data);
+    JpegDecOutput jpic;
+    int i;
+
+    memset(&jpic, 0, sizeof(JpegDecOutput));
+    /* TODO update chroma luma/chroma base */
+    for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++){
+        jpic.pictures[i].output_picture_y = pic.pictures[i].luma;
+    }
+
+    ff_es_jpeg_dec_del_pic_wait_consume_list(dec_ctx, data);
+    JpegDecPictureConsumed((void*)dec_ctx->dec_inst, &jpic);
+
+    av_free(data);
+}
+
+static av_cold int ff_es_jpeg_decode_close(AVCodecContext *avctx)
+{
+    VSVDECContext *dec_ctx = avctx->priv_data;
+    int i;
+
+    av_log(avctx, AV_LOG_DEBUG, "Es jpeg decode close.....\n");
+
+    if(dec_ctx->low_latency && (dec_ctx->decode_end_flag == 0)) {
+        dec_ctx->decode_end_flag = 1;
+        sem_post(&dec_ctx->frame_sem);
+        ff_es_jpeg_wait_for_task_completion(dec_ctx->task);
+        dec_ctx->task_existed = 0;
+        av_log(avctx, AV_LOG_DEBUG, "low_latency thread exited\n");
+    }
+
+    if (dec_ctx->pkt_dump_handle)
+        ff_codec_dump_file_close(&dec_ctx->pkt_dump_handle);
+
+    for ( int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if(dec_ctx->frame_dump_handle[i]) {
+            ff_codec_dump_file_close(&dec_ctx->frame_dump_handle[i]);
+        }
+    }
+
+    if(dec_ctx->dec_inst) {
+        JpegDecEndOfStream(dec_ctx->dec_inst);
+    }
+
+    av_packet_unref(&dec_ctx->avpkt);
+    dec_ctx->last_pic_flag = 1;
+    dec_ctx->closed = 1;
+
+    av_log(avctx, AV_LOG_DEBUG, "release input buffer\n");
+    for (i = 0; i < dec_ctx->allocated_buffers; i++) {
+        if (dec_ctx->stream_mem[i].virtual_address != NULL) {
+            if (dec_ctx->dec_inst)
+                DWLFreeLinear(dec_ctx->dwl_inst, &dec_ctx->stream_mem[i]);
+        }
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "release dec_inst\n");
+    if (dec_ctx->dec_inst)
+        JpegDecRelease(dec_ctx->dec_inst);
+
+    av_log(avctx, AV_LOG_DEBUG, "release output buffer\n");
+    ff_es_jpeg_dec_release_ext_buffers(dec_ctx);
+
+     av_log(avctx, AV_LOG_DEBUG, "release dwl_inst\n");
+    if (dec_ctx->dwl_inst)
+        DWLRelease(dec_ctx->dwl_inst);
+
+    if (dec_ctx->frame) {
+        av_frame_free(&dec_ctx->frame);
+    }
+
+    av_buffer_unref(&dec_ctx->hwframe);
+    av_buffer_unref(&dec_ctx->hwdevice);
+    return 0;
+}
+
+static av_cold int ff_es_jpeg_decode_init(AVCodecContext *avctx)
+{
+    int ret = 0;
+    VSVDECContext *dec_ctx = avctx->priv_data;
+    JpegDecApiVersion dec_api;
+    enum DecRet rv;
+    int  i;
+
+    avctx->apply_cropping = 0;//for RGB format can output
+    dec_api = JpegGetAPIVersion();
+    av_log(avctx, AV_LOG_DEBUG, "Jpeg Decoder API v%d.%d\n", dec_api.major, dec_api.minor);
+
+    ff_es_jpeg_dec_paras_check(avctx);
+
+    ret = ff_es_jpeg_dec_init_hwctx(avctx);
+    if (ret < 0)
+        return ret;
+
+    dec_ctx->vsv_decode_picture_consume = jpeg_picture_consume;
+    dec_ctx->vsv_decode_pri_picture_info_free = ff_es_pri_picture_info_free;
+    dec_ctx->data_free = ff_es_data_free;
+
+#ifdef FB_SYSLOG_ENABLE
+    sprintf(dec_ctx->module_name, "JPEGDEC");
+#endif
+
+    // ff_es_jpeg_create_dump_document(dec_ctx);
+
+    jpeg_dec_set_default_dec_config(avctx);
+
+    // ret = ff_es_jpeg_dec_set_buffer_number_for_trans(avctx);
+    // av_log(avctx, AV_LOG_DEBUG, "ff_es_jpeg_dec_set_buffer_number_for_trans %d\n", ret);
+
+    ret = ff_es_jpeg_dec_init_ppu_cfg(avctx,&dec_ctx->vsv_dec_config);
+    if (ret < 0){
+        av_log(avctx, AV_LOG_ERROR, "ff_es_jpeg_init_ppu_cfg failed\n");
+        goto error;
+    }
+
+    rv = jpeg_init(dec_ctx);
+    if (rv != DEC_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Decoder initialization failed!\n");
+        goto error;
+    } else {
+        av_log(avctx, AV_LOG_DEBUG, "JpegDecInit Init OK!\n");
+    }
+
+    ret = ff_es_jpeg_allocate_input_buffer(dec_ctx);
+    if (ret < 0)
+        goto error;
+
+    return ret;
+error:
+    ff_es_jpeg_decode_close(avctx);
+    return ret;
+}
+
+static int ff_es_jpeg_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    VSVDECContext *dec_ctx = avctx->priv_data;
+    // AVPacket avpkt = { 0 };
+    AVFrame *out = frame;
+    enum DecRet ret;
+    struct DWLLinearMem mem;
+    struct DecBufferInfo buf_info;
+    struct DecInputParameters jpeg_in;
+    AVFrame *tmp_frame;
+
+    tmp_frame = dec_ctx->frame;
+    u32 tmp = 0;
+    int rv = 0;
+
+    av_packet_unref(&dec_ctx->avpkt);
+    rv = ff_decode_get_packet(avctx, &dec_ctx->avpkt);
+
+    if (rv < 0 && rv != AVERROR_EOF) {
+        return rv;
+    } else if (rv == AVERROR_EOF) {
+
+        av_log(avctx, AV_LOG_DEBUG,
+               "in ff_es_jpeg_decode_receive_frame JpegDecEndOfStream  EOS... \n");
+
+        JpegDecEndOfStream(dec_ctx->dec_inst);
+        ret = ff_esdec_get_next_picture(avctx, frame);
+        if (ret < 0) {
+            return ret;
+        }
+    }
+
+    dec_ctx->got_package_number++;
+
+    if(dec_ctx->drop_frame_interval > 0 ){
+        rv = ff_es_dec_drop_pkt(avctx, &dec_ctx->avpkt);
+        if (rv < 0)
+            goto err_exit;
+    }
+
+    // ff_es_jpeg_pkt_dump(dec_ctx, &dec_ctx->avpkt);
+
+    if(dec_ctx->low_latency) {
+        if (!dec_ctx->task_existed) {
+            ff_es_jpeg_low_latency_task_init(dec_ctx);
+        }
+        else {
+            if (!dec_ctx->avpkt.data) {
+                av_log(NULL, AV_LOG_ERROR, "pkt.data is invaild, exit low_latency pthread\n");
+                goto err_exit;
+            }
+            dec_ctx->send_strm_info.strm_bus_addr =
+                        dec_ctx->send_strm_info.strm_bus_start_addr =
+                        dec_ctx->stream_mem[dec_ctx->stream_mem_index].bus_address;
+            dec_ctx->send_strm_info.strm_vir_addr =
+                        dec_ctx->send_strm_info.strm_vir_start_addr =
+                        (u8 *)dec_ctx->stream_mem[dec_ctx->stream_mem_index].virtual_address;
+            sem_post(&dec_ctx->frame_sem);
+        }
+    }  else {
+        ff_es_jpeg_dec_send_avpkt_to_decode_buffer(avctx,
+                                                   &dec_ctx->avpkt,
+                                                   dec_ctx->stream_mem[dec_ctx->stream_mem_index]);
+    }
+
+    if(dec_ctx->low_latency) {
+        sem_wait(&dec_ctx->send_sem);
+        jpeg_in.strm_len = dec_ctx->sw_hw_bound;
+    }
+
+    // init jpeg_in
+    ff_es_jpeg_dec_init_dec_input_paras(&dec_ctx->avpkt, dec_ctx, &jpeg_in);
+
+decode:
+
+    dec_ctx->sequence_info.jpeg_input_info = jpeg_in;
+
+    ret = jpeg_dec_get_info(dec_ctx);
+    if(ret != DEC_OK) {
+        av_log(avctx, AV_LOG_ERROR, "jpeg_dec_get_info return: %d\n", ret);
+        goto err_exit;
+    } else {
+        av_log(avctx, AV_LOG_DEBUG, "[%s:%d] get image info successful\n", __func__, __LINE__);
+        ff_es_jpeg_dec_print_image_info(avctx, &dec_ctx->sequence_info);
+    }
+
+    // create pkt dump file
+    if (dec_ctx->packet_dump && !dec_ctx->pkt_dump_handle)
+        ff_es_jpeg_init_pkt_dump_handle(dec_ctx);
+    ff_es_jpeg_pkt_dump(dec_ctx);
+
+    // update jpeg_in after jpeg_dec_get_info
+    ff_es_jpeg_dec_update_dec_input_paras(dec_ctx, &jpeg_in);
+    if (dec_ctx->thumb_mode == Decode_Pic_Thumb && dec_ctx->thum_exist && dec_ctx->thum_out) {
+        jpeg_in.dec_image_type = JPEGDEC_THUMBNAIL;
+    }
+
+    dec_ctx->vsv_dec_config.dec_image_type = jpeg_in.dec_image_type;
+
+    rv = ff_es_jpeg_dec_modify_config_by_sequence_info(avctx);
+    if (rv < 0)
+        goto err_exit;
+
+    //modify dec_ctx->vsv_dec_config according to dec_ctx->thum_out.
+    ff_es_jpeg_dec_modify_thum_config_by_sequence_info(avctx);
+
+    tmp = jpeg_dec_set_info((void* )dec_ctx->dec_inst, dec_ctx->vsv_dec_config);
+    av_log(avctx, AV_LOG_DEBUG, "jpeg_dec_set_info return: %d\n", tmp);
+    if (tmp != DEC_OK)
+        goto err_exit;
+
+allocate_buffer:
+
+    rv = jpeg_get_buffer_info((void* )dec_ctx->dec_inst, &buf_info);
+    av_log(avctx, AV_LOG_DEBUG, "jpeg_get_buffer_info return: %d\n", rv);
+    if(rv != DEC_WAITING_FOR_BUFFER && rv != DEC_OK)
+        goto err_exit;
+
+    av_log(avctx, AV_LOG_DEBUG, "buf_to_free %p, next_buf_size %d, buf_num %d\n",
+            (void *)buf_info.buf_to_free.virtual_address, buf_info.next_buf_size, buf_info.buf_num);
+
+    rv = ff_es_jpeg_allocate_output_buffer(dec_ctx, &buf_info);
+
+    if (rv < 0)
+        goto err_exit;
+
+    rv = ff_es_jpeg_decoder(avctx, &jpeg_in, frame);
+
+    if (rv == ES_MORE_BUFFER) {
+        goto allocate_buffer;
+    } else if (rv == ES_ERROR) {
+        goto err_exit;
+    }
+
+    if (dec_ctx->thumb_mode == Decode_Pic_Thumb && dec_ctx->thum_exist && !dec_ctx->thum_out) {
+        dec_ctx->thum_out = 1;
+        goto decode;
+    }
+
+    if (ret == ES_OK) {
+        if (avctx->width != frame->width || avctx->height != frame->height) {
+            avctx->width = frame->width;
+            avctx->height = frame->height;
+        }
+
+        if (avctx->pix_fmt == AV_PIX_FMT_ES) {
+            frame->format = AV_PIX_FMT_ES;
+            frame->hw_frames_ctx = av_buffer_ref(dec_ctx->hwframe);
+        } else if (frame->flags & AV_FRAME_FLAG_DISCARD){
+            frame->format = avctx->sw_pix_fmt;
+        } else {
+            av_frame_move_ref(tmp_frame, frame);
+            ret = ff_get_buffer(avctx, frame, 0);
+            if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "ff_get_buffer failed\n");
+            } else {
+                frame->pts = tmp_frame->pts;
+                tmp_frame->hw_frames_ctx = av_buffer_ref(dec_ctx->hwframe);
+                ret = av_hwframe_transfer_data(frame, tmp_frame, 0);
+                if (ret) {
+                    av_log(avctx, AV_LOG_ERROR, "av_hwframe_transfer_data failed\n");
+                }
+            }
+            av_frame_unref(tmp_frame);
+        }
+    }
+
+err_exit:
+    av_log(avctx, AV_LOG_DEBUG, "exit of jpeg_decode_frame...\n");
+    if(dec_ctx->low_latency) {
+        dec_ctx->pic_decoded = 1;
+        av_log(avctx, AV_LOG_DEBUG, "send_bytestrm_task sleep\n");
+    }
+    return AVERROR_EOF;
+}
+
+static void ff_es_jpeg_decode_flush(AVCodecContext *avctx)
+{
+}
+
+#define OFFSET(x) offsetof(VSVDECContext, x)
+#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM
+static const AVOption options[] = {
+    { "stride_align", "set out_stride", OFFSET(out_stride),
+        AV_OPT_TYPE_INT,  { .i64 = 64 }, 1, 2048, VD },
+    { "pp0_enabled", "set pp0 output enable", OFFSET(cfg_pp_enabled[0]),
+        AV_OPT_TYPE_INT,  { .i64 = 1 }, 0, 1, VD },
+    { "pp0_format", "set ppu0 output format", OFFSET(output_format[0]),
+        AV_OPT_TYPE_INT,  { .i64 = 23 }, 0, INT_MAX, VD },
+    { "pp0_set", "set pp configure", OFFSET(pp_setting[0]),
+        AV_OPT_TYPE_STRING, {.str=NULL}, 0, 0, VD }, //pp0 not support scale
+    { "pp1_enabled", "set pp0 output enable", OFFSET(cfg_pp_enabled[1]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "pp1_format", "set ppu1 output format", OFFSET(output_format[1]),
+        AV_OPT_TYPE_INT,  { .i64 = 23 }, 0, INT_MAX, VD },
+    { "pp1_set", "set pp configure", OFFSET(pp_setting[1]),
+        AV_OPT_TYPE_STRING, {.str=NULL}, 0, 0, VD },
+    { "packet_dump", "set dump packet", OFFSET(packet_dump),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "dump_path", "set dump packet path", OFFSET(dump_path),
+        AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VD },
+    { "packet_dump_time", "set dump packet time", OFFSET(packet_dump_time),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, INT_MAX, VD },
+    { "pp0_frame_dump", "set pp0 frame dump", OFFSET(frame_dump[0]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 60, VD },
+    { "pp1_frame_dump", "set pp1 frame dump", OFFSET(frame_dump[1]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 60, VD },
+    { "pp0_frame_dump_time", "set dump pp0 frame time", OFFSET(frame_dump_time[0]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, INT_MAX, VD },
+    { "pp1_frame_dump_time", "set dump pp1 frame time", OFFSET(frame_dump_time[1]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, INT_MAX, VD },
+    { "pmode", "set pkt dump mode", OFFSET(pmode),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "fmode", "set frame dump mode", OFFSET(fmode),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "drop_frame_interval", "set drop frame interval", OFFSET(drop_frame_interval),
+        AV_OPT_TYPE_INT,  {.i64 = 0 }, 0, INT_MAX, VD },
+    { "thumb_mode", "0: only decode picture, 1: only decode thumbnail, 2: decode thumbnail and picture.",
+        OFFSET(thumb_mode), AV_OPT_TYPE_INT,  {.i64 = Decode_Pic_Thumb }, 0, 2, VD, "thumbmode"},
+    { "decode_pic", "0: only decode picture",  0,
+        AV_OPT_TYPE_CONST, { .i64 = Only_Decode_Pic } , 0, 2, VD, "thumbmode"},
+    { "decode_thumb", "1: only decode thumbnail",  0,
+        AV_OPT_TYPE_CONST, { .i64 = Only_Decode_Thumb } , 0, 2, VD, "thumbmode"},
+    { "decode_both", "2: decode thumbnail and picture",  0,
+        AV_OPT_TYPE_CONST, { .i64 = Decode_Pic_Thumb } , 0, 2, VD, "thumbmode"},
+    { "decode_mode", "decode mode: dec_normal, dec_low_latency",  OFFSET(decode_mode),
+        AV_OPT_TYPE_INT, { .i64 =  DEC_NORMAL} , 0, 8, VD, "decode_mode"},
+    { "dec_normal", "decode mode: dec_normal",  0,
+        AV_OPT_TYPE_CONST, { .i64 =  DEC_NORMAL} , 0, 8, VD, "decode_mode"},
+    { "dec_low_latency", "decode mode: dec_low_latency",  0,
+        AV_OPT_TYPE_CONST, { .i64 =  DEC_LOW_LATENCY} , 0, 8, VD, "decode_mode"},
+
+    // ffmpeg set opts
+    { "down_scale", "width:height or ratio_x:ratio_y", OFFSET(scale_set),
+        AV_OPT_TYPE_STRING, { .str="0:0" }, 0, 0, VD },
+    { "pp0_crop", "crop (top)x(bottom)x(left)x(right)", OFFSET(crop_set[0]),
+        AV_OPT_TYPE_STRING, { .str=NULL }, 0, 0, VD },
+    { "pp1_crop", "crop (top)x(bottom)x(left)x(right)", OFFSET(crop_set[1]),
+        AV_OPT_TYPE_STRING, { .str=NULL }, 0, 0, VD },
+    { "frame_dump", "frame dump enable, next set filename better", OFFSET(fdump),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "filename", " frame dump filename", OFFSET(filename),
+        AV_OPT_TYPE_STRING,  { .str="dump_file" }, 0, 0, VD },
+    { "force_8bit", "force output 8 bits data", OFFSET(force_8bit),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "pp0", "PP0 output enable",  OFFSET(cfg_pp_enabled[0]),
+        AV_OPT_TYPE_INT, { .i64 = 1 }, 0, 1, VD, "enable pp"},
+    { "pp1", "PP1 output enable",  OFFSET(cfg_pp_enabled[1]),
+        AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VD, "enable pp"},
+    { "pp_out", "set pp output enable", OFFSET(pp_out),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "enable", "enable pp",  0,
+        AV_OPT_TYPE_CONST, { .i64 = 1 } , 0, 1, VD, "enable pp"},
+    { "disable", "disable pp",  0,
+        AV_OPT_TYPE_CONST, { .i64 = 0 } , 0, 0, VD, "enable pp"},
+    { "pp0_fmt", "set pp0 output format",  OFFSET(output_format[0]),
+        AV_OPT_TYPE_INT, { .i64 = 23 } , 0, 194, VD, "pp0_fmt"},
+    { "pp1_fmt", "set pp1 output format",  OFFSET(output_format[1]),
+        AV_OPT_TYPE_INT, { .i64 = 23 } , 0, 194, VD, "pp1_fmt"},
+
+    // set pp0 format
+    { "nv12", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_NV12 } , 0, 194, VD, "pp0_fmt"},
+    { "nv21", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_NV21 } , 0, 194, VD, "pp0_fmt"},
+    { "yuv420p", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_YUV420P } , 0, 194, VD, "pp0_fmt"},
+    { "gray", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_GRAY8 } , 0, 194, VD, "pp0_fmt"},
+    // set pp1 format
+    { "nv12", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_NV12 } , 0, 194, VD, "pp1_fmt"},
+    { "nv21", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_NV21 } , 0, 194, VD, "pp1_fmt"},
+    { "yuv420p", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_YUV420P } , 0, 194, VD, "pp1_fmt"},
+    { "gray", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_GRAY8 } , 0, 194, VD, "pp1_fmt"},
+    { "rgb24", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_RGB24 } , 0, 194, VD, "pp1_fmt"},
+    { "bgr24", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_BGR24 } , 0, 194, VD, "pp1_fmt"},
+    { "argb", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_ARGB } , 0, 194, VD, "pp1_fmt"},
+    { "abgr", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_ABGR } , 0, 194, VD, "pp1_fmt"},
+    { "0rgb", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_0RGB } , 0, 194, VD, "pp1_fmt"},
+    { "0bgr", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_0BGR } , 0, 194, VD, "pp1_fmt"},
+    { NULL },
+};
+
+static const AVClass es_jpeg_decode_class = {
+    .class_name = "es_jpeg_decoder",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+static const AVCodecDefault es_jpeg_decode_defaults[] = {
+    { NULL },
+};
+
+static const enum AVPixelFormat es_jdec_support_pixfmts[] = {AV_PIX_FMT_ES,
+                                                             AV_PIX_FMT_YUV420P,
+                                                             AV_PIX_FMT_NV12,
+                                                             AV_PIX_FMT_NV21,
+                                                             AV_PIX_FMT_GRAY8,
+                                                             AV_PIX_FMT_NONE};
+
+static const AVCodecHWConfigInternal *es_hw_configs[] = {
+    &(const AVCodecHWConfigInternal) {
+        .public = {
+            .pix_fmt     = AV_PIX_FMT_ES,
+            .methods     = AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX
+                           | AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX
+                           | AV_CODEC_HW_CONFIG_METHOD_INTERNAL,
+            .device_type = AV_HWDEVICE_TYPE_ES,
+        },
+        .hwaccel = NULL,
+    },
+    NULL
+};
+
+AVCodec ff_jpeg_es_decoder = {
+    .name           = "jpeg_es_decoder",
+    .long_name      = NULL_IF_CONFIG_SMALL("Eswin JPEG decoder, on VeriSilicon & GStreamer & FFmpeg."),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_MJPEG,
+    .priv_data_size = sizeof(VSVDECContext),
+    .init           = &ff_es_jpeg_decode_init,
+    .close          = &ff_es_jpeg_decode_close,
+    .receive_frame  = &ff_es_jpeg_decode_receive_frame,
+    .flush          = &ff_es_jpeg_decode_flush,
+    .priv_class     = &es_jpeg_decode_class,
+    .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE | AV_CODEC_CAP_AVOID_PROBING,
+    .defaults       = es_jpeg_decode_defaults,
+    .pix_fmts       = es_jdec_support_pixfmts,
+    .hw_configs     = es_hw_configs,
+    .wrapper_name   = "es",
+    //.bsfs           = "mjpeg2jpeg",
+};
diff --git a/libavcodec/es_jpegenc.c b/libavcodec/es_jpegenc.c
new file mode 100644
index 0000000000..d4c97cd5d4
--- /dev/null
+++ b/libavcodec/es_jpegenc.c
@@ -0,0 +1,2621 @@
+
+/*
+ * Copyright (C) 2022 Eswin
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include "libavutil/opt.h"
+#include "hwconfig.h"
+#include "avcodec.h"
+#include <libavutil/imgutils.h>
+
+#include "jpegencapi.h"
+#include "encinputlinebuffer.h"
+#include "es_jpegenc.h"
+#include "es_common.h"
+#include "encode.h"
+#include "codec_internal.h"
+
+#ifndef OFFSET
+#define OFFSET(x) offsetof(EsJpegEncodeContext, x)
+#endif
+
+#ifndef FLAGS
+#define FLAGS (AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_EXPORT)
+#endif
+
+#ifndef UNUSED
+#define UNUSED(x) (void)x;
+#endif
+
+#define JPEG_ES_ENCODER_STR "jpeg_es_encoder"
+
+#define USER_DEFINED_QTABLE 10
+
+/*------------------------------------------------------------------------------
+    4. Local function prototypes
+------------------------------------------------------------------------------*/
+static int read_roimap(AVCodecContext *avctx);
+static int read_non_roi_fliter(AVCodecContext *avctx);
+static JpegEncRet es_jenc_alloc_roi_res(AVCodecContext *avctx);
+static void es_jenc_get_aligned_pic_size_by_format(
+    JpegEncFrameType type, u32 width, u32 height, u32 alignment, u64 *luma_size, u64 *chroma_size, u64 *picture_size);
+static void es_jpeg_encode_report(AVCodecContext *avctx);  // TODO: Performance report
+static JpegEncRet es_jenc_config_codec(AVCodecContext *avctx);
+static JpegEncRet es_jenc_alloc_codec_res(AVCodecContext *avctx);
+static JpegEncRet es_jenc_free_codec_res(AVCodecContext *avctx);
+static JpegEncRet es_jenc_init_codec(AVCodecContext *avctx);
+static JpegEncRet es_jenc_release_codec(AVCodecContext *avctx);
+static JpegEncRet es_jenc_init_thumbnail(AVCodecContext *avctx);
+static JpegEncRet es_jenc_set_thumbnail(AVCodecContext *avctx);
+static JpegEncRet es_jenc_init_input_line_buffer(AVCodecContext *avctx);
+static JpegEncRet es_jenc_set_input_line_buffer(AVCodecContext *avctx);
+static JpegEncRet es_jenc_set_quant_table(AVCodecContext *avctx);
+static int es_jenc_realloc_output_buffer(AVCodecContext *avctx, int new_size);
+
+static const AVOption es_jpeg_encode_options[] = {
+    // pre-processor setting
+    {"rotation",
+     "pre-processor, rotation. 0=0 degree, 90=right 90 degree, 270=left 90 degree, 180=right 180 "
+     "degree.",
+     OFFSET(jpeg_option_params.rotation),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     360,
+     FLAGS},
+    {"mirror",
+     "pre-processor, mirror. 0=disable, 1=enable.",
+     OFFSET(jpeg_option_params.mirror),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1,
+     FLAGS},
+    // crop string:
+    {"crop",
+     "crop 'cx:N,cy:N,cw:N,ch:N',mean crop xoffset,yoffset,out_width,out_heigh",
+     OFFSET(crop_str),
+     AV_OPT_TYPE_STRING,
+     {.str = "cx:0,cy:0,cw:0,ch:0"},
+     0,
+     0,
+     FLAGS},
+    // thumbnail setting:
+    {"input_thumb",
+     "thumbnail input file path. [thumbnail.jpg] ",
+     OFFSET(jpeg_option_params.inputThumb),
+     AV_OPT_TYPE_STRING,
+     {.str = NULL},
+     0,
+     0,
+     FLAGS},
+    {"thumb_fmt",
+     "thumbnail format. 0:disable 1:JPEG 2:RGB8 3:RGB24 ",
+     OFFSET(jpeg_option_params.thumbnailFormat),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     3,
+     FLAGS},
+    {"thumb_w",
+     "thumbnail width. [0, 255]",
+     OFFSET(jpeg_option_params.widthThumb),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     255,
+     FLAGS},
+    {"thumb_h",
+     "thumbnail heigh. [0, 255]",
+     OFFSET(jpeg_option_params.heightThumb),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     255,
+     FLAGS},
+    // Quantization
+    {"qp",
+     "quantization scale.[0, 10] 10 = user defined qtable.",
+     OFFSET(jpeg_option_params.qLevel),
+     AV_OPT_TYPE_INT,
+     {.i64 = 1},
+     0,
+     10,
+     FLAGS},
+    {"qtable_path",
+     "user defined qtable path",
+     OFFSET(jpeg_option_params.qTablePath),
+     AV_OPT_TYPE_STRING,
+     {.str = NULL},
+     0,
+     0,
+     FLAGS},
+    // Density
+    {"units",
+     "Units type of x- and y-density, 0 = pixel aspect ratio, 1 = dots/inch, 2 = dots/cm ",
+     OFFSET(jpeg_option_params.unitsType),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     2,
+     FLAGS},
+    {"xdensity",
+     "Xdensity to APP0 header. ",
+     OFFSET(jpeg_option_params.xdensity),
+     AV_OPT_TYPE_INT,
+     {.i64 = 1},
+     1,
+     0xFFFFU,
+     FLAGS},
+    {"ydensity",
+     "Ydensity to APP0 header. ",
+     OFFSET(jpeg_option_params.ydensity),
+     AV_OPT_TYPE_INT,
+     {.i64 = 1},
+     1,
+     0xFFFFU,
+     FLAGS},
+    // ConstChroma
+    {"enable_const_chroma",
+     "Enable/Disable set chroma to a constant pixel value. 0:disable,1:enable  ",
+     OFFSET(jpeg_option_params.constChromaEn),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1,
+     FLAGS},
+    {"const_cb",
+     "The constant pixel value for Cb.   ",
+     OFFSET(jpeg_option_params.constCb),
+     AV_OPT_TYPE_INT,
+     {.i64 = 128},
+     0,
+     255,
+     FLAGS},
+    {"const_cr",
+     "The constant pixel value for Cr.   ",
+     OFFSET(jpeg_option_params.constCr),
+     AV_OPT_TYPE_INT,
+     {.i64 = 128},
+     0,
+     255,
+     FLAGS},
+    // ROI: jpeg only:
+    {"roi_file",
+     "Input file for roimap region. [jpeg_roimap.roi]",
+     OFFSET(jpeg_option_params.roimapFile),
+     AV_OPT_TYPE_STRING,
+     {.str = NULL},
+     0,
+     0,
+     FLAGS},
+    {"non_roi_file",
+     "Input file for nonroimap region filter. [filter.txt]",
+     OFFSET(jpeg_option_params.nonRoiFilter),
+     AV_OPT_TYPE_STRING,
+     {.str = NULL},
+     0,
+     0,
+     FLAGS},
+    {"non_roi_level",
+     "non_roi filter level (0 - 10), 10:user define ",
+     OFFSET(jpeg_option_params.nonRoiLevel),
+     AV_OPT_TYPE_INT,
+     {.i64 = 10},
+     0,
+     10,
+     FLAGS},
+    {"enable_roi",
+     "enable or disable the roi feature  ",
+     OFFSET(jpeg_option_params.roi_enable),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1,
+     FLAGS},
+    // mjpeg
+    {"rc_mode",
+     "Rate control mode, 0: single frame, 1: CBR, 2: VBR.",
+     OFFSET(jpeg_option_params.rcMode),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     2,
+     FLAGS},
+    {"bit_per_second",
+     "Target bits per second, 0: RC off, other: bit number.(unused)",
+     OFFSET(jpeg_option_params.bitPerSecond),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1048575,
+     FLAGS},
+    {"fixed_qp",
+     "Fixed QP number for each frame.",
+     OFFSET(jpeg_option_params.fixedQP),
+     AV_OPT_TYPE_INT,
+     {.i64 = -1},
+     -1,
+     51,
+     FLAGS},
+    {"frame_rate_num",
+     "Frame rate number.(unused)",
+     OFFSET(jpeg_option_params.frameRateNum),
+     AV_OPT_TYPE_INT,
+     {.i64 = 30},
+     1,
+     1048575,
+     FLAGS},
+    {"frame_rate_denom",
+     "Frame rate denominator.(unused)",
+     OFFSET(jpeg_option_params.frameRateDenom),
+     AV_OPT_TYPE_INT,
+     {.i64 = 1},
+     1,
+     1048575,
+     FLAGS},
+    {"pic_qp_delta_min",
+     "Picture level QP delta min value.",
+     OFFSET(jpeg_option_params.picQpDeltaMin),
+     AV_OPT_TYPE_INT,
+     {.i64 = -2},
+     -10,
+     -1,
+     FLAGS},
+    {"pic_qp_delta_max",
+     "Picture level QP delta max value.",
+     OFFSET(jpeg_option_params.picQpDeltaMax),
+     AV_OPT_TYPE_INT,
+     {.i64 = 3},
+     1,
+     10,
+     FLAGS},
+    {"qp_min", "Min QP value.(unused)", OFFSET(jpeg_option_params.qpmin), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 51, FLAGS},
+    {"qp_max", "Max QP value.(unused)", OFFSET(jpeg_option_params.qpmax), AV_OPT_TYPE_INT, {.i64 = 51}, 0, 51, FLAGS},
+    // marker type
+    {"marker_type",
+     "Quantization/Huffman table markers type, 0 = Single marker 1 = Multiple markers",
+     OFFSET(jpeg_option_params.markerType),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1,
+     FLAGS},
+    // line buffer
+    {"linebuf_mode",
+     "Line buffer mode, 0=disable; 1=SW Loopback enabled; 3=SW Loopback disable",
+     OFFSET(jpeg_option_params.inputLineBufMode),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     4,
+     FLAGS},
+    {"linebuf_depth",
+     "Number of MCU rows to control loop-back/handshaking,0 is only allowed with linebuf_mode = 3",
+     OFFSET(jpeg_option_params.inputLineBufDepth),
+     AV_OPT_TYPE_INT,
+     {.i64 = 1},
+     0,
+     511,
+     FLAGS},
+    {"linebuf_amount",
+     "Handshake sync amount for every loopback",
+     OFFSET(jpeg_option_params.amountPerLoopBack),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1023,
+     FLAGS},
+    {"stride_align",
+     "set the stride alignment of input frame, multiple of 16",
+     OFFSET(jpeg_option_params.exp_of_input_alignment),
+     AV_OPT_TYPE_INT,
+     {.i64 = 64},
+     0,
+     4096,
+     FLAGS},
+    {"partial_coding",
+     "Encode a picture as several slices(partial Coding), 0 = disable, 1 = enable",
+     OFFSET(jpeg_option_params.partialCoding),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1,
+     FLAGS},
+    {"restart_interval",
+     "Restart interval in MCU rows, each MCU row has a height of 16 pixels ",
+     OFFSET(jpeg_option_params.restartInterval),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1048575,
+     FLAGS},
+    {NULL},
+};
+
+static const AVCodecHWConfigInternal *es_jpeg_encode_hw_configs[] = {
+    &(const AVCodecHWConfigInternal){
+        .public =
+            {
+                .pix_fmt = AV_PIX_FMT_ES,
+                .methods = AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX | AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX
+                           | AV_CODEC_HW_CONFIG_METHOD_INTERNAL,
+                .device_type = AV_HWDEVICE_TYPE_ES,
+            },
+        .hwaccel = NULL,
+    },
+    NULL};
+
+static const FFCodecDefault es_jpeg_encode_defaults[] = {
+    {NULL},
+};
+
+static const AVClass es_jpeg_encode_class = {
+    .class_name = JPEG_ES_ENCODER_STR,
+    .item_name = av_default_item_name,
+    .option = es_jpeg_encode_options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+/* jpeg support such input pix_fmt */
+static const enum AVPixelFormat es_jenc_support_pixfmts[] = {AV_PIX_FMT_ES,
+                                                             AV_PIX_FMT_YUV420P,
+                                                             AV_PIX_FMT_NV12,
+                                                             AV_PIX_FMT_NV21,
+                                                             AV_PIX_FMT_YUYV422,
+                                                             AV_PIX_FMT_UYVY422,
+                                                             AV_PIX_FMT_P010LE,
+                                                             AV_PIX_FMT_YUV420P10LE,
+                                                             /*todo: test add more supported pixfmt*/
+                                                             AV_PIX_FMT_NONE};
+
+/**-------------------------FUNCTION------------------------------------**/
+/**Private function ,print the params info*/
+static void es_jenc_print_params(AVCodecContext *avctx, EsJpegEncParams *params) {
+    if (!params) {
+        av_log(avctx, AV_LOG_ERROR, "Params args invalid: Null pointer found.\n");
+        return;
+    }
+    av_log(NULL, AV_LOG_INFO, "\n\t**********************************************************\n");
+    av_log(NULL, AV_LOG_INFO, "\n\t-ESW JPEG: ENCODER PARAMS\n");
+    av_log(NULL, AV_LOG_INFO, "");
+    if (params->qLevel == USER_DEFINED_QTABLE) {
+        av_log(avctx, AV_LOG_INFO, "JPEG: User Define qTableLuma \n");
+    }
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: qp \t\t\t:%d\n", params->qLevel);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: inputWidth \t\t:%d\n", params->lumWidthSrc);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: inputHeight \t\t:%d\n", params->lumHeightSrc);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: outputWidth  \t\t:%d\n", params->width);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: outputHeight \t\t:%d\n", params->height);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: horOffsetSrc \t\t:%d\n", params->horOffsetSrc);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: verOffsetSrc \t\t:%d\n", params->verOffsetSrc);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: restartInterval \t\t:%d\n", params->restartInterval);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: frameType \t\t:%d\n", params->frameType);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: colorConversion \t\t:%d\n", params->colorConversion);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: rotation \t\t:%d\n", params->rotation);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: partialCoding \t\t:%d\n", params->partialCoding);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: codingMode \t\t:%d\n", params->codingMode);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: markerType \t\t:%d\n", params->markerType);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: unitsType \t\t:%d\n", params->unitsType);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: xdensity \t\t:%d\n", params->xdensity);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: ydensity \t\t:%d\n", params->ydensity);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: thumbnailformat \t\t:%d\n", params->thumbnailFormat);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: widthThumb \t\t:%d\n", params->widthThumb);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: heightThumb \t\t:%d\n", params->heightThumb);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: inputLineBufMode \t:%d\n", params->inputLineBufMode);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: inputLineBufDepth \t:%d\n", params->inputLineBufDepth);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: amountPerLoopBack \t:%d\n", params->amountPerLoopBack);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: mirror \t\t\t:%d\n", params->mirror);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: formatCustomizedType \t:%d\n", params->formatCustomizedType);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: constChromaEn \t\t:%d\n", params->constChromaEn);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: constCb \t\t\t:%u\n", params->constCb);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: constCr \t\t\t:%u\n", params->constCr);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: picQpDeltaMin \t\t:%i\n", params->picQpDeltaMin);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: picQpDeltaMax \t\t:%i\n", params->picQpDeltaMax);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: losslessEnable \t\t:%d\n", params->losslessEnable);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: predictMode \t\t:%d\n", params->predictMode);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: exp_of_input_alignment \t:%u\n", params->exp_of_input_alignment);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: streamBufChain \t\t:%u\n", params->streamBufChain);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: streamMultiSegmentMode \t:%u\n", params->streamMultiSegmentMode);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: mosaicEnables \t\t:%u\n", params->mosaicEnables);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: sramPowerdownDisable \t:%u\n", params->sramPowerdownDisable);
+    av_log(avctx, AV_LOG_INFO, "\t-JPEG: burstMaxLength \t\t:%u\n", params->burstMaxLength);
+    av_log(NULL, AV_LOG_INFO, "\n\t**********************************************************\n\n");
+}
+
+/**initialization the codecs params*/
+JpegEncRet es_jenc_init_params(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *params = &(jpeg_enc_ctx->jpeg_enc_params);
+    EsJpegEncParams *option_params = &(jpeg_enc_ctx->jpeg_option_params);
+    CropInfo crop_info;
+    JpegEncRet ret_value;
+    enum AVPixelFormat pix_fmt = avctx->pix_fmt;
+    int counter;
+
+    av_log(avctx, AV_LOG_INFO, "es_jenc_init_params() IN\n");
+    memset(params, 0, sizeof(EsJpegEncParams));
+
+    /*encode compress rate, default 10*/
+    jpeg_enc_ctx->compress_rate = 10;
+
+    /*stride must multiple of 16*/
+    if (option_params->exp_of_input_alignment && option_params->exp_of_input_alignment % 16) {
+        av_log(avctx, AV_LOG_ERROR, "in_align %d is not multiple of 16\n", option_params->exp_of_input_alignment);
+        return JPEGENC_ERROR;
+    }
+    params->exp_of_input_alignment = log2(option_params->exp_of_input_alignment);
+
+    // check input width and height
+    params->lumWidthSrc = FFALIGN(avctx->width, 1 << params->exp_of_input_alignment);
+    params->lumHeightSrc = avctx->height;
+
+    // check output width and height
+    params->width = avctx->width;
+    params->height = avctx->height;
+
+    // Parse crop string.
+    if (ff_codec_get_crop(jpeg_enc_ctx->crop_str, &crop_info)) {
+        av_log(avctx, AV_LOG_ERROR, "parser crop config error\n");
+        return -1;
+    }
+
+    av_log(avctx,
+           AV_LOG_DEBUG,
+           "crop info: w:%d, h:%d, x:%d, y:%d\n",
+           crop_info.crop_width,
+           crop_info.crop_height,
+           crop_info.crop_xoffset,
+           crop_info.crop_yoffset);
+
+    if (crop_info.crop_width > 0) params->width = crop_info.crop_width;
+    if (crop_info.crop_height > 0) params->height = crop_info.crop_height;
+
+    if (crop_info.crop_xoffset >= 0) params->horOffsetSrc = crop_info.crop_xoffset;
+    if (crop_info.crop_yoffset >= 0) params->verOffsetSrc = crop_info.crop_yoffset;
+
+    av_log(avctx,
+           AV_LOG_INFO,
+           "avctx: src wxh [%dx%d],dest wxh [%dx%d] \n",
+           params->lumWidthSrc,
+           params->lumHeightSrc,
+           params->width,
+           params->height);
+
+    params->useVcmd = -1;
+    jpeg_enc_ctx->roi_enable = option_params->roi_enable;
+    params->roimapFile = option_params->roimapFile;
+    params->nonRoiFilter = option_params->nonRoiFilter;
+    params->nonRoiLevel = option_params->nonRoiLevel;
+
+    // pix_fmt:
+    if (pix_fmt == AV_PIX_FMT_ES) {
+        pix_fmt = avctx->sw_pix_fmt;
+    }
+    av_log(avctx, AV_LOG_INFO, "pix_fmt: %s\n", av_get_pix_fmt_name(pix_fmt));
+    switch (pix_fmt) {
+        case AV_PIX_FMT_YUV420P:
+            params->frameType = JPEGENC_YUV420_PLANAR;
+            break;
+        case AV_PIX_FMT_NV12:
+            params->frameType = JPEGENC_YUV420_SEMIPLANAR;
+            break;
+        case AV_PIX_FMT_NV21:
+            params->frameType = JPEGENC_YUV420_SEMIPLANAR_VU;
+            break;
+        case AV_PIX_FMT_UYVY422:
+            params->frameType = JPEGENC_YUV422_INTERLEAVED_UYVY;
+            break;
+        case AV_PIX_FMT_YUYV422:
+            params->frameType = JPEGENC_YUV422_INTERLEAVED_YUYV;
+            break;
+        case AV_PIX_FMT_YUV420P10LE:
+            params->frameType = JPEGENC_YUV420_I010;
+            break;
+        case AV_PIX_FMT_P010LE:
+            params->frameType = JPEGENC_YUV420_MS_P010;
+            break;
+        default:
+            params->frameType = JPEGENC_YUV420_PLANAR;
+            break;
+    }
+
+    // Thumbnail.
+    ret_value = es_jenc_init_thumbnail(avctx);
+    if (ret_value != JPEGENC_OK) {
+        av_log(avctx, AV_LOG_INFO, "thumbnail init failed\n");
+    }
+
+    // mosaic VC unsupported
+    params->mosaicEnables = 0;
+
+    // Rotation.
+    params->rotation = option_params->rotation;
+
+    // Quantization
+    params->qLevel = 1;
+    ret_value = es_jenc_set_quant_table(avctx);
+    if (ret_value != JPEGENC_OK) {
+        av_log(avctx, AV_LOG_INFO, "quantization set failed\n");
+    }
+
+    // Slice mode
+    params->partialCoding = option_params->partialCoding;
+    params->restartInterval = option_params->restartInterval;
+
+    params->colorConversion = 0;
+    params->codingMode = JPEGENC_420_MODE;
+    params->markerType = option_params->markerType;
+    params->unitsType = option_params->unitsType;
+    params->xdensity = option_params->xdensity;
+    params->ydensity = option_params->ydensity;
+    params->comLength = 0;
+    params->inputLineBufMode = option_params->inputLineBufMode;
+    jpeg_enc_ctx->input_line_buf_mode = params->inputLineBufMode;
+    params->inputLineBufDepth = option_params->inputLineBufDepth;
+    params->amountPerLoopBack = option_params->amountPerLoopBack;
+    params->hashtype = 0;
+    params->mirror = option_params->mirror;
+    params->formatCustomizedType = -1;
+    params->constChromaEn = option_params->constChromaEn;
+    params->constCb = option_params->constCb;
+    params->constCr = option_params->constCr;
+
+    // lossless VC unsupported
+    params->predictMode = 0;
+    params->ptransValue = 0;
+
+    // RC
+    params->rcMode = option_params->rcMode;
+    if (params->rcMode != JPEGENC_SINGLEFRAME) {
+        // rc setting, using ffmpeg common option
+        if (params->partialCoding) {
+            params->frameRateNum = 1;
+            params->frameRateDenom = 1;
+        } else {
+            params->frameRateNum = avctx->framerate.num;
+            params->frameRateDenom = avctx->framerate.den;
+        }
+        params->bitPerSecond = avctx->bit_rate;
+        params->fixedQP = option_params->fixedQP;
+    } else {
+        params->frameRateNum = 1;
+        params->frameRateDenom = 1;
+        params->bitPerSecond = 0;
+        params->fixedQP = -1;
+    }
+    params->qpmin = avctx->qmin;
+    params->qpmax = avctx->qmax;
+    params->picQpDeltaMin = option_params->picQpDeltaMin;
+    params->picQpDeltaMax = option_params->picQpDeltaMax;
+
+    av_log(avctx,
+           AV_LOG_INFO,
+           "rc info: rcMode:%d, bps:%d, qpmin:%d, qpmax:%d, frameRateNum:%d, frameRateDenom:%d, "
+           "picQpDeltaMin:%d, "
+           "picQpDeltaMax:%d, fixedQP:%d \n",
+           params->rcMode,
+           params->bitPerSecond,
+           params->qpmin,
+           params->qpmax,
+           params->frameRateNum,
+           params->frameRateDenom,
+           params->picQpDeltaMin,
+           params->picQpDeltaMax,
+           params->fixedQP);
+
+    params->streamBufChain = 0;
+    params->streamMultiSegmentMode = 0;
+    params->streamMultiSegmentAmount = 4;
+    strcpy(params->dec400CompTableinput, "dec400CompTableinput.bin");
+    params->AXIAlignment = 0;
+    params->irqTypeMask = 0x1f0;
+
+    /*Overlay*/
+    params->overlayEnables = 0;
+    strcpy(params->osdDec400CompTableInput, "osdDec400CompTableinput.bin");
+
+    for (counter = 0; counter < MAX_OVERLAY_NUM; counter++) {
+        strcpy(params->olInput[counter], "olInput.yuv");
+        params->olFormat[counter] = 0;
+        params->olAlpha[counter] = 0;
+        params->olWidth[counter] = 0;
+        params->olHeight[counter] = 0;
+        params->olXoffset[counter] = 0;
+        params->olYoffset[counter] = 0;
+        params->olYStride[counter] = 0;
+        params->olUVStride[counter] = 0;
+        params->olSuperTile[counter] = 0;
+        params->olScaleWidth[counter] = 0;
+        params->olScaleHeight[counter] = 0;
+    }
+
+    params->sramPowerdownDisable = 0;
+    return JPEGENC_OK;
+}
+
+/**Set the codecs params, If some params you want to fix , call es_jenc_get_params first*/
+JpegEncRet es_jenc_set_params(AVCodecContext *avctx, EsJpegEncParams *params) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *destParams = &(jpeg_enc_ctx->jpeg_enc_params);
+
+    av_log(avctx, AV_LOG_INFO, "es_jenc_set_params()\n");
+
+    if (!params) {
+        av_log(avctx, AV_LOG_ERROR, "Params args invalid: Null pointer found.\n");
+        return JPEGENC_INVALID_ARGUMENT;
+    }
+    memcpy(destParams, params, sizeof(EsJpegEncParams));
+    es_jenc_print_params(avctx, destParams);
+    return JPEGENC_OK;
+}
+
+/**Get Current the codecs params, */
+JpegEncRet es_jenc_get_params(AVCodecContext *avctx, EsJpegEncParams *params) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *srcParams = &(jpeg_enc_ctx->jpeg_enc_params);
+
+    av_log(avctx, AV_LOG_INFO, "es_jenc_get_params()\n");
+
+    if (!params) {
+        av_log(avctx, AV_LOG_ERROR, "Params args invalid: Null pointer found.\n");
+        return JPEGENC_INVALID_ARGUMENT;
+    }
+
+    memset(params, 0, sizeof(EsJpegEncParams));
+    memcpy(params, srcParams, sizeof(EsJpegEncParams));
+    return JPEGENC_OK;
+}
+
+static JpegEncRet es_jenc_init_codec(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncCfg *enc_config = &jpeg_enc_ctx->enc_config;
+    JpegEncInst *enc_inst = &jpeg_enc_ctx->enc_inst;
+    JpegEncRet ret_value = JPEGENC_OK;
+
+    av_log(avctx, AV_LOG_INFO, "es_jenc_init_codec\n");
+
+    if ((ret_value = JpegEncInit(enc_config, enc_inst, NULL)) != JPEGENC_OK) {
+        av_log(avctx, AV_LOG_ERROR, "JpegEncInit failed\n");
+    }
+    av_log(avctx, AV_LOG_INFO, "JpegEncInit: ret_value = %d, enc_inst = %p.\n", (int)ret_value, enc_inst);
+
+    return ret_value;
+}
+
+static int es_jenc_realloc_output_buffer(AVCodecContext *avctx, int new_size) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncInst enc_inst = jpeg_enc_ctx->enc_inst;
+    i32 counter = 0;
+    const void *ewl_inst = JpegEncGetEwl(enc_inst);
+
+    EWLFreeLinear(ewl_inst, &jpeg_enc_ctx->outbufMem[0]);
+    memset(jpeg_enc_ctx->outbufMem, 0, sizeof(jpeg_enc_ctx->outbufMem));
+    jpeg_enc_ctx->outbufMem[counter].mem_type = VPU_WR | CPU_WR | CPU_RD | EWL_MEM_TYPE_SLICE;
+    if (EWLMallocLinear(ewl_inst, new_size, 0, &jpeg_enc_ctx->outbufMem[counter]) != EWL_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to allocate output buffer!\n");
+        jpeg_enc_ctx->outbufMem[counter].virtualAddress = NULL;
+        return -1;
+    }
+    av_log(
+        avctx, AV_LOG_INFO, "Output buffer%d size:         %u bytes\n", counter, jpeg_enc_ctx->outbufMem[counter].size);
+    av_log(avctx,
+           AV_LOG_INFO,
+           "Output buffer%d bus address:  %p\n",
+           counter,
+           (void *)jpeg_enc_ctx->outbufMem[counter].busAddress);
+    av_log(avctx,
+           AV_LOG_INFO,
+           "Output buffer%d user address: %10p\n",
+           counter,
+           jpeg_enc_ctx->outbufMem[counter].virtualAddress);
+    return 0;
+}
+
+static JpegEncRet es_jenc_free_codec_res(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncInst enc_inst = jpeg_enc_ctx->enc_inst;
+
+    const void *ewl_inst = JpegEncGetEwl(enc_inst);
+
+    av_log(avctx, AV_LOG_INFO, "es_jenc_free_codec_res()\n");
+
+    EWLFreeLinear(ewl_inst, &jpeg_enc_ctx->outbufMem[0]);
+    EWLFreeLinear(ewl_inst, &jpeg_enc_ctx->roimapMem);
+    EWLFreeLinear(ewl_inst, &jpeg_enc_ctx->input_buf_mem);
+
+    if (jpeg_enc_ctx->thumb_data != NULL) {
+        free(jpeg_enc_ctx->thumb_data);
+        jpeg_enc_ctx->thumb_data = NULL;
+        jpeg_enc_ctx->thumbnail_enable = false;
+    }
+
+    return JPEGENC_OK;
+}
+
+static JpegEncRet es_jenc_alloc_codec_res(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *jpeg_params = &(jpeg_enc_ctx->jpeg_enc_params);
+    JpegEncInst enc_inst = jpeg_enc_ctx->enc_inst;
+    EWLLinearMem_t *pictureMem = &(jpeg_enc_ctx->input_buf_mem);
+
+    i32 sliceRows = 0;
+    u64 pictureSize;
+    u32 streamBufTotalSize;
+
+    i32 counter;
+    u64 lumaSize, chromaSize;
+    u32 input_alignment = (jpeg_params->exp_of_input_alignment == 0 ? 0 : (1 << jpeg_params->exp_of_input_alignment));
+    i32 mcuh = (jpeg_params->codingMode == JPEGENC_422_MODE ? 8 : 16);
+    i32 strmBufNum = jpeg_params->streamBufChain ? 2 : 1;
+    i32 bufSizes[2] = {0, 0};
+    JpegEncRet ret_value;
+
+    const void *ewl_inst = JpegEncGetEwl(jpeg_enc_ctx->enc_inst);
+
+    if (jpeg_params->codingMode == JPEGENC_420_MODE) {
+        jpeg_enc_ctx->mb_width = (jpeg_params->lumWidthSrc + 15) / MB_SIZE_16;
+        jpeg_enc_ctx->mb_height = (jpeg_params->lumHeightSrc + 15) / MB_SIZE_16;
+    } else if (jpeg_params->codingMode == JPEGENC_422_MODE) {
+        jpeg_enc_ctx->mb_width = (jpeg_params->lumWidthSrc + 15) / MB_SIZE_16;
+        jpeg_enc_ctx->mb_height = (jpeg_params->lumHeightSrc + 7) / MB_SIZE_8;
+    } else if (jpeg_params->codingMode == JPEGENC_MONO_MODE) {
+        jpeg_enc_ctx->mb_width = (jpeg_params->lumWidthSrc + 7) / MB_SIZE_8;
+        jpeg_enc_ctx->mb_height = (jpeg_params->lumHeightSrc + 7) / MB_SIZE_8;
+    }
+
+    av_log(avctx, AV_LOG_INFO, "es_jenc_alloc_codec_res\n");
+    /* Set slice size and output buffer size
+     * For output buffer size, 1 byte/pixel is enough for most images.
+     * Some extra is needed for testing purposes (noise input) */
+
+    if (jpeg_params->partialCoding == 0) {
+        if (jpeg_params->frameType == JPEGENC_YUV420_PLANAR_8BIT_TILE_32_32)
+            sliceRows = ((jpeg_params->lumHeightSrc + 32 - 1) & (~(32 - 1)));
+        else if (jpeg_params->frameType == JPEGENC_YUV420_PLANAR_8BIT_TILE_16_16_PACKED_4)
+            sliceRows = ((jpeg_params->lumHeightSrc + mcuh - 1) & (~(mcuh - 1)));
+        else
+            sliceRows = jpeg_params->lumHeightSrc;
+    } else {
+        sliceRows = jpeg_params->restartInterval * mcuh;
+    }
+
+    es_jenc_get_aligned_pic_size_by_format(jpeg_params->frameType,
+                                           jpeg_params->lumWidthSrc,
+                                           sliceRows,
+                                           input_alignment,
+                                           &lumaSize,
+                                           &chromaSize,
+                                           &pictureSize);
+
+    JpegSetLumaSize(enc_inst, lumaSize, 0);
+    JpegSetChromaSize(enc_inst, chromaSize, 0);
+
+    if (jpeg_enc_ctx->compress_rate != 0) {
+        // calculate output buffer size: input_buffer_size / compress_rate
+        streamBufTotalSize = pictureSize / jpeg_enc_ctx->compress_rate;
+    } else {
+        // calculate output buffer size reference testbench
+        streamBufTotalSize = jpeg_params->lumWidthSrc * sliceRows * 2;
+    }
+
+    if (streamBufTotalSize < JPEGENC_STREAM_MIN_BUF0_SIZE) {
+        jpeg_enc_ctx->compress_rate = pictureSize / (JPEGENC_STREAM_MIN_BUF0_SIZE);
+        if (pictureSize % (JPEGENC_STREAM_MIN_BUF0_SIZE)) {
+            jpeg_enc_ctx->compress_rate--;
+            if (jpeg_enc_ctx->compress_rate < 2) jpeg_enc_ctx->compress_rate = 1;
+        }
+        streamBufTotalSize = pictureSize / jpeg_enc_ctx->compress_rate;
+    }
+    av_log(avctx,
+           AV_LOG_INFO,
+           "jenc alloc outbuf size: %d is 1/%d of YUV \n",
+           streamBufTotalSize,
+           jpeg_enc_ctx->compress_rate);
+
+    pictureMem->virtualAddress = NULL;
+    /* Here we use the EWL instance directly from the encoder
+     * because it is the easiest way to allocate the linear memories */
+    pictureMem->mem_type = EXT_WR | VPU_RD | EWL_MEM_TYPE_DPB;
+    if (EWLMallocLinear(ewl_inst, pictureSize, 0, pictureMem) != EWL_OK) {
+        fprintf(stderr, "Failed to allocate input picture!\n");
+        pictureMem->virtualAddress = NULL;
+        return JPEGENC_ERROR;
+    }
+    av_log(avctx, AV_LOG_INFO, "Input buffer size:         %u bytes\n", pictureMem->size);
+    av_log(avctx, AV_LOG_INFO, "Input buffer bus address:  %p\n", (void *)pictureMem->busAddress);
+    av_log(avctx, AV_LOG_INFO, "Input bufferuser address: %10p\n", pictureMem->virtualAddress);
+
+    if (strmBufNum == 1) {
+        bufSizes[0] = (jpeg_params->streamMultiSegmentMode != 0 ? streamBufTotalSize / 128 : streamBufTotalSize);
+    } else {
+        /* set small stream buffer0 to test two stream buffers */
+        // stream buffer chain in win2030 is unsupported.
+        bufSizes[0] = streamBufTotalSize / 100;
+        bufSizes[1] = streamBufTotalSize - bufSizes[0];
+    }
+    av_log(avctx, AV_LOG_DEBUG, "dbg: real output buf size : bufSizes[0] : %d \n", bufSizes[0]);
+
+    memset(jpeg_enc_ctx->outbufMem, 0, sizeof(jpeg_enc_ctx->outbufMem));
+    for (counter = 0; counter < strmBufNum; counter++) {
+        u32 size = bufSizes[counter];
+
+        /* For FPGA testing, smaller size maybe specified. */
+        /* Max output buffer size is less than 256MB */
+        // comment out outbufSize hard limitation for 16K*16K testing
+        // size = size < (1024*1024*64) ? size : (1024*1024*64);
+
+        jpeg_enc_ctx->outbufMem[counter].mem_type = VPU_WR | CPU_WR | CPU_RD | EWL_MEM_TYPE_SLICE;
+        if (EWLMallocLinear(ewl_inst, size, 0, &jpeg_enc_ctx->outbufMem[counter]) != EWL_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to allocate output buffer!\n");
+            jpeg_enc_ctx->outbufMem[counter].virtualAddress = NULL;
+            return JPEGENC_ERROR;
+        }
+    }
+    // RoiMap assume jpeg_params->width/height % 16 == 0
+    // alloc roimapMem
+    if (jpeg_enc_ctx->roi_enable) {
+        ret_value = es_jenc_alloc_roi_res(avctx);
+        jpeg_enc_ctx->roi_buffer_alloced = TRUE;
+        if (ret_value != 0) {
+            return ret_value;
+        }
+    }
+
+    /*Overlay input buffer*/
+    // TODO: now overlay inputbuffer is unused.
+    // TODO: dec400 buffer is unused
+    // TODO: osdDec400 buffer is unused
+#ifndef ASIC_WAVE_TRACE_TRIGGER
+    if (jpeg_enc_ctx->thumbnail_enable) {
+        av_log(avctx,
+               AV_LOG_INFO,
+               "Input pic[%dx%d] encoding at thumb[%dx%d] + pic[%dx%d] ",
+               jpeg_params->lumWidthSrc,
+               jpeg_params->lumHeightSrc,
+               jpeg_params->widthThumb,
+               jpeg_params->heightThumb,
+               jpeg_params->width,
+               jpeg_params->height);
+    } else {
+        av_log(avctx,
+               AV_LOG_INFO,
+               "Input pic [%dx%d] encoding at [%dx%d]",
+               jpeg_params->lumWidthSrc,
+               jpeg_params->lumHeightSrc,
+               jpeg_params->width,
+               jpeg_params->height);
+    }
+
+    if (jpeg_params->partialCoding != 0)
+        av_log(avctx, AV_LOG_INFO, "in slices of %dx%d", jpeg_params->width, sliceRows);
+    av_log(avctx, AV_LOG_INFO, "\n");
+#endif
+
+#ifndef ASIC_WAVE_TRACE_TRIGGER
+    for (counter = 0; counter < strmBufNum; counter++) {
+        av_log(avctx,
+               AV_LOG_INFO,
+               "Output buffer%d size:         %u bytes\n",
+               counter,
+               jpeg_enc_ctx->outbufMem[counter].size);
+        av_log(avctx,
+               AV_LOG_INFO,
+               "Output buffer%d bus address:  %p\n",
+               counter,
+               (void *)jpeg_enc_ctx->outbufMem[counter].busAddress);
+        av_log(avctx,
+               AV_LOG_INFO,
+               "Output buffer%d user address: %10p\n",
+               counter,
+               jpeg_enc_ctx->outbufMem[counter].virtualAddress);
+    }
+#endif
+    return JPEGENC_OK;
+}
+
+static JpegEncRet es_jenc_alloc_roi_res(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *jpeg_params = &(jpeg_enc_ctx->jpeg_enc_params);
+
+    u32 RoiSize = 0;
+    u32 ImageWidthMB = jpeg_enc_ctx->mb_width;
+    u32 ImageHeightMB = jpeg_enc_ctx->mb_height;
+    u32 sliceRowsMb = 0;
+    u32 RoiSizePerSlice = 0;
+
+    const void *ewl_inst = JpegEncGetEwl(jpeg_enc_ctx->enc_inst);
+
+    if (jpeg_params->partialCoding == JPEGENC_WHOLE_FRAME) {
+        RoiSize = (ImageWidthMB * ImageHeightMB + 7) / MB_SIZE_8;
+        sliceRowsMb = ImageHeightMB;
+    } else {
+        if (jpeg_params->codingMode == JPEGENC_420_MODE) {
+            sliceRowsMb = jpeg_params->restartInterval;
+        } else {
+            sliceRowsMb = jpeg_params->restartInterval * 2;
+        }
+        RoiSizePerSlice = ((sliceRowsMb * ImageWidthMB + 7) / MB_SIZE_8 + 15) & (~15);
+        RoiSize = RoiSizePerSlice * ((ImageHeightMB + sliceRowsMb - 1) / sliceRowsMb);
+    }
+
+    jpeg_enc_ctx->roimapMem.mem_type = EXT_WR | VPU_RD | EWL_MEM_TYPE_VPU_WORKING;
+    if (EWLMallocLinear(ewl_inst, RoiSize, 0, &jpeg_enc_ctx->roimapMem) != EWL_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to allocate RoiMap Memory!\n");
+        jpeg_enc_ctx->roimapMem.virtualAddress = NULL;
+        return JPEGENC_MEMORY_ERROR;
+    }
+    memset(jpeg_enc_ctx->roimapMem.virtualAddress, 0, RoiSize);
+    jpeg_enc_ctx->roi_memory_size = RoiSize;
+    av_log(avctx, AV_LOG_INFO, "roi buffer size:         %u bytes\n", jpeg_enc_ctx->roimapMem.size);
+    av_log(avctx, AV_LOG_INFO, "roi bufferbus address:  %p\n", (void *)jpeg_enc_ctx->roimapMem.busAddress);
+    av_log(avctx, AV_LOG_INFO, "roi buffer user address: %10p\n", jpeg_enc_ctx->roimapMem.virtualAddress);
+    return JPEGENC_OK;
+}
+
+static int dynamic_read_roimap(AVCodecContext *avctx, const AVFrame *frame) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *jpeg_params = &(jpeg_enc_ctx->jpeg_enc_params);
+
+    // roi rect val
+    i32 RoiRectNum = 0;
+    u32 RoiRectLeft[30];
+    u32 RoiRectTop[30];
+    u32 RoiRectWidth[30];
+    u32 RoiRectHeight[30];
+
+    int ImageWidthMB = jpeg_enc_ctx->mb_width;
+    int ImageHeightMB = jpeg_enc_ctx->mb_height;
+    u32 sliceRowsMb = 0;
+
+    u8 *roimap_virtualAddr = NULL;
+    u32 bitNum = 0;
+    u32 MbNumPerSlice = 0;
+    u8 roiValTmp = 0;
+    u8 RoiRegion_SetVal[8] = {0};
+    int ret = 0;
+    int nb_rois = 0;
+    SideDataRoiArea *roi_area = NULL;
+
+    AVFrameSideData *sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_JENC_ROI_AREA);
+    if (sd) {
+        roi_area = (SideDataRoiArea *)sd->data;
+        nb_rois = sd->size / sizeof(SideDataRoiArea);
+        if (!nb_rois || sd->size % sizeof(SideDataRoiArea) != 0) {
+            av_log(avctx, AV_LOG_ERROR, "Invalid AVRegionOfInterest. self_size.\n");
+            return AVERROR(EINVAL);
+        }
+    }
+
+    if (jpeg_params->partialCoding == JPEGENC_WHOLE_FRAME) {
+        sliceRowsMb = ImageHeightMB;
+    } else {
+        if (jpeg_params->codingMode == JPEGENC_420_MODE) {
+            sliceRowsMb = jpeg_params->restartInterval;
+        } else {
+            sliceRowsMb = jpeg_params->restartInterval * 2;
+        }
+    }
+
+    // This list must be iterated in reverse because the first
+    // region in the list applies when regions overlap.
+    for (int i = nb_rois - 1; i >= 0; i--) {
+        if ((roi_area->width + roi_area->x) > jpeg_params->lumWidthSrc
+            || (roi_area->height + roi_area->y) > jpeg_params->lumHeightSrc) {
+            av_log(avctx,
+                   AV_LOG_ERROR,
+                   "(%d, %d, %d, %d) (%d, %d): Error, The Roi Region Coordinate Input Is Out Of Picture Range!\n",
+                   roi_area->x,
+                   roi_area->y,
+                   roi_area->width,
+                   roi_area->height,
+                   jpeg_params->lumWidthSrc,
+                   jpeg_params->lumHeightSrc);
+
+            return -1;
+        }
+
+        roi_area = (SideDataRoiArea *)(sd->data + sizeof(SideDataRoiArea) * i);
+        if (jpeg_params->codingMode == JPEGENC_420_MODE) {
+            RoiRectLeft[RoiRectNum] = roi_area->x / MB_SIZE_16;
+            RoiRectTop[RoiRectNum] = roi_area->y / MB_SIZE_16;
+            RoiRectWidth[RoiRectNum] = (roi_area->width + 15) / MB_SIZE_16;
+            RoiRectHeight[RoiRectNum] = (roi_area->height + 15) / MB_SIZE_16;
+        } else if (jpeg_params->codingMode == JPEGENC_422_MODE) {
+            RoiRectLeft[RoiRectNum] = roi_area->x / MB_SIZE_16;
+            RoiRectTop[RoiRectNum] = roi_area->y / MB_SIZE_8;
+            RoiRectWidth[RoiRectNum] = (roi_area->width + 15) / MB_SIZE_16;
+            RoiRectHeight[RoiRectNum] = (roi_area->height + 7) / MB_SIZE_8;
+        } else if (jpeg_params->codingMode == JPEGENC_MONO_MODE) {
+            RoiRectLeft[RoiRectNum] = roi_area->x / MB_SIZE_8;
+            RoiRectTop[RoiRectNum] = roi_area->y / MB_SIZE_8;
+            RoiRectWidth[RoiRectNum] = (roi_area->width + 7) / MB_SIZE_8;
+            RoiRectHeight[RoiRectNum] = (roi_area->height + 7) / MB_SIZE_8;
+        }
+
+        av_log(avctx,
+               AV_LOG_INFO,
+               "Rect%d: left:%d, top:%d, width:%d, heigh:%d\n",
+               RoiRectNum,
+               roi_area->x,
+               roi_area->y,
+               roi_area->width,
+               roi_area->height);
+        RoiRectNum++;
+        // for (int y = starty; y < endy; y++) {
+        //     for (int x = startx; x < endx; x++) {
+        //         qoffsets[x + y * mbx] = qoffset;
+        //     }
+        // }
+    }
+    goto write_roi_bitmap;
+
+write_roi_bitmap:
+    memset(jpeg_enc_ctx->roimapMem.virtualAddress, 0, jpeg_enc_ctx->roi_memory_size);
+    // ROI bitmap need 1
+    // roimap_virtualAddr = (u8 *)roimapMem.virtualAddress;
+    roimap_virtualAddr = (u8 *)(jpeg_enc_ctx->roimapMem.virtualAddress);
+    for (int roinum = 0; roinum < RoiRectNum; roinum++) {
+        roimap_virtualAddr = (u8 *)(jpeg_enc_ctx->roimapMem.virtualAddress);
+        for (int rows = 0; rows < ImageHeightMB; rows++) {
+            for (int cals = 0; cals < ImageWidthMB; cals++) {
+                if ((rows >= RoiRectTop[roinum] && rows < (RoiRectTop[roinum] + RoiRectHeight[roinum]))
+                    && cals >= RoiRectLeft[roinum] && cals < (RoiRectLeft[roinum] + RoiRectWidth[roinum]))  // ROI
+                {
+                    RoiRegion_SetVal[bitNum] = 1;
+                } else {
+                    RoiRegion_SetVal[bitNum] = 0;
+                }
+                bitNum++;
+                if (bitNum == 8 || (rows == ImageHeightMB - 1 && cals == ImageWidthMB - 1)
+                    || (MbNumPerSlice == sliceRowsMb * ImageWidthMB - 1)) {
+                    roiValTmp = RoiRegion_SetVal[0] * 128 + RoiRegion_SetVal[1] * 64 + RoiRegion_SetVal[2] * 32
+                                + RoiRegion_SetVal[3] * 16 + RoiRegion_SetVal[4] * 8 + RoiRegion_SetVal[5] * 4
+                                + RoiRegion_SetVal[6] * 2 + RoiRegion_SetVal[7] * 1;
+                    *roimap_virtualAddr = *roimap_virtualAddr | roiValTmp;
+                    roimap_virtualAddr++;
+                    if ((MbNumPerSlice == sliceRowsMb * ImageWidthMB - 1) && jpeg_params->partialCoding == 1) {
+                        roimap_virtualAddr = (u8 *)(((ptr_t)roimap_virtualAddr + 15) & (~15));
+                    }
+                    roiValTmp = 0;
+                    bitNum = 0;
+                    memset(RoiRegion_SetVal, 0, sizeof(RoiRegion_SetVal));
+                }
+                MbNumPerSlice++;
+                if (MbNumPerSlice == sliceRowsMb * ImageWidthMB
+                    || (rows == ImageHeightMB - 1 && cals == ImageWidthMB - 1)) {
+                    MbNumPerSlice = 0;
+                }
+            }
+        }
+    }
+
+    ret = EWLSyncMemData(&jpeg_enc_ctx->roimapMem, 0, jpeg_enc_ctx->roi_memory_size, HOST_TO_DEVICE);
+    if (ret != 0) {
+        av_log(avctx, AV_LOG_ERROR, "SyncMemData failed\n");
+        return ret;
+    }
+
+    return ret;
+}
+
+static int read_roimap(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *jpeg_params = &(jpeg_enc_ctx->jpeg_enc_params);
+    // roi rect val
+    i32 RoiRectNum = 0;
+    u32 RoiRectLeft[30];
+    u32 RoiRectTop[30];
+    u32 RoiRectWidth[30];
+    u32 RoiRectHeight[30];
+
+    int ImageWidthMB = jpeg_enc_ctx->mb_width;
+    int ImageHeightMB = jpeg_enc_ctx->mb_height;
+    u32 sliceRowsMb = 0;
+
+    u8 *roimap_virtualAddr = NULL;
+    u32 bitNum = 0;
+    u32 MbNumPerSlice = 0;
+    u8 roiValTmp = 0;
+    u8 RoiRegion_SetVal[8] = {0};
+    int ret = 0;
+
+    if (jpeg_params->partialCoding == JPEGENC_WHOLE_FRAME) {
+        sliceRowsMb = ImageHeightMB;
+    } else {
+        if (jpeg_params->codingMode == JPEGENC_420_MODE) {
+            sliceRowsMb = jpeg_params->restartInterval;
+        } else {
+            sliceRowsMb = jpeg_params->restartInterval * 2;
+        }
+    }
+    // read roi map from file:
+    if (jpeg_params->roimapFile != NULL) {
+        char buf[30];
+        FILE *fpROI = fopen(jpeg_params->roimapFile, "r");
+        if (!fpROI) {
+            av_log(avctx, AV_LOG_ERROR, "jpeg_map.roi, Can Not Open File %s\n", jpeg_params->roimapFile);
+            return -1;
+        }
+
+        av_log(avctx, AV_LOG_INFO, "read roi map from file:%s \n", jpeg_params->roimapFile);
+
+        while (fgets(buf, 30, fpROI) != NULL) {
+            if (buf[0] == 'r') {
+                sscanf(buf,
+                       "roi=(%d,%d,%d,%d)",
+                       &RoiRectLeft[RoiRectNum],
+                       &RoiRectTop[RoiRectNum],
+                       &RoiRectWidth[RoiRectNum],
+                       &RoiRectHeight[RoiRectNum]);
+                if (RoiRectLeft[RoiRectNum] + RoiRectWidth[RoiRectNum] > jpeg_params->lumWidthSrc
+                    || RoiRectTop[RoiRectNum] + RoiRectHeight[RoiRectNum] > jpeg_params->height) {
+                    printf("jpeg_map.roi: Error, The Roi Region Coordinate Input Is Out Of Picture Range!\n");
+                    return -1;
+                }
+                av_log(avctx,
+                       AV_LOG_INFO,
+                       "Rect%d: left:%d, top:%d, width:%d, heigh:%d\n",
+                       RoiRectNum,
+                       RoiRectLeft[RoiRectNum],
+                       RoiRectTop[RoiRectNum],
+                       RoiRectWidth[RoiRectNum],
+                       RoiRectHeight[RoiRectNum]);
+                if (jpeg_params->codingMode == JPEGENC_420_MODE) {
+                    RoiRectLeft[RoiRectNum] = RoiRectLeft[RoiRectNum] / MB_SIZE_16;
+                    RoiRectTop[RoiRectNum] = RoiRectTop[RoiRectNum] / MB_SIZE_16;
+                    RoiRectWidth[RoiRectNum] = (RoiRectWidth[RoiRectNum] + 15) / MB_SIZE_16;
+                    RoiRectHeight[RoiRectNum] = (RoiRectHeight[RoiRectNum] + 15) / MB_SIZE_16;
+                } else if (jpeg_params->codingMode == JPEGENC_422_MODE) {
+                    RoiRectLeft[RoiRectNum] = RoiRectLeft[RoiRectNum] / MB_SIZE_16;
+                    RoiRectTop[RoiRectNum] = RoiRectTop[RoiRectNum] / MB_SIZE_8;
+                    RoiRectWidth[RoiRectNum] = (RoiRectWidth[RoiRectNum] + 15) / MB_SIZE_16;
+                    RoiRectHeight[RoiRectNum] = (RoiRectHeight[RoiRectNum] + 7) / MB_SIZE_8;
+                } else if (jpeg_params->codingMode == JPEGENC_MONO_MODE) {
+                    RoiRectLeft[RoiRectNum] = RoiRectLeft[RoiRectNum] / MB_SIZE_8;
+                    RoiRectTop[RoiRectNum] = RoiRectTop[RoiRectNum] / MB_SIZE_8;
+                    RoiRectWidth[RoiRectNum] = (RoiRectWidth[RoiRectNum] + 7) / MB_SIZE_8;
+                    RoiRectHeight[RoiRectNum] = (RoiRectHeight[RoiRectNum] + 7) / MB_SIZE_8;
+                }
+
+                RoiRectNum++;
+            }
+        }
+        fclose(fpROI);
+        goto write_roi_bitmap;
+    }
+
+write_roi_bitmap:
+    memset(jpeg_enc_ctx->roimapMem.virtualAddress, 0, jpeg_enc_ctx->roi_memory_size);
+    // ROI bitmap need 1
+    // roimap_virtualAddr = (u8 *)roimapMem.virtualAddress;
+    roimap_virtualAddr = (u8 *)(jpeg_enc_ctx->roimapMem.virtualAddress);
+    for (int roinum = 0; roinum < RoiRectNum; roinum++) {
+        roimap_virtualAddr = (u8 *)(jpeg_enc_ctx->roimapMem.virtualAddress);
+        for (int rows = 0; rows < ImageHeightMB; rows++) {
+            for (int cals = 0; cals < ImageWidthMB; cals++) {
+                if ((rows >= RoiRectTop[roinum] && rows < (RoiRectTop[roinum] + RoiRectHeight[roinum]))
+                    && cals >= RoiRectLeft[roinum] && cals < (RoiRectLeft[roinum] + RoiRectWidth[roinum]))  // ROI
+                {
+                    RoiRegion_SetVal[bitNum] = 1;
+                } else {
+                    RoiRegion_SetVal[bitNum] = 0;
+                }
+                bitNum++;
+                if (bitNum == 8 || (rows == ImageHeightMB - 1 && cals == ImageWidthMB - 1)
+                    || (MbNumPerSlice == sliceRowsMb * ImageWidthMB - 1)) {
+                    roiValTmp = RoiRegion_SetVal[0] * 128 + RoiRegion_SetVal[1] * 64 + RoiRegion_SetVal[2] * 32
+                                + RoiRegion_SetVal[3] * 16 + RoiRegion_SetVal[4] * 8 + RoiRegion_SetVal[5] * 4
+                                + RoiRegion_SetVal[6] * 2 + RoiRegion_SetVal[7] * 1;
+                    *roimap_virtualAddr = *roimap_virtualAddr | roiValTmp;
+                    roimap_virtualAddr++;
+                    if ((MbNumPerSlice == sliceRowsMb * ImageWidthMB - 1) && jpeg_params->partialCoding == 1) {
+                        roimap_virtualAddr = (u8 *)(((ptr_t)roimap_virtualAddr + 15) & (~15));
+                    }
+                    roiValTmp = 0;
+                    bitNum = 0;
+                    memset(RoiRegion_SetVal, 0, sizeof(RoiRegion_SetVal));
+                }
+                MbNumPerSlice++;
+                if (MbNumPerSlice == sliceRowsMb * ImageWidthMB
+                    || (rows == ImageHeightMB - 1 && cals == ImageWidthMB - 1)) {
+                    MbNumPerSlice = 0;
+                }
+            }
+        }
+    }
+
+    ret = EWLSyncMemData(&jpeg_enc_ctx->roimapMem, 0, jpeg_enc_ctx->roi_memory_size, HOST_TO_DEVICE);
+    if (ret != 0) {
+        av_log(avctx, AV_LOG_ERROR, "SyncMemData failed\n");
+        return ret;
+    }
+
+    return ret;
+}
+
+static int dynamic_read_non_roi_filter(AVCodecContext *avctx, SideDataJencNonRoiFilter *sd_non_roi_filter) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncCfg *enc_config = &jpeg_enc_ctx->enc_config;
+
+    if (sd_non_roi_filter->non_roi_qp_level == 10) {
+        av_log(avctx, AV_LOG_INFO, "Use user qp map\n");
+        for (int i = 0; i < 128; i++) {
+            enc_config->filter[i] = sd_non_roi_filter->non_roi_filter_map[i];
+        }
+    } else if (sd_non_roi_filter->non_roi_qp_level <= 9) {
+        for (int j = 0; j < 64; j++) {
+            enc_config->filter[j] = NonRoiFilterLuminance[sd_non_roi_filter->non_roi_qp_level][j];
+            enc_config->filter[j + 64] = NonRoiFilterChrominance[sd_non_roi_filter->non_roi_qp_level][j];
+        }
+    } else {
+        av_log(avctx, AV_LOG_INFO, "non roi fliter not set\n");
+        return 1;
+    }
+
+    // print fliter:
+    av_log(avctx, AV_LOG_INFO, "non_roi_qp_level:%d  print non ROI fliter: \n ", sd_non_roi_filter->non_roi_qp_level);
+    av_log(NULL,
+           AV_LOG_INFO,
+           "luma: %d %d %d %d %d %d %d %d",
+           enc_config->filter[0],
+           enc_config->filter[1],
+           enc_config->filter[2],
+           enc_config->filter[3],
+           enc_config->filter[4],
+           enc_config->filter[5],
+           enc_config->filter[6],
+           enc_config->filter[7]);
+    av_log(NULL,
+           AV_LOG_INFO,
+           "chroma: %d %d %d %d %d %d %d %d",
+           enc_config->filter[64],
+           enc_config->filter[65],
+           enc_config->filter[66],
+           enc_config->filter[67],
+           enc_config->filter[68],
+           enc_config->filter[69],
+           enc_config->filter[70],
+           enc_config->filter[71]);
+    // num = 0;
+    // while (num < 128) {
+    //     for (int i = 0; i < 8; i++) {
+    //         av_log(NULL, AV_LOG_INFO, "%d ", enc_config->filter[num]);
+    //         num++;
+    //     }
+    //     av_log(NULL, AV_LOG_INFO, "\n ");
+    // }
+
+    return 0;
+}
+
+static int read_non_roi_fliter(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *jpeg_params = &(jpeg_enc_ctx->jpeg_enc_params);
+    JpegEncCfg *enc_config = &jpeg_enc_ctx->enc_config;
+
+    FILE *fpFilter;
+    char buf[32];
+    int val[8];
+    int num = 0;
+
+    av_log(avctx,
+           AV_LOG_DEBUG,
+           "roimapFile = %s, nonRoiFilter = %s,nonRoiLevel = %d \n",
+           jpeg_params->roimapFile,
+           jpeg_params->nonRoiFilter,
+           jpeg_params->nonRoiLevel);
+
+    if (jpeg_params->nonRoiFilter) {
+        fpFilter = fopen(jpeg_params->nonRoiFilter, "r");
+        if (fpFilter == NULL) {
+            av_log(avctx, AV_LOG_ERROR, "filter.txt: Error, Can Not Open File %s\n", jpeg_params->nonRoiFilter);
+            return -1;
+        }
+        while (fgets(buf, 32, fpFilter) != NULL) {
+            if (buf[0] == '#' || buf[0] == '\r' || buf[0] == '\n') {
+                continue;
+            }
+            sscanf(
+                buf, "%d %d %d %d %d %d %d %d", &val[0], &val[1], &val[2], &val[3], &val[4], &val[5], &val[6], &val[7]);
+            for (int i = 0; i < 8; i++) {
+                enc_config->filter[num] = (u8)val[i];
+                num++;
+            }
+        }
+        fclose(fpFilter);
+    } else if (jpeg_params->nonRoiLevel >= 0 && jpeg_params->nonRoiLevel <= 9) {
+        for (int j = 0; j < 64; j++) {
+            enc_config->filter[j] = NonRoiFilterLuminance[jpeg_params->nonRoiLevel][j];
+            enc_config->filter[j + 64] = NonRoiFilterChrominance[jpeg_params->nonRoiLevel][j];
+        }
+    } else {
+        av_log(avctx, AV_LOG_INFO, "non roi fliter not set\n");
+        return 1;
+    }
+
+    // print fliter:
+    av_log(avctx, AV_LOG_INFO, " print non ROI fliter: \n ");
+    av_log(NULL,
+           AV_LOG_INFO,
+           "luma: %d %d %d %d %d %d %d %d",
+           enc_config->filter[0],
+           enc_config->filter[1],
+           enc_config->filter[2],
+           enc_config->filter[3],
+           enc_config->filter[4],
+           enc_config->filter[5],
+           enc_config->filter[6],
+           enc_config->filter[7]);
+    av_log(NULL,
+           AV_LOG_INFO,
+           "chroma: %d %d %d %d %d %d %d %d",
+           enc_config->filter[64],
+           enc_config->filter[65],
+           enc_config->filter[66],
+           enc_config->filter[67],
+           enc_config->filter[68],
+           enc_config->filter[69],
+           enc_config->filter[70],
+           enc_config->filter[71]);
+
+    // num = 0;
+    // while (num < 128) {
+    //     for (int i = 0; i < 8; i++) {
+    //         av_log(NULL, AV_LOG_INFO, "%d ", enc_config->filter[num]);
+    //         num++;
+    //     }
+    //     av_log(NULL, AV_LOG_INFO, "\n ");
+    // }
+
+    return 0;
+}
+
+void es_jenc_get_aligned_pic_size_by_format(
+    JpegEncFrameType type, u32 width, u32 height, u32 alignment, u64 *luma_size, u64 *chroma_size, u64 *picture_size) {
+    u32 luma_stride = 0, chroma_stride = 0;
+    u64 lumaSize = 0, chromaSize = 0, pictureSize = 0;
+
+    JpegEncGetAlignedStride(width, type, &luma_stride, &chroma_stride, alignment);
+    switch (type) {
+        case JPEGENC_YUV420_PLANAR:
+        case JPEGENC_YVU420_PLANAR:
+            lumaSize = (u64)luma_stride * height;
+            chromaSize = (u64)chroma_stride * height / 2 * 2;
+            break;
+        case JPEGENC_YUV420_SEMIPLANAR:
+        case JPEGENC_YUV420_SEMIPLANAR_VU:
+            lumaSize = (u64)luma_stride * height;
+            chromaSize = (u64)chroma_stride * height / 2;
+            break;
+        case JPEGENC_YUV422_INTERLEAVED_YUYV:
+        case JPEGENC_YUV422_INTERLEAVED_UYVY:
+        case JPEGENC_RGB565:
+        case JPEGENC_BGR565:
+        case JPEGENC_RGB555:
+        case JPEGENC_BGR555:
+        case JPEGENC_RGB444:
+        case JPEGENC_BGR444:
+        case JPEGENC_RGB888:
+        case JPEGENC_BGR888:
+        case JPEGENC_RGB101010:
+        case JPEGENC_BGR101010:
+            lumaSize = (u64)luma_stride * height;
+            chromaSize = 0;
+            break;
+        case JPEGENC_YUV420_I010:
+            lumaSize = (u64)luma_stride * height;
+            chromaSize = (u64)chroma_stride * height / 2 * 2;
+            break;
+        case JPEGENC_YUV420_MS_P010:
+            lumaSize = (u64)luma_stride * height;
+            chromaSize = (u64)chroma_stride * height / 2;
+            break;
+        case JPEGENC_YUV420_PLANAR_8BIT_TILE_32_32:
+            lumaSize = (u64)luma_stride * height;
+            chromaSize = (u64)lumaSize / 2;
+            break;
+        case JPEGENC_YUV420_PLANAR_8BIT_TILE_16_16_PACKED_4:
+            lumaSize = (u64)luma_stride * height * 2 * 12 / 8;
+            chromaSize = 0;
+            break;
+        case JPEGENC_YUV420_SEMIPLANAR_8BIT_TILE_4_4:
+        case JPEGENC_YUV420_SEMIPLANAR_VU_8BIT_TILE_4_4:
+        case JPEGENC_YUV420_PLANAR_10BIT_P010_TILE_4_4:
+            lumaSize = (u64)luma_stride * ((height + 3) / 4);
+            chromaSize = (u64)chroma_stride * (((height / 2) + 3) / 4);
+            break;
+        case JPEGENC_YUV420_SEMIPLANAR_101010:
+            lumaSize = luma_stride * height;
+            chromaSize = chroma_stride * height / 2;
+            break;
+        case JPEGENC_YUV422_888:
+            lumaSize = (u64)luma_stride * height;
+            chromaSize = (u64)chroma_stride * height;
+            break;
+        case JPEGENC_YUV420_8BIT_TILE_8_8:
+            lumaSize = (u64)luma_stride * ((height + 7) / 8);
+            chromaSize = (u64)chroma_stride * (((height / 2) + 3) / 4);
+            break;
+        case JPEGENC_YUV420_10BIT_TILE_8_8:
+            lumaSize = (u64)luma_stride * ((height + 7) / 8);
+            chromaSize = (u64)chroma_stride * (((height / 2) + 3) / 4);
+            break;
+        case JPEGENC_YUV420_FBC64:
+        case JPEGENC_YUV420_UV_8BIT_TILE_128_2:
+        case JPEGENC_YUV420_UV_10BIT_TILE_128_2:
+            lumaSize = luma_stride * ((height + 1) / 2);
+            chromaSize = chroma_stride * (((height / 2) + 1) / 2);
+            break;
+        default:
+            av_log(NULL, AV_LOG_INFO, "not support this format\n");
+            chromaSize = lumaSize = 0;
+            break;
+    }
+
+    pictureSize = lumaSize + chromaSize;
+    if (luma_size != NULL) *luma_size = lumaSize;
+    if (chroma_size != NULL) *chroma_size = chromaSize;
+    if (picture_size != NULL) *picture_size = pictureSize;
+}
+
+static JpegEncRet es_jenc_config_codec(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *jpeg_params = &(jpeg_enc_ctx->jpeg_enc_params);
+    JpegEncCfg *jpeg_config = &(jpeg_enc_ctx->enc_config);
+    int counter;
+
+    memset(jpeg_config, 0, sizeof(JpegEncCfg));
+
+    jpeg_config->enableRoimap = jpeg_enc_ctx->roi_enable;
+
+    /* lossless mode */
+    jpeg_config->losslessEn = 0;
+    jpeg_config->predictMode = jpeg_params->predictMode;
+    jpeg_config->ptransValue = jpeg_params->ptransValue;
+
+    jpeg_config->inputWidth = (jpeg_params->lumWidthSrc + 15) & (~15); /* API limitation */
+    if (jpeg_config->inputWidth != (u32)jpeg_params->lumWidthSrc) {
+        av_log(avctx, AV_LOG_WARNING, "Warning: Input width must be multiple of 16!\n");
+    }
+    jpeg_config->inputWidth = jpeg_params->lumWidthSrc;
+    jpeg_config->inputHeight = jpeg_params->lumHeightSrc;
+
+    jpeg_config->xOffset = jpeg_params->horOffsetSrc;
+    jpeg_config->yOffset = jpeg_params->verOffsetSrc;
+
+    switch (jpeg_params->rotation) {
+        case 90:
+            jpeg_config->rotation = JPEGENC_ROTATE_90R;
+            break;
+        case 180:
+            jpeg_config->rotation = JPEGENC_ROTATE_180;
+            break;
+        case 270:
+            jpeg_config->rotation = JPEGENC_ROTATE_90L;
+            break;
+        case 0:
+        default:
+            jpeg_config->rotation = JPEGENC_ROTATE_0;
+            break;
+    }
+    if ((jpeg_config->rotation != JPEGENC_ROTATE_0) && (jpeg_config->rotation != JPEGENC_ROTATE_180)) {
+        /* full */
+        jpeg_config->codingWidth = jpeg_params->height;
+        jpeg_config->codingHeight = jpeg_params->width;
+        jpeg_config->xDensity = jpeg_params->ydensity;
+        jpeg_config->yDensity = jpeg_params->xdensity;
+    } else {
+        /* full */
+        jpeg_config->codingWidth = jpeg_params->width;
+        jpeg_config->codingHeight = jpeg_params->height;
+        jpeg_config->xDensity = jpeg_params->xdensity;
+        jpeg_config->yDensity = jpeg_params->ydensity;
+    }
+
+    if (jpeg_params->partialCoding && (jpeg_config->rotation != JPEGENC_ROTATE_0)) {
+        av_log(avctx, AV_LOG_ERROR, "slice mode(partial coding) not support rotation\n");
+        return JPEGENC_INVALID_ARGUMENT;
+    }
+
+    jpeg_config->mirror = jpeg_params->mirror;
+
+    if (jpeg_params->qLevel == USER_DEFINED_QTABLE) {
+        jpeg_config->qTableLuma = jpeg_enc_ctx->qtable_luma;      // qTableLuma;
+        jpeg_config->qTableChroma = jpeg_enc_ctx->qtable_chroma;  // qTableChroma;
+    } else {
+        jpeg_config->qLevel = jpeg_params->qLevel;
+    }
+
+    jpeg_config->restartInterval = jpeg_params->restartInterval;
+    jpeg_config->codingType = (JpegEncCodingType)jpeg_params->partialCoding;
+    jpeg_config->frameType = (JpegEncFrameType)jpeg_params->frameType;
+    jpeg_config->unitsType = (JpegEncAppUnitsType)jpeg_params->unitsType;
+    jpeg_config->markerType = (JpegEncTableMarkerType)jpeg_params->markerType;
+    jpeg_config->colorConversion.type = (JpegEncColorConversionType)jpeg_params->colorConversion;
+    if (jpeg_config->colorConversion.type == JPEGENC_RGBTOYUV_USER_DEFINED) {
+        /* User defined RGB to YCbCr conversion coefficients, scaled by 16-bits */
+        jpeg_config->colorConversion.coeffA = 20000;
+        jpeg_config->colorConversion.coeffB = 44000;
+        jpeg_config->colorConversion.coeffC = 5000;
+        jpeg_config->colorConversion.coeffE = 35000;
+        jpeg_config->colorConversion.coeffF = 38000;
+        jpeg_config->colorConversion.coeffG = 35000;
+        jpeg_config->colorConversion.coeffH = 38000;
+        jpeg_config->colorConversion.LumaOffset = 0;
+    }
+    jpeg_config->codingMode = (JpegEncCodingMode)jpeg_params->codingMode;
+
+    /* low latency */
+    jpeg_config->inputLineBufEn = (jpeg_params->inputLineBufMode > 0) ? 1 : 0;
+    jpeg_config->inputLineBufLoopBackEn =
+        (jpeg_params->inputLineBufMode == 1 || jpeg_params->inputLineBufMode == 2) ? 1 : 0;
+    jpeg_config->inputLineBufDepth = jpeg_params->inputLineBufDepth;
+    jpeg_config->amountPerLoopBack = jpeg_params->amountPerLoopBack;
+    jpeg_config->inputLineBufHwModeEn =
+        (jpeg_params->inputLineBufMode == 2 || jpeg_params->inputLineBufMode == 4) ? 1 : 0;
+    jpeg_config->inputLineBufCbFunc = VCEncInputLineBufDone;
+    jpeg_config->inputLineBufCbData = &jpeg_enc_ctx->lineBufCfg;
+    jpeg_config->hashType = jpeg_params->hashtype;
+
+    /* flexa sbi */
+    jpeg_config->sbi_id_0 = 0;
+    jpeg_config->sbi_id_1 = 1;
+    jpeg_config->sbi_id_2 = 2;
+
+    /*stream multi-segment*/
+    jpeg_config->streamMultiSegmentMode = jpeg_params->streamMultiSegmentMode;
+    jpeg_config->streamMultiSegmentAmount = jpeg_params->streamMultiSegmentAmount;
+    jpeg_config->streamMultiSegCbFunc = NULL;
+    jpeg_config->streamMultiSegCbData = NULL;
+
+    /* constant chroma control */
+    jpeg_config->constChromaEn = jpeg_params->constChromaEn;
+    jpeg_config->constCb = jpeg_params->constCb;
+    jpeg_config->constCr = jpeg_params->constCr;
+
+    /* jpeg rate_ctrl*/
+    jpeg_config->targetBitPerSecond = jpeg_params->bitPerSecond;
+    jpeg_config->frameRateNum = 1;
+    jpeg_config->frameRateDenom = 1;
+
+    // framerate valid only when RC enabled
+    if (jpeg_params->bitPerSecond) {
+        jpeg_config->frameRateNum = jpeg_params->frameRateNum;
+        jpeg_config->frameRateDenom = jpeg_params->frameRateDenom;
+    }
+    jpeg_config->qpmin = jpeg_params->qpmin;
+    jpeg_config->qpmax = jpeg_params->qpmax;
+    jpeg_config->fixedQP = jpeg_params->fixedQP;
+    jpeg_config->rcMode = jpeg_params->rcMode;
+    jpeg_config->picQpDeltaMax = jpeg_params->picQpDeltaMax;
+    jpeg_config->picQpDeltaMin = jpeg_params->picQpDeltaMin;
+
+    /*stride*/
+    jpeg_config->exp_of_input_alignment = jpeg_params->exp_of_input_alignment;
+
+    /* overlay control */
+    for (counter = 0; counter < MAX_OVERLAY_NUM; counter++) {
+        jpeg_config->olEnable[counter] = (jpeg_params->overlayEnables >> counter) & 1;
+        jpeg_config->olFormat[counter] = jpeg_params->olFormat[counter];
+        jpeg_config->olAlpha[counter] = jpeg_params->olAlpha[counter];
+        jpeg_config->olWidth[counter] = jpeg_params->olWidth[counter];
+        jpeg_config->olCropWidth[counter] = jpeg_params->olCropWidth[counter];
+        jpeg_config->olHeight[counter] = jpeg_params->olHeight[counter];
+        jpeg_config->olCropHeight[counter] = jpeg_params->olCropHeight[counter];
+        jpeg_config->olXoffset[counter] = jpeg_params->olXoffset[counter];
+        jpeg_config->olCropXoffset[counter] = jpeg_params->olCropXoffset[counter];
+        jpeg_config->olYoffset[counter] = jpeg_params->olYoffset[counter];
+        jpeg_config->olCropYoffset[counter] = jpeg_params->olCropYoffset[counter];
+        jpeg_config->olYStride[counter] = jpeg_params->olYStride[counter];
+        jpeg_config->olUVStride[counter] = jpeg_params->olUVStride[counter];
+        jpeg_config->olBitmapY[counter] = jpeg_params->olBitmapY[counter];
+        jpeg_config->olBitmapU[counter] = jpeg_params->olBitmapU[counter];
+        jpeg_config->olBitmapV[counter] = jpeg_params->olBitmapV[counter];
+        jpeg_config->olSuperTile[counter] = jpeg_params->olSuperTile[counter];
+        jpeg_config->olScaleWidth[counter] = jpeg_params->olScaleWidth[counter];
+        jpeg_config->olScaleHeight[counter] = jpeg_params->olScaleHeight[counter];
+    }
+
+    /* mosaic controls */
+    for (counter = 0; counter < MAX_MOSAIC_NUM; counter++) {
+        jpeg_config->mosEnable[counter] = (jpeg_params->mosaicEnables >> counter) & 1;
+        jpeg_config->mosWidth[counter] = jpeg_params->mosWidth[counter];
+        jpeg_config->mosHeight[counter] = jpeg_params->mosHeight[counter];
+        jpeg_config->mosXoffset[counter] = jpeg_params->mosXoffset[counter];
+        jpeg_config->mosYoffset[counter] = jpeg_params->mosYoffset[counter];
+    }
+
+    /* SRAM power down mode disable  */
+    jpeg_config->sramPowerdownDisable = jpeg_params->sramPowerdownDisable;
+
+    jpeg_config->AXIAlignment = jpeg_params->AXIAlignment;
+    jpeg_config->irqTypeMask = jpeg_params->irqTypeMask;
+    jpeg_config->burstMaxLength = jpeg_params->burstMaxLength;
+
+    jpeg_config->comLength = jpeg_params->comLength;
+    return JPEGENC_OK;
+}
+
+void es_jpeg_encode_report(AVCodecContext *avctx) {
+    UNUSED(avctx);
+    // TODO: referece vsv_encode_report();
+}
+
+/*------------------------------------------------------------------------------
+    es_jenc_init_input_line_buffer
+    -get line buffer params for IRQ handle
+    -get address of input line buffer
+------------------------------------------------------------------------------*/
+static JpegEncRet es_jenc_init_input_line_buffer(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncIn *encIn = (JpegEncIn *)&(jpeg_enc_ctx->enc_input);
+    EWLLinearMem_t *input_buf_mem = &jpeg_enc_ctx->input_buf_mem;
+    JpegEncInst inst = jpeg_enc_ctx->enc_inst;
+    JpegEncCfg *encCfg = (JpegEncCfg *)&jpeg_enc_ctx->enc_config;
+    inputLineBufferCfg *lineBufCfg = (inputLineBufferCfg *)&(jpeg_enc_ctx->lineBufCfg);
+    u32 luma_stride, chroma_stride;
+    u64 luma_size = 0, chroma_size = 0;
+
+    JpegEncGetAlignedStride(
+        encCfg->inputWidth, encCfg->frameType, &luma_stride, &chroma_stride, 1 << encCfg->exp_of_input_alignment);
+    memset(lineBufCfg, 0, sizeof(inputLineBufferCfg));
+
+    JpegGetLumaSize(jpeg_enc_ctx->enc_inst, &luma_size, NULL);
+    JpegGetChromaSize(jpeg_enc_ctx->enc_inst, &chroma_size, NULL);
+
+    lineBufCfg->inst = (void *)inst;
+    // lineBufCfg->asic   = &(((jpegInstance_s *)inst)->asic);
+    lineBufCfg->wrCnt = 0;
+    lineBufCfg->depth = encCfg->inputLineBufDepth;
+    lineBufCfg->inputFormat = encCfg->frameType;
+    lineBufCfg->lumaStride = luma_stride;
+    lineBufCfg->chromaStride = chroma_stride;
+    lineBufCfg->encWidth = encCfg->codingWidth;
+    lineBufCfg->encHeight = encCfg->codingHeight;
+    lineBufCfg->hwHandShake = encCfg->inputLineBufHwModeEn;
+    lineBufCfg->loopBackEn = encCfg->inputLineBufLoopBackEn;
+    lineBufCfg->amountPerLoopBack = encCfg->amountPerLoopBack;
+    lineBufCfg->srcHeight = encCfg->codingType ? encCfg->restartInterval * 16 : encCfg->inputHeight;
+    lineBufCfg->srcVerOffset = encCfg->codingType ? 0 : encCfg->yOffset;
+    lineBufCfg->getMbLines = &JpegEncGetEncodedMbLines;
+    lineBufCfg->setMbLines = &JpegEncSetInputMBLines;
+    lineBufCfg->ctbSize = 16;
+    lineBufCfg->lumSrc = (u8 *)input_buf_mem->virtualAddress;
+    lineBufCfg->cbSrc = lineBufCfg->lumSrc + luma_size;
+    lineBufCfg->crSrc = lineBufCfg->cbSrc + chroma_size / 2;
+    lineBufCfg->initSegNum = 0;
+    lineBufCfg->client_type = EWL_CLIENT_TYPE_JPEG_ENC;
+
+    if (VCEncInitInputLineBuffer(lineBufCfg)) {
+        return JPEGENC_ERROR;
+    }
+
+    /* loopback mode */
+    if (lineBufCfg->loopBackEn && lineBufCfg->lumBuf.buf) {
+        encIn->busLum = lineBufCfg->lumBuf.busAddress;
+        encIn->busCb = lineBufCfg->cbBuf.busAddress;
+        encIn->busCr = lineBufCfg->crBuf.busAddress;
+
+        /* data in SRAM start from the line to be encoded*/
+        if (encCfg->codingType == JPEGENC_WHOLE_FRAME) {
+            encCfg->yOffset = 0;
+        }
+    }
+    return JPEGENC_OK;
+}
+
+/*------------------------------------------------------------------------------
+
+    es_jenc_set_input_line_buffer
+    -setup inputLineBufferCfg
+    -initialize line buffer
+
+------------------------------------------------------------------------------*/
+static JpegEncRet es_jenc_set_input_line_buffer(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncIn *encIn = (JpegEncIn *)&(jpeg_enc_ctx->enc_input);
+    JpegEncCfg *encCfg = (JpegEncCfg *)&jpeg_enc_ctx->enc_config;
+    inputLineBufferCfg *lineBufCfg = (inputLineBufferCfg *)&(jpeg_enc_ctx->lineBufCfg);
+
+    if (encCfg->codingType == JPEGENC_SLICED_FRAME) {
+        i32 h = encCfg->codingHeight + encCfg->yOffset;
+        i32 sliceRows = encCfg->restartInterval * 16;
+        i32 rows = jpeg_enc_ctx->sliceIdx * sliceRows;
+        if ((rows + sliceRows) <= h)
+            lineBufCfg->encHeight = sliceRows;
+        else
+            lineBufCfg->encHeight = h % sliceRows;
+    }
+    lineBufCfg->wrCnt = 0;
+    encIn->lineBufWrCnt = VCEncStartInputLineBuffer(lineBufCfg, HANTRO_FALSE);
+    encIn->initSegNum = lineBufCfg->initSegNum;
+
+    av_log(avctx,
+           AV_LOG_INFO,
+           "Low latency: depth:%d ,inputFormat:%d, lumaStride:%d, chromaStride:%d,encWidth:%d,encHeight:%d\n",
+           lineBufCfg->depth,
+           lineBufCfg->inputFormat,
+           lineBufCfg->lumaStride,
+           lineBufCfg->chromaStride,
+           lineBufCfg->encWidth,
+           lineBufCfg->encHeight);
+    av_log(avctx,
+           AV_LOG_INFO,
+           "Low latency: hwHandShake:%d,loopBackEn:%d,amountPerLoopBack:%d,srcHeight:%d, srcVerOffset:%d,\n",
+           lineBufCfg->hwHandShake,
+           lineBufCfg->loopBackEn,
+           lineBufCfg->amountPerLoopBack,
+           lineBufCfg->srcHeight,
+           lineBufCfg->srcVerOffset);
+    av_log(avctx,
+           AV_LOG_INFO,
+           "Low latency: lineBufCfg->lumSrc:%p,lineBufCfg->cbSrc:%p, lineBufCfg->crSrc:%p\n",
+           lineBufCfg->lumSrc,
+           lineBufCfg->cbSrc,
+           lineBufCfg->crSrc);
+    av_log(
+        avctx, AV_LOG_INFO, "encIn->lineBufWrCnt:%d, encIn->initSegNum:%d\n", encIn->lineBufWrCnt, encIn->initSegNum);
+
+    return JPEGENC_OK;
+}
+
+static int ReadQTable(char *qTableFileName, u8 *qTableLuma, u8 *qTableChroma) {
+    FILE *fp = NULL;
+    u8 *qTable;
+    int line[8];
+    int i, j, num;
+
+    fp = fopen(qTableFileName, "rt");
+    if (fp == NULL) return -1;
+
+    qTable = qTableLuma;
+    for (i = 0; i < 16; i++) {
+        num = fscanf(fp,
+                     "%d %d %d %d %d %d %d %d\n",
+                     line,
+                     line + 1,
+                     line + 2,
+                     line + 3,
+                     line + 4,
+                     line + 5,
+                     line + 6,
+                     line + 7);
+        if (num != 8) {
+            fclose(fp);
+            return -1;
+        }
+        for (j = 0; j < 8; j++) {
+            if (line[j] > 255) {
+                fclose(fp);
+                av_log(NULL, AV_LOG_ERROR, "Invalid Quant Table value %d at %d.\n", line[j], i * 8 + j);
+                return -1;
+            }
+            qTable[j] = (u8)line[j];
+        }
+
+        if (i == 7)
+            qTable = qTableChroma;
+        else
+            qTable += 8;
+    }
+    fclose(fp);
+    return 0;
+}
+
+static JpegEncRet es_jenc_set_quant_table(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *params = &(jpeg_enc_ctx->jpeg_enc_params);
+    EsJpegEncParams *option_params = &(jpeg_enc_ctx->jpeg_option_params);
+    /* An example of user defined quantization table */
+    u8 *qTableLuma = jpeg_enc_ctx->qtable_luma;
+    u8 *qTableChroma = jpeg_enc_ctx->qtable_chroma;
+
+    params->qLevel = option_params->qLevel;
+    if (params->qLevel == USER_DEFINED_QTABLE && (0 != strcmp(option_params->qTablePath, ""))) {
+        // read qtable
+        av_log(avctx, AV_LOG_INFO, "qLevel %u, user qtable: %s\n", params->qLevel, option_params->qTablePath);
+        if (0 != ReadQTable(option_params->qTablePath, qTableLuma, qTableChroma)) {
+            av_log(avctx, AV_LOG_INFO, "Failed to open qtable from file %s\n. ", params->qTablePath);
+            return JPEGENC_ERROR;
+        }
+    }
+
+    return JPEGENC_OK;
+}
+
+static JpegEncRet es_jenc_release_codec(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncInst enc_inst = jpeg_enc_ctx->enc_inst;
+    JpegEncRet ret_value = JPEGENC_OK;
+
+    av_log(avctx, AV_LOG_INFO, "es_jenc_release_codec()\n");
+
+    ret_value = JpegEncRelease(enc_inst);
+    if (ret_value != JPEGENC_OK) {
+        av_log(
+            avctx, AV_LOG_ERROR, "JpegEncRelease failed\n: ret_value = %d, enc_inst = %p.\n", (int)ret_value, enc_inst);
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "JpegEncRelease: ret_value = %d, enc_inst = %p.\n", (int)ret_value, enc_inst);
+
+    return ret_value;
+}
+
+static JpegEncRet es_jenc_init_thumbnail(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams *option_params = &(jpeg_enc_ctx->jpeg_option_params);
+    JpegEncThumb *jpeg_thumb = &(jpeg_enc_ctx->jpeg_thumb);
+    size_t size;
+    FILE *fThumb;
+
+    if (option_params->thumbnailFormat == 0 || option_params->inputThumb == NULL) {
+        av_log(avctx, AV_LOG_INFO, "No thumbnail picture input\n");
+        jpeg_enc_ctx->thumbnail_enable = false;
+        return JPEGENC_OK;
+    }
+    if (option_params->widthThumb > 0xFF || option_params->heightThumb > 0xFF) {
+        av_log(avctx, AV_LOG_ERROR, "thumbnail picture width/heigh invalid\n");
+        jpeg_enc_ctx->thumbnail_enable = false;
+        return JPEGENC_ERROR;
+    }
+
+    memset(jpeg_thumb, 0, sizeof(JpegEncThumb));
+    // open thumbnail file:
+    fThumb = fopen(option_params->inputThumb, "rb");
+    if (fThumb == NULL) {
+        av_log(avctx, AV_LOG_ERROR, "Unable to open Thumbnail file: %s\n", option_params->inputThumb);
+        return JPEGENC_ERROR;
+    }
+    jpeg_thumb->width = (u8)option_params->widthThumb;
+    jpeg_thumb->height = (u8)option_params->heightThumb;
+
+    switch (option_params->thumbnailFormat) {
+        case 1:
+            fseek(fThumb, 0, SEEK_END);
+            jpeg_thumb->dataLength = ftell(fThumb);
+            jpeg_thumb->format = JPEGENC_THUMB_JPEG;
+            fseek(fThumb, 0, SEEK_SET);
+            break;
+        case 2:
+            jpeg_thumb->dataLength = 3 * 256 + jpeg_thumb->width * jpeg_thumb->height;
+            jpeg_thumb->format = JPEGENC_THUMB_PALETTE_RGB8;
+            break;
+        case 3:
+            jpeg_thumb->dataLength = jpeg_thumb->width * jpeg_thumb->height * 3;
+            jpeg_thumb->format = JPEGENC_THUMB_RGB24;
+            break;
+    }
+
+    jpeg_enc_ctx->thumb_data = (u8 *)malloc(jpeg_thumb->dataLength);
+    size = fread(jpeg_enc_ctx->thumb_data, 1, jpeg_thumb->dataLength, fThumb);
+    if (size = 0) {
+        av_log(avctx, AV_LOG_ERROR, "Unable to read Thumbnail file\n");
+        jpeg_enc_ctx->thumbnail_enable = false;
+        return JPEGENC_ERROR;
+    }
+    fclose(fThumb);
+    jpeg_thumb->data = jpeg_enc_ctx->thumb_data;
+    jpeg_enc_ctx->thumbnail_enable = true;
+
+    av_log(avctx,
+           AV_LOG_INFO,
+           "input thumbnail:%s, width:%d  height:%d, data:%p, data_len:%u\n",
+           option_params->inputThumb,
+           jpeg_thumb->width,
+           jpeg_thumb->height,
+           jpeg_enc_ctx->thumb_data,
+           jpeg_thumb->dataLength);
+    return JPEGENC_OK;
+}
+
+static JpegEncRet es_jenc_set_thumbnail(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncRet ret_value = JPEGENC_OK;
+    JpegEncThumb *jpeg_thumb = &(jpeg_enc_ctx->jpeg_thumb);
+
+    if (jpeg_enc_ctx->thumbnail_enable) {
+        ret_value = JpegEncSetThumbnail(jpeg_enc_ctx->enc_inst, jpeg_thumb);
+        if (ret_value != JPEGENC_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to set thumbnail. Error code: %8i\n", ret_value);
+        }
+    }
+
+    return ret_value;
+}
+
+static int es_jenc_encode_got_mem_fd(const AVFrame *frame, int64_t *mem_fd) {
+    AVFrameSideData *sd = NULL;
+    if (!frame) return -1;
+    if (!frame->nb_side_data) return -1;
+
+    // mem fd
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_MEM_FRAME_FD);
+    if (sd) {
+        *mem_fd = *((int64_t *)sd->data);
+        av_log(NULL, AV_LOG_INFO, "got mem_fd: %lx\n", *mem_fd);
+        return 0;
+    }
+
+    return -1;
+}
+
+static int es_jenc_send_fd_by_avpacket(AVPacket *pkt, int64_t mem_fd) {
+    uint8_t *buf;
+    int64_t *fd;
+    if (!pkt) {
+        av_log(NULL, AV_LOG_ERROR, "es_jenc_send_fd_by_avpacket, invalid pointers\n");
+        return -1;
+    }
+
+    // dma fd
+    buf = av_packet_new_side_data(pkt, SIDE_DATA_TYPE_MEM_FRAME_FD_RELEASE, sizeof(mem_fd));
+    fd = (int64_t *)buf;
+    *fd = mem_fd;
+
+    av_log(NULL, AV_LOG_INFO, "encoded one frame, release pkt with dma fd[%lx]\n", mem_fd);
+
+    return 0;
+}
+
+static JpegEncRet es_jenc_fill_input_buffer(AVCodecContext *avctx, const AVFrame *pict) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncIn *enc_in = (JpegEncIn *)&(jpeg_enc_ctx->enc_input);
+    JpegEncCfg *encCfg = (JpegEncCfg *)&jpeg_enc_ctx->enc_config;
+    EWLLinearMem_t *yuv_frame_mem = (EWLLinearMem_t *)&(jpeg_enc_ctx->input_buf_mem);
+    u64 luma_size = 0, chroma_size = 0;
+    u32 luma_stride, chroma_stride;
+    uint8_t *data[3];
+    int linesize[3];
+    int height = 0;
+    int i = 0;
+
+    JpegGetLumaSize(jpeg_enc_ctx->enc_inst, &luma_size, NULL);
+    JpegGetChromaSize(jpeg_enc_ctx->enc_inst, &chroma_size, NULL);
+    JpegEncGetAlignedStride(
+        encCfg->inputWidth, encCfg->frameType, &luma_stride, &chroma_stride, 1 << encCfg->exp_of_input_alignment);
+
+    av_log(avctx,
+           AV_LOG_DEBUG,
+           "input picture:w: %d, h: %d, format: %d, linesize: %d, %d, %d, data: %p, %p, %p\n",
+           pict->width,
+           pict->height,
+           pict->format,
+           pict->linesize[0],
+           pict->linesize[1],
+           pict->linesize[2],
+           pict->data[0],
+           pict->data[1],
+           pict->data[2]);
+
+    av_log(avctx,
+           AV_LOG_DEBUG,
+           "luma_stride: %d, chroma_stride: %d, lumaSize: %ld, chromaSize: %ld\n",
+           luma_stride,
+           chroma_stride,
+           luma_size,
+           chroma_size);
+
+    switch (encCfg->frameType) {
+        case JPEGENC_YUV420_PLANAR:
+        case JPEGENC_YUV420_I010:
+            data[0] = (uint8_t *)yuv_frame_mem->virtualAddress;
+            data[1] = data[0] + luma_size;
+            data[2] = data[1] + chroma_size / 2;
+            linesize[0] = luma_stride;
+            linesize[1] = chroma_stride;
+            linesize[2] = chroma_stride;
+            enc_in->busLum = yuv_frame_mem->busAddress;
+            enc_in->busCb = enc_in->busLum + luma_size;
+            enc_in->busCr = enc_in->busCb + chroma_size / 2;
+            break;
+        case JPEGENC_YUV420_SEMIPLANAR:
+        case JPEGENC_YUV420_SEMIPLANAR_VU:
+        case JPEGENC_YUV420_MS_P010:
+            data[0] = (uint8_t *)yuv_frame_mem->virtualAddress;
+            data[1] = data[0] + luma_size;
+            data[2] = NULL;
+            linesize[0] = luma_stride;
+            linesize[1] = chroma_stride;
+            linesize[2] = 0;
+            enc_in->busLum = yuv_frame_mem->busAddress;
+            enc_in->busCb = enc_in->busLum + luma_size;
+            enc_in->busCr = 0;
+            break;
+        case JPEGENC_YUV422_INTERLEAVED_YUYV:
+        case JPEGENC_YUV422_INTERLEAVED_UYVY:
+
+            data[0] = (uint8_t *)yuv_frame_mem->virtualAddress;
+            data[1] = NULL;
+            data[2] = NULL;
+            linesize[0] = luma_stride;
+            linesize[1] = 0;
+            linesize[2] = 0;
+            enc_in->busLum = yuv_frame_mem->busAddress;
+            enc_in->busCb = 0;
+            enc_in->busCr = 0;
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, "not support format: %d\n", encCfg->frameType);
+            return JPEGENC_ERROR;
+    }
+
+    for (i = 0; i < FF_ARRAY_ELEMS(data) && data[i]; i++) {
+        height = !i ? pict->height : pict->height >> 1;
+        if (linesize[i] == pict->linesize[i]) {
+            ff_es_codec_memcpy_block(pict->data[i], data[i], pict->linesize[i] * height);
+        } else {
+            ff_es_codec_memcpy_by_line(pict->data[i], data[i], pict->linesize[i], linesize[i], height);
+        }
+    }
+
+    if (EWLSyncMemData(&jpeg_enc_ctx->input_buf_mem, 0, luma_size + chroma_size, HOST_TO_DEVICE) != EWL_OK) {
+        av_log(avctx, AV_LOG_ERROR, "EWLSyncMemData() failed \n");
+        return JPEGENC_ERROR;
+    }
+
+    return JPEGENC_OK;
+}
+
+static JpegEncRet es_jpeg_encode_encode(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *pict) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncRet ret_value = JPEGENC_OK;
+    JpegEncIn *enc_in = (JpegEncIn *)&(jpeg_enc_ctx->enc_input);
+    JpegEncOut *enc_out = (JpegEncOut *)&jpeg_enc_ctx->enc_output;
+    JpegEncCfg *encCfg = (JpegEncCfg *)&jpeg_enc_ctx->enc_config;
+    u64 luma_size = 0, chroma_size = 0;
+    u64 input_buf_size = 0;
+    u32 luma_stride, chroma_stride;
+    // output:
+    u32 buf0Len;
+    u32 writeSize;
+    int new_size;
+
+    // input fd
+    int64_t mem_fd = 0;
+    unsigned long vir_addr = 0;
+
+#ifdef SUPPORT_DMA_HEAP
+    const void *ewl_inst = JpegEncGetEwl(jpeg_enc_ctx->enc_inst);
+#endif
+
+    memset(enc_in, 0, sizeof(JpegEncIn));
+    // output buffer
+    for (int i = 0; i < 1; i++) {
+        enc_in->pOutBuf[i] = (u8 *)jpeg_enc_ctx->outbufMem[0].virtualAddress;
+        enc_in->busOutBuf[i] = jpeg_enc_ctx->outbufMem[0].busAddress;
+        enc_in->outBufSize[i] = jpeg_enc_ctx->outbufMem[0].size;
+        av_log(
+            avctx, AV_LOG_DEBUG, "encIn.pOutBuf[%d] Vaddr:%p, size:%d\n", i, enc_in->pOutBuf[i], enc_in->outBufSize[i]);
+    }
+
+    // input buffer
+    JpegGetLumaSize(jpeg_enc_ctx->enc_inst, &luma_size, NULL);
+    JpegGetChromaSize(jpeg_enc_ctx->enc_inst, &chroma_size, NULL);
+    JpegEncGetAlignedStride(
+        encCfg->inputWidth, encCfg->frameType, &luma_stride, &chroma_stride, 1 << encCfg->exp_of_input_alignment);
+    input_buf_size = luma_size + chroma_size;
+    if (!es_jenc_encode_got_mem_fd(pict, &mem_fd)) {
+        // get dma buffer virtual addr
+#ifdef SUPPORT_DMA_HEAP
+        EWLGetIovaByFd(ewl_inst, mem_fd, &vir_addr);
+#else
+        vir_addr = mem_fd;
+#endif
+        if (luma_stride != pict->linesize[0]) {
+            av_log(avctx,
+                   AV_LOG_ERROR,
+                   "for share buffer, jenc alignment[%d] !=  linesize[%d] failed\n",
+                   luma_stride,
+                   pict->linesize[0]);
+            return JPEGENC_ERROR;
+        }
+        enc_in->busLum = (ptr_t)vir_addr;
+        enc_in->busCb = enc_in->busLum + luma_size;
+        enc_in->busCr = enc_in->busCb + chroma_size / 2;
+    } else {
+        ret_value = es_jenc_fill_input_buffer(avctx, pict);
+        if (ret_value != JPEGENC_OK) {
+            av_log(avctx, AV_LOG_ERROR, "fill input buffer mem failed, ret:%d\n", ret_value);
+            return JPEGENC_ERROR;
+        }
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "pEncIn->busLum = %p, lumaSize:%ld\n", (void *)enc_in->busLum, luma_size);
+    av_log(avctx, AV_LOG_DEBUG, "pEncIn->busCb = %p,chromaSize:%ld\n", (void *)enc_in->busCb, chroma_size);
+    av_log(avctx, AV_LOG_DEBUG, "pEncIn->busCr = %p\n", (void *)enc_in->busCr);
+
+    enc_in->frameHeader = 1;
+    enc_in->lineBufWrCnt = 0;
+    enc_in->dec400Enable = 1;
+
+    if (jpeg_enc_ctx->roi_enable) {
+        enc_in->filter = jpeg_enc_ctx->enc_config.filter;
+        enc_in->busRoiMap = jpeg_enc_ctx->roimapMem.busAddress;
+    } else {
+        enc_in->filter = NULL;
+        enc_in->busRoiMap = 0;
+    }
+
+    /* Set thumbnail every frame*/
+    ret_value = es_jenc_set_thumbnail(avctx);
+    if (ret_value != 0) {
+        av_log(avctx, AV_LOG_ERROR, "es_jpeg_set_enc_thumbnail error. ret_value = %d\n", ret_value);
+        return ret_value;
+    }
+
+    /* Multi Segment Mode */
+    if (jpeg_enc_ctx->stream_multi_segment_mode != 0) {
+        av_log(avctx, AV_LOG_DEBUG, "stream multi segment mode enable\n");
+        // VS don't support stream multi-segment
+        // InitStreamSegmentCrl(&streamSegCtl, &cmdl, fout, &encIn);
+    }
+
+    /* Low latency */
+    if (jpeg_enc_ctx->input_line_buf_mode) {
+        ret_value = es_jenc_set_input_line_buffer(avctx);
+        if (ret_value != JPEGENC_OK) {
+            av_log(avctx, AV_LOG_ERROR, "es_jenc_set_input_line_buffer() failed ,ret:%d\n", ret_value);
+            return ret_value;
+        }
+    }
+reenc:
+    gettimeofday(&jpeg_enc_ctx->time_frame_start, 0);
+    ret_value = JpegEncEncode(jpeg_enc_ctx->enc_inst, enc_in, enc_out);
+    gettimeofday(&jpeg_enc_ctx->time_frame_end, 0);
+    switch (ret_value) {
+        case JPEGENC_FRAME_READY:
+        case JPEGENC_RESTART_INTERVAL:
+            if (ret_value == JPEGENC_RESTART_INTERVAL) {
+                av_log(avctx, AV_LOG_INFO, "partial frame encoded succsess\n");
+            }
+
+            av_log(avctx, AV_LOG_DEBUG, "enc_output->streamSize = %d\n", jpeg_enc_ctx->out_stream_size);
+
+            if (jpeg_enc_ctx->input_line_buf_mode) {
+                VCEncUpdateInitSegNum(&jpeg_enc_ctx->lineBufCfg);
+            }
+
+            buf0Len = jpeg_enc_ctx->outbufMem[0].size;
+            writeSize = MIN(enc_out->jfifSize, buf0Len - enc_out->invalidBytesInBuf0Tail);
+
+#if 0
+            {
+                // In some cases the EOI marker (0xff 0xd9) will be missing.
+                // So we check and add it when the scenario occurs.
+                u8 * head = (u8 *) jpeg_enc_ctx->outbufMem[0].virtualAddress;
+                u8 * tail = head + writeSize - 2;
+                if ((tail[0] != 0xff) && (tail[1] != 0xd9)) {
+                    tail[2] = 0xff;
+                    tail[3] = 0xd9;
+                    writeSize += 2;
+                    av_log(avctx, AV_LOG_WARNING, "EOI marker missing and added.\n");
+                }
+            }
+#endif
+
+            if (av_new_packet(avpkt, writeSize)) {
+                return -1;
+            }
+
+            memcpy(avpkt->data, (u8 *)jpeg_enc_ctx->outbufMem[0].virtualAddress, writeSize);
+            avpkt->size = writeSize;
+            avpkt->pts = pict->pts;
+            break;
+        case JPEGENC_OUTPUT_BUFFER_OVERFLOW:
+            av_log(avctx, AV_LOG_WARNING, " out put buffer overflow\n");
+
+            // choose decompress rate
+            jpeg_enc_ctx->compress_rate--;
+            if (jpeg_enc_ctx->compress_rate < 2) {
+                jpeg_enc_ctx->compress_rate = 1;
+            }
+            new_size = input_buf_size / jpeg_enc_ctx->compress_rate;
+            if (jpeg_enc_ctx->outbufMem[0].size >= new_size) {
+                // VS testbench defalut value
+                new_size = encCfg->inputWidth * encCfg->inputHeight * 2;
+            }
+            av_log(avctx, AV_LOG_INFO, " out put buffer realloc %d->%d\n", jpeg_enc_ctx->outbufMem[0].size, new_size);
+            if (es_jenc_realloc_output_buffer(avctx, new_size) != 0) {
+                av_log(avctx, AV_LOG_ERROR, "out put buffer realloc failed\n");
+                return JPEGENC_ERROR;
+            }
+            enc_in->pOutBuf[0] = (u8 *)jpeg_enc_ctx->outbufMem[0].virtualAddress;
+            enc_in->busOutBuf[0] = jpeg_enc_ctx->outbufMem[0].busAddress;
+            enc_in->outBufSize[0] = jpeg_enc_ctx->outbufMem[0].size;
+            goto reenc;
+            break;
+        default:
+            av_log(avctx, AV_LOG_ERROR, " encoded failed ret = %d\n", ret_value);
+            break;
+    }
+
+    if (mem_fd != 0) {
+#ifdef SUPPORT_DMA_HEAP
+        EWLPutIovaByFd(ewl_inst, mem_fd);
+#endif
+        es_jenc_send_fd_by_avpacket(avpkt, mem_fd);
+    }
+
+    return ret_value;
+}
+
+static av_cold JpegEncRet es_jpeg_encode_open(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncRet ret_value = JPEGENC_ERROR;
+    JpegEncApiVersion jpeg_api_ver;
+    JpegEncBuild jpeg_api_build;
+    i32 useVcmd = 1;
+
+    if (jpeg_enc_ctx->encoder_is_open) {
+        av_log(avctx, AV_LOG_INFO, "encoder is already open.\n");
+        return 0;
+    }
+
+    if (jpeg_enc_ctx->input_line_buf_mode) {
+        useVcmd = 0;
+    }
+    EWLAttach(NULL, 0, useVcmd);
+    jpeg_api_ver = JpegEncGetApiVersion();
+    jpeg_api_build = JpegEncGetBuild(0, NULL);
+#ifdef FB_SYSLOG_ENABLE
+    ENC_INFO_PRINT((const char *)&jpeg_enc_ctx->log_header,
+                   "JPEG Encoder API version %d.%d.%d\n",
+                   jpeg_api_ver.major,
+                   jpeg_api_ver.minor,
+                   jpeg_api_ver.clnum);
+    ENC_INFO_PRINT((const char *)&jpeg_enc_ctx->log_header,
+                   "JPEG Encoder HW ID:  0x%08x\t SW Build: %u.%u.%u\n\n",
+                   jpeg_api_build.hwBuild,
+                   jpeg_api_build.swBuild / 1000000,
+                   (jpeg_api_build.swBuild / 1000) % 1000,
+                   jpeg_api_build.swBuild % 1000);
+#else
+    UNUSED(jpeg_api_ver);
+    UNUSED(jpeg_api_build);
+#endif
+
+    ret_value = es_jenc_init_codec(avctx);
+    if (ret_value != JPEGENC_OK) {
+        goto error_exit;
+    }
+
+    ret_value = es_jenc_alloc_codec_res(avctx);
+    if (ret_value != JPEGENC_OK) {
+        goto error_exit;
+    }
+
+    /* init low latency */
+    if (jpeg_enc_ctx->input_line_buf_mode) {
+        av_log(avctx, AV_LOG_INFO, "inputline buffer mode enable\n");
+        ret_value = es_jenc_init_input_line_buffer(avctx);
+        if (ret_value != JPEGENC_OK) {
+            av_log(avctx, AV_LOG_ERROR, "es_jenc_init_input_line_buffer() failed ,ret:%d\n", ret_value);
+            goto error_exit;
+        }
+    }
+
+    /* init input roi*/
+    if (jpeg_enc_ctx->roi_enable) {
+        if (read_non_roi_fliter(avctx) != 0) {
+            av_log(avctx, AV_LOG_ERROR, "read_non_roi_fliter() failed \n");
+            goto error_exit;
+        } else {
+            // set roi
+            read_roimap(avctx);
+        }
+    }
+
+    ret_value = JpegEncSetPictureSize(jpeg_enc_ctx->enc_inst, &(jpeg_enc_ctx->enc_config));
+    if (ret_value != JPEGENC_OK) {
+        av_log(avctx, AV_LOG_ERROR, "JpegEncSetPictureSize() failed ,ret:%d\n", ret_value);
+        goto error_exit;
+    }
+    jpeg_enc_ctx->encoder_is_open = 1;
+    return JPEGENC_OK;
+
+error_exit:
+    es_jenc_free_codec_res(avctx);
+    es_jenc_release_codec(avctx);
+    return ret_value;
+}
+
+#ifndef CONFIG_ESW_FF_ENHANCEMENT
+static int es_jpeg_encode_init_hwcontext(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+
+    /* hw device & frame init */
+    if (avctx->hw_frames_ctx) {
+        AVHWFramesContext *hwframe;
+
+        hwframe = (AVHWFramesContext *)avctx->hw_frames_ctx->data;
+        jpeg_enc_ctx->hwdevice = (AVVSVDeviceContext *)((AVHWDeviceContext *)hwframe->device_ref->data)->hwctx;
+        if (!jpeg_enc_ctx->hwdevice) {
+            return AVERROR(ENOMEM);
+        }
+    } else if (avctx->hw_device_ctx) {
+        av_log(avctx, AV_LOG_TRACE, "%s(%d) avctx->hw_device_ctx = %p\n", __FUNCTION__, __LINE__, avctx->hw_device_ctx);
+        jpeg_enc_ctx->hwdevice = (AVVSVDeviceContext *)((AVHWDeviceContext *)avctx->hw_device_ctx->data)->hwctx;
+        av_log(avctx,
+               AV_LOG_TRACE,
+               "%s(%d) jpeg_enc_ctx->hwdevice = %p\n",
+               __FUNCTION__,
+               __LINE__,
+               jpeg_enc_ctx->hwdevice);
+        if (!jpeg_enc_ctx->hwdevice) {
+            return AVERROR(ENOMEM);
+        }
+    } else {
+        return AVERROR(EINVAL);
+    }
+
+    // if (jpeg_enc_ctx->lookahead_depth) {
+    //     jpeg_enc_ctx->hwdevice->lookahead = 1;
+    //     nb_frames = 17 + jpeg_enc_ctx->lookahead_depth;
+    // } else {
+    //     nb_frames = 8 + 2;
+    // }
+
+    // if (jpeg_enc_ctx->hwdevice->nb_frames < nb_frames) {
+    //     jpeg_enc_ctx->hwdevice->nb_frames = nb_frames;
+    // }
+
+    return 0;
+}
+#endif
+
+av_cold int ff_es_jpeg_encode_init(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    EsJpegEncParams params;
+    JpegEncRet ret_value = JPEGENC_OK;
+
+    av_log(avctx, AV_LOG_TRACE, "%s %d\n", __FUNCTION__, __LINE__);
+
+    /* If you add something that can fail above this av_frame_alloc(),
+     * modify ff_es_jpeg_encode_close() accordingly. */
+    jpeg_enc_ctx->frame = av_frame_alloc();
+    if (!jpeg_enc_ctx->frame) {
+        return AVERROR(ENOMEM);
+    }
+
+    // Create thread/mutex, use video encoder thread utils:
+    ret_value = esenc_init(&jpeg_enc_ctx->tc, avctx, &ff_es_jpeg_encode_encode2);
+    if (ret_value < 0) {
+        ret_value = JPEGENC_ERROR;
+        goto error_exit;
+    }
+
+    // init the jpeg encoder params, set to default value.
+    ret_value = es_jenc_init_params(avctx);
+    if (ret_value != JPEGENC_OK) {
+        goto error_exit;
+    }
+
+    // get the codec's current params, and fix the params user set
+    ret_value = es_jenc_get_params(avctx, &params);
+    if (ret_value != JPEGENC_OK) {
+        goto error_exit;
+    }
+
+    // set the user's params to codec
+    ret_value = es_jenc_set_params(avctx, &params);
+    if (ret_value != JPEGENC_OK) {
+        goto error_exit;
+    }
+
+    // config the params to the codec
+    ret_value = es_jenc_config_codec(avctx);
+    if (ret_value != JPEGENC_OK) {
+        goto error_exit;
+    }
+
+#ifndef CONFIG_ESW_FF_ENHANCEMENT
+    //  hwcontext init
+    ret_value = es_jpeg_encode_init_hwcontext(avctx);
+    if (ret_value < 0) {
+        goto error_exit;
+    }
+#endif
+
+    // open the codec
+    jpeg_enc_ctx->encoder_is_open = 0;
+    ret_value = es_jpeg_encode_open(avctx);
+    if (ret_value != JPEGENC_OK) {
+        av_log(avctx, AV_LOG_ERROR, "es_jpeg_encode_open error. ret_value = %d\n", ret_value);
+        goto error_exit;
+    }
+    return JPEGENC_OK;
+error_exit:
+    ff_es_jpeg_encode_close(avctx);
+    return ret_value;
+}
+
+av_cold int ff_es_jpeg_encode_close(AVCodecContext *avctx) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+
+    /* We check ctx->frame to know whether encode_init()
+     * has been called and va_config/va_context initialized. */
+    if (!jpeg_enc_ctx->frame) return 0;
+
+    esenc_close(jpeg_enc_ctx->tc);
+
+    es_jpeg_encode_report(avctx);
+
+    if (jpeg_enc_ctx->encoder_is_open) {
+        es_jenc_free_codec_res(avctx);
+        es_jenc_release_codec(avctx);
+        jpeg_enc_ctx->encoder_is_open = 0;
+    }
+
+    av_frame_free(&jpeg_enc_ctx->frame);
+    if (avctx->extradata) {
+        av_freep(&avctx->extradata);
+    }
+
+    return JPEGENC_OK;
+}
+
+int ff_es_jpeg_encode_send_frame(AVCodecContext *avctx, const AVFrame *frame) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    return esenc_send_frame(jpeg_enc_ctx->tc, frame);
+}
+
+int ff_es_jpeg_encode_receive_packet(AVCodecContext *avctx, AVPacket *avpkt) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    AVFrame *frame = jpeg_enc_ctx->frame;
+    int err;
+
+    err = ff_encode_get_frame(avctx, frame);
+    if (err < 0 && err != AVERROR_EOF) {
+        return err;
+    }
+
+    if (err == AVERROR_EOF) {
+        av_log(avctx, AV_LOG_INFO, "send NULL frame ,eos frame\n");
+        frame = NULL;
+    }
+
+#ifdef DUMP_ESJENC_INPUT
+    if (frame) {
+        av_log(avctx, AV_LOG_ERROR, "open  inputyuv.yuv\n");
+        FILE *input_f = fopen("inputyuv.yuv", "wb+");
+        if (input_f == NULL) av_log(avctx, AV_LOG_ERROR, "open  inputyuv.yuv failed\n");
+        av_log(avctx, AV_LOG_ERROR, "frame->data[0,1,2]:[%p,%p,%p]\n", frame->data[0], frame->data[1], frame->data[2]);
+        av_log(avctx,
+               AV_LOG_ERROR,
+               "frame->linesize[0,1,2]:[%d,%d,%d]\n",
+               frame->linesize[0],
+               frame->linesize[1],
+               frame->linesize[2]);
+        av_log(avctx, AV_LOG_ERROR, "frame w h:[%d,%d]\n", frame->width, frame->height);
+        fwrite(frame->data[0], frame->width * frame->height * 3 / 2, 1, input_f);
+        fflush(input_f);
+        fclose(input_f);
+    }
+#endif
+
+    err = esenc_send_frame(jpeg_enc_ctx->tc, frame);
+    if (err != 0) {
+        av_log(avctx, AV_LOG_ERROR, "esenc_send_frame failed res=:%d\n", err);
+        return err;
+    }
+    return esenc_receive_packet(jpeg_enc_ctx->tc, avpkt);
+}
+
+static JpegEncRet es_jenc_side_data_parse(AVCodecContext *avctx, const AVFrame *frame) {
+    EsJpegEncodeContext *jpeg_enc_ctx = (EsJpegEncodeContext *)avctx->priv_data;
+    JpegEncThumb *jpeg_thumb = &(jpeg_enc_ctx->jpeg_thumb);
+    AVFrameSideData *sd = NULL;
+    SideDataThumbnail *sd_thumbnail = NULL;
+    SideDataRoiArea *sd_roi_areas = NULL;
+    SideDataJencNonRoiFilter *sd_non_roi_filter = NULL;
+    if (!avctx) return JPEGENC_ERROR;
+    if (!frame) return JPEGENC_OK;
+    if (!frame->nb_side_data) return JPEGENC_OK;
+
+    // got thumbnail side data
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_JENC_THUMBNAIL);
+    if (sd) {
+        sd_thumbnail = (SideDataThumbnail *)sd->data;
+        av_log(avctx, AV_LOG_INFO, "received thumbnail sd, data_size = %d\n", sd_thumbnail->data_length);
+    }
+
+    // got roi from side data
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_JENC_ROI_AREA);
+    if (sd) {
+        sd_roi_areas = (SideDataRoiArea *)sd->data;
+    }
+
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_JENC_NON_ROI_FILTER);
+    if (sd) {
+        sd_non_roi_filter = (SideDataJencNonRoiFilter *)sd->data;
+        av_log(avctx, AV_LOG_INFO, "received non roi filter sd, level:%d\n", sd_non_roi_filter->non_roi_qp_level);
+    }
+
+    if (sd_thumbnail) {
+        jpeg_thumb->format = sd_thumbnail->format;
+        jpeg_thumb->width = sd_thumbnail->width;
+        jpeg_thumb->height = sd_thumbnail->height;
+        jpeg_thumb->data = sd_thumbnail->data;
+        jpeg_thumb->dataLength = sd_thumbnail->data_length;
+        jpeg_enc_ctx->thumbnail_enable = 1;
+    }
+
+    if (sd_roi_areas != NULL && sd_non_roi_filter != NULL) {
+        // 1.alloc roi
+        if (jpeg_enc_ctx->roi_buffer_alloced == FALSE) {
+            es_jenc_alloc_roi_res(avctx);
+            jpeg_enc_ctx->roi_buffer_alloced = TRUE;
+        }
+        // 2.set non roi filter
+        dynamic_read_non_roi_filter(avctx, sd_non_roi_filter);
+        // 3.set roi area
+        dynamic_read_roimap(avctx, frame);
+        jpeg_enc_ctx->roi_enable = 1;
+    }
+
+    return JPEGENC_OK;
+}
+
+int ff_es_jpeg_encode_encode2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet) {
+    JpegEncRet ret_value = JPEGENC_OK;
+    *got_packet = 0;
+
+    ret_value = es_jenc_side_data_parse(avctx, frame);
+    if (frame == NULL) {
+        av_log(avctx, AV_LOG_INFO, "ff_es_jpeg_encode_encode2 frame is null\n");
+        ret_value = AVERROR_EOF;
+    } else {
+        av_log(avctx,
+               AV_LOG_DEBUG,
+               "frame ref count %d for %p\n",
+               av_buffer_get_ref_count(frame->buf[0]),
+               frame->buf[0]->data);
+
+        ret_value = es_jpeg_encode_encode(avctx, avpkt, frame);
+
+        if (ret_value == JPEGENC_FRAME_READY || ret_value == JPEGENC_RESTART_INTERVAL) {
+            *got_packet = 1;
+        } else {
+            /* need error process */
+            ret_value = JPEGENC_ERROR;
+        }
+    }
+    av_log(avctx, AV_LOG_DEBUG, "%s(%d) got_packet %d\n", __FUNCTION__, __LINE__, *got_packet);
+
+    return (int)ret_value;
+}
+
+const FFCodec ff_jpeg_es_encoder = {
+    .p.name = JPEG_ES_ENCODER_STR,
+    .p.long_name = NULL_IF_CONFIG_SMALL("Eswin JPEG encoder, on VeriSilicon & GStreamer & FFmpeg"),
+    .p.type = AVMEDIA_TYPE_VIDEO,
+    .p.id = AV_CODEC_ID_MJPEG,
+    .priv_data_size = sizeof(EsJpegEncodeContext),
+    .init = ff_es_jpeg_encode_init,
+    .close = ff_es_jpeg_encode_close,
+    // .send_frame = &ff_es_jpeg_encode_send_frame,
+    FF_CODEC_RECEIVE_PACKET_CB(ff_es_jpeg_encode_receive_packet),
+    // FF_CODEC_ENCODE_CB(ff_es_jpeg_encode_encode2),
+    .p.priv_class = &es_jpeg_encode_class,
+    .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE,
+    .defaults = es_jpeg_encode_defaults,
+    .p.pix_fmts = es_jenc_support_pixfmts,
+    .hw_configs = es_jpeg_encode_hw_configs,
+    .p.wrapper_name = "es",
+};
diff --git a/libavcodec/es_jpegenc.h b/libavcodec/es_jpegenc.h
new file mode 100644
index 0000000000..3504770b62
--- /dev/null
+++ b/libavcodec/es_jpegenc.h
@@ -0,0 +1,412 @@
+
+/*
+ * Copyright (C) 2022 Eswin
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ES_JPEGENC_H
+#define AVCODEC_ES_JPEGENC_H
+
+#include <stdio.h>         //printf
+#include "esenc_common.h"  //thread unit
+
+/* Maximum lenght of the file path */
+#ifndef MAX_PATH
+#define MAX_PATH 512
+#endif
+
+#define MB_SIZE_16 16
+#define MB_SIZE_8 8
+
+/* Quantization tables for luminance, levels 0-9 */
+static const u8 NonRoiFilterLuminance[10][64] = {
+
+    {255, 255, 255, 63, 0,  0,  0, 0, 255, 255, 255, 63, 0, 0, 0, 0, 255, 255, 255, 63, 0, 0,
+     0,   0,   63,  63, 63, 63, 0, 0, 0,   0,   0,   0,  0, 0, 0, 0, 0,   0,   0,   0,  0, 0,
+     0,   0,   0,   0,  0,  0,  0, 0, 0,   0,   0,   0,  0, 0, 0, 0, 0,   0,   0,   0},
+
+    {255, 255, 255, 127, 0,   0,   0, 0, 255, 255, 255, 127, 0, 0, 0, 0, 255, 255, 255, 127, 0, 0,
+     0,   0,   127, 127, 127, 127, 0, 0, 0,   0,   0,   0,   0, 0, 0, 0, 0,   0,   0,   0,   0, 0,
+     0,   0,   0,   0,   0,   0,   0, 0, 0,   0,   0,   0,   0, 0, 0, 0, 0,   0,   0,   0},
+
+    {255, 255, 255, 255, 7,   7,   7, 7, 255, 255, 255, 127, 7, 7, 7, 7, 255, 255, 255, 127, 7, 7,
+     7,   7,   255, 127, 127, 127, 7, 7, 7,   7,   7,   7,   7, 7, 7, 7, 7,   7,   7,   7,   7, 7,
+     7,   7,   7,   7,   7,   7,   7, 7, 7,   7,   7,   7,   7, 7, 7, 7, 7,   7,   7,   7},
+
+    {255, 255, 255, 255, 63,  15,  15, 15, 255, 255, 255, 255, 63, 15, 15, 15, 255, 255, 255, 255, 31, 15,
+     15,  15,  255, 255, 255, 255, 31, 15, 15,  15,  63,  63,  63, 31, 31, 15, 15,  15,  15,  15,  15, 15,
+     15,  15,  15,  15,  15,  15,  15, 15, 15,  15,  15,  15,  15, 15, 15, 15, 15,  15,  15,  15},
+
+    {255, 255, 255, 255, 127, 15,  15,  15, 255, 255, 255, 255, 127, 15,  15, 15, 255, 255, 255, 255, 127, 15,
+     15,  15,  255, 255, 255, 255, 127, 15, 15,  15,  127, 127, 127, 127, 63, 15, 15,  15,  15,  15,  15,  15,
+     15,  15,  15,  15,  15,  15,  15,  15, 15,  15,  15,  15,  15,  15,  15, 15, 15,  15,  15,  15},
+
+    {255, 255, 255, 255, 255, 63,  31,  31, 255, 255, 255, 255, 255, 63,  31,  31, 255, 255, 255, 255, 255, 31,
+     31,  31,  255, 255, 255, 255, 255, 31, 31,  31,  255, 255, 255, 255, 255, 31, 31,  31,  63,  63,  31,  31,
+     31,  31,  31,  31,  31,  31,  31,  31, 31,  31,  31,  31,  31,  31,  31,  31, 31,  31,  31,  31},
+
+    {255, 255, 255, 255, 255, 255, 31,  31,  255, 255, 255, 255, 255, 255, 31,  31, 255, 255, 255, 255, 255, 255,
+     31,  31,  255, 255, 255, 255, 255, 127, 31,  31,  255, 255, 255, 255, 127, 63, 31,  31,  255, 255, 255, 127,
+     63,  63,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31, 31,  31,  31,  31},
+
+    {255, 255, 255, 255, 255, 255, 127, 63,  255, 255, 255, 255, 255, 255, 127, 63,  255, 255, 255, 255, 255, 255,
+     31,  63,  255, 255, 255, 255, 255, 255, 31,  63,  255, 255, 255, 255, 255, 255, 31,  63,  255, 255, 255, 255,
+     255, 255, 31,  63,  127, 127, 31,  31,  31,  31,  31,  63,  63,  63,  63,  63,  63,  63,  63,  63},
+
+    {255, 255, 255, 255, 255, 255, 127, 63,  255, 255, 255, 255, 255, 255, 127, 63,  255, 255, 255, 255, 255, 255,
+     127, 63,  255, 255, 255, 255, 255, 255, 127, 63,  255, 255, 255, 255, 255, 255, 127, 63,  255, 255, 255, 255,
+     255, 255, 63,  63,  127, 127, 127, 127, 127, 63,  63,  63,  63,  63,  63,  63,  63,  63,  63,  63},
+
+    {255, 255, 255, 255, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255, 255, 127, 255, 255, 255, 255, 255, 255,
+     255, 127, 255, 255, 255, 255, 255, 255, 255, 63,  255, 255, 255, 255, 255, 255, 255, 63,  255, 255, 255, 255,
+     255, 255, 255, 63,  255, 255, 255, 255, 255, 255, 255, 63,  127, 127, 127, 63,  63,  63,  63,  63}};
+
+/* Quantization tables for chrominance, levels 0-9 */
+static const u8 NonRoiFilterChrominance[10][64] = {
+    {255, 255, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+     0,   0,   0, 0, 0, 0, 0, 0, 0,   0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+
+    {255, 255, 31, 0, 0, 0, 0, 0, 255, 255, 31, 0, 0, 0, 0, 0, 31, 31, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+     0,   0,   0,  0, 0, 0, 0, 0, 0,   0,   0,  0, 0, 0, 0, 0, 0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
+
+    {255, 255, 255, 31, 7,  7,  7, 7, 255, 255, 255, 31, 7, 7, 7, 7, 255, 255, 255, 31, 7, 7,
+     7,   7,   31,  31, 31, 31, 7, 7, 7,   7,   7,   7,  7, 7, 7, 7, 7,   7,   7,   7,  7, 7,
+     7,   7,   7,   7,  7,  7,  7, 7, 7,   7,   7,   7,  7, 7, 7, 7, 7,   7,   7,   7},
+
+    {255, 255, 255, 255, 31,  15,  15, 15, 255, 255, 255, 255, 31, 15, 15, 15, 255, 255, 255, 255, 31, 15,
+     15,  15,  255, 255, 255, 255, 31, 15, 15,  15,  31,  31,  31, 31, 31, 15, 15,  15,  15,  15,  15, 15,
+     15,  15,  15,  15,  15,  15,  15, 15, 15,  15,  15,  15,  15, 15, 15, 15, 15,  15,  15,  15},
+
+    {255, 255, 255, 255, 127, 15,  15, 15, 255, 255, 255, 255, 63, 15, 15, 15, 255, 255, 255, 255, 63, 15,
+     15,  15,  255, 255, 255, 255, 63, 15, 15,  15,  127, 63,  63, 63, 63, 15, 15,  15,  15,  15,  15, 15,
+     15,  15,  15,  15,  15,  15,  15, 15, 15,  15,  15,  15,  15, 15, 15, 15, 15,  15,  15,  15},
+
+    {255, 255, 255, 255, 255, 63,  31,  31, 255, 255, 255, 255, 255, 63,  31,  31, 255, 255, 255, 255, 255, 31,
+     31,  31,  255, 255, 255, 255, 255, 31, 31,  31,  255, 255, 255, 255, 255, 31, 31,  31,  63,  63,  31,  31,
+     31,  31,  31,  31,  31,  31,  31,  31, 31,  31,  31,  31,  31,  31,  31,  31, 31,  31,  31,  31},
+
+    {255, 255, 255, 255, 255, 255, 31,  31, 255, 255, 255, 255, 255, 255, 31,  31, 255, 255, 255, 255, 255, 255,
+     31,  31,  255, 255, 255, 255, 255, 63, 31,  31,  255, 255, 255, 255, 255, 63, 31,  31,  255, 255, 255, 63,
+     63,  63,  31,  31,  31,  31,  31,  31, 31,  31,  31,  31,  31,  31,  31,  31, 31,  31,  31,  31},
+
+    {255, 255, 255, 255, 255, 255, 31,  31,  255, 255, 255, 255, 255, 255, 31,  31,  255, 255, 255, 255, 255, 255,
+     31,  31,  255, 255, 255, 255, 255, 255, 31,  31,  255, 255, 255, 255, 255, 255, 31,  31,  255, 255, 255, 255,
+     255, 255, 31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31,  31},
+
+    {255, 255, 255, 255, 255, 255, 127, 35,  255, 255, 255, 255, 255, 255, 127, 35,  255, 255, 255, 255, 255, 255,
+     127, 35,  255, 255, 255, 255, 255, 255, 127, 35,  255, 255, 255, 255, 255, 255, 63,  35,  255, 255, 255, 255,
+     255, 255, 63,  35,  127, 127, 127, 127, 63,  63,  63,  35,  35,  35,  35,  35,  35,  35,  35,  35},
+
+    {255, 255, 255, 255, 255, 255, 255, 63,  255, 255, 255, 255, 255, 255, 255, 63,  255, 255, 255, 255, 255, 255,
+     255, 63,  255, 255, 255, 255, 255, 255, 255, 63,  255, 255, 255, 255, 255, 255, 255, 63,  255, 255, 255, 255,
+     255, 255, 255, 63,  255, 255, 255, 255, 255, 255, 255, 63,  63,  63,  63,  63,  63,  63,  63,  63}};
+
+typedef struct EsJpegEncParams {
+    /**Parameters affecting input frame and encoded frame resolutions and cropping:*/
+    i32 width;                   /**Width of output image.*/
+    i32 height;                  /**Height of output image.*/
+    i32 lumWidthSrc;             /**Width of source image. */
+    i32 lumHeightSrc;            /**Height of source image.*/
+    i32 horOffsetSrc;            /**Output image horizontal offset.*/
+    i32 verOffsetSrc;            /**Output image vertical offset.*/
+    i32 restartInterval;         /**Restart interval in MCU rows.*/
+    JpegEncFrameType frameType;  //@see JpegEncFrameType: JPEGENC_YUV420_PLANAR
+
+    /**Parameters for RoiMap*/
+    i32 roi_enable;
+    char *roimapFile;   /**Input file for roimap region. [jpeg_roimap.roi]  */
+    char *nonRoiFilter; /**Input file for nonroimap region filter. [filter.txt]*/
+    i32 nonRoiLevel;    // non_roi filter level (0 - 9)
+
+    i32 colorConversion; /**RGB to YCbCr color conversion type.
+                           0 - ITU-R BT.601, RGB limited [16...235] (BT601_l.mat)
+                           1 - ITU-R BT.709, RGB limited [16...235] (BT709_l.mat)
+                           2 - User defined, coefficients defined in test bench.
+                           3 - ITU-R BT.2020
+                           4 - ITU-R BT.601, RGB full [0...255] (BT601_f.mat)
+                           5 - ITU-R BT.601, RGB limited [0...219] (BT601_219.mat)
+                           6 - ITU-R BT.709, RGB full [0...255] (BT709_f.mat) */
+
+    JpegEncPictureRotation rotation; /**Rotate input image.1:90 degrees right,
+                                      2:90 degrees left, 3:180 degrees*/
+
+    JpegEncCodingType partialCoding; /**0=whole frame, 1=partial frame encoding. */
+
+    i32 codingMode; /**@see JpegEncCodingMode: JPEGENC_420_MODE,0=YUV420, 1=YUV422, 2=Monochrome [0]
+                     */
+    i32 markerType; /**@see JpegEncTableMarkerType: JPEGENC_SINGLE_MARKER, Quantization/Huffman
+                       table markers.0 = Single marker 1 = Multiple markers*/
+
+    i32 qLevel;        // Quantization level (0 - 9)
+    char *qTablePath;  // User defined qtable path
+
+    i32 unitsType;  //@JpegEncAppUnitsType :JPEGENC_DOTS_PER_CM
+    i32 xdensity;   // Horizontal pixel density @JpegEncAppUnitsType
+    i32 ydensity;   // Vertical pixel density @JpegEncAppUnitsType
+
+    /** \brief  thumbnail info */
+    char *inputThumb;     // thumbnail path
+    i32 thumbnailFormat;  // thumbnail format 0:disable 1:JPEG 2:RGB8 3:RGB24
+    i32 widthThumb;
+    i32 heightThumb;
+
+    /** \brief Comment header file path,It was add to file header
+     *  Ex: Eswin Jpeg encoder
+     */
+    i32 comLength;  // Length of COM header
+    char com[MAX_PATH];
+
+    /* low latency */
+    i32 inputLineBufMode;
+    i32 inputLineBufDepth;
+    u32 amountPerLoopBack;
+    u32 hashtype;
+
+    /** \brief horizontal mirror 0:disable mirror 1:enable mirror*
+     *   Ex: When using the camera to take a selfie, set mirror =1
+     */
+    i32 mirror;
+
+    /**
+     *-1..4 Convert YUV420 to customer private format. [-1]
+      -1 - No conversion to customer private format
+       0 - customer private tile format for HEVC
+       1 - customer private tile format for H.264
+       2 - customer private YUV422_888
+       3 - common data 8-bit tile 4x4
+       4 - common data 10-bit tile 4x4
+       5 - customer private tile format for JPEG
+     */
+    i32 formatCustomizedType;
+
+    /** Enable/Disable set chroma to a constant pixel value.*/
+    i32 constChromaEn;
+    u32 constCb;  // 0..255. The constant pixel value for Cb. [128]
+    u32 constCr;  // 0..255. The constant pixel value for Cr. [128]
+
+    /** Losless setup(It doesn't work after modification)*/
+    i32 losslessEnable;  // UNUSED
+    i32 predictMode;     // 1~7 - Enalbe lossless with prediction select mode n
+    i32 ptransValue;     //  0..7 Point transform value for lossless encoding. [0]
+
+    /** \brief those params Motion JPEG*/
+    /* jpeg Rate control*/
+    u32 bitPerSecond;   /**Target bit per second. 0 - RC OFF, none zero - RC ON */
+    u32 frameRateNum;   /**1..1048575 Output picture rate numerator.*/
+    u32 frameRateDenom; /**1..1048575 Output picture rate denominator. */
+    i32 rcMode;         /**0..2, JPEG/MJPEG RC mode. 0 = single frame RC mode.1 = video RC with CBR.
+                        2 = video RC with VBR.*/
+    i32 picQpDeltaMin;  /**Qp Delta range in picture-level rate control.
+                        Min: -10..-1 Minimum Qp_Delta in picture RC. [-2]
+                        Max:  1..10  Maximum Qp_Delta in picture RC. [3]
+                        This range only applies to two neighboring frames. */
+    i32 picQpDeltaMax;
+    u32 qpmin;   // 0..51, Minimum frame qp. [0]
+    u32 qpmax;   // 0..51, Maxmum frame qp. [51]
+    i32 fixedQP; /**-1..51, Fixed qp for every frame. [-1], -1   = disable fixed qp mode*/
+
+    u32 exp_of_input_alignment; /** Alignment value of input frame buffer. 0 = Disable
+                                   alignment  4..12 = Base address of input frame buffer and each
+                                   line are aligned to 2^inputAlignmentExp*/
+    u32 streamBufChain;         /**Enable two output stream buffers. 0 - Single output stream buffer 1 - Two
+                                   output stream buffers chained together.*/
+
+    /**Parameters affecting stream multi-segment output**/
+    u32 streamMultiSegmentMode;   /**0..2 Stream multi-segment mode control.0 = Disable stream
+                                     multi-segment.1 = Enable. No SW handshaking. Loop-back enabled.
+                                     2 = Enable. SW handshaking. Loop-back enabled.*/
+    u32 streamMultiSegmentAmount; /** 2..16. the total amount of segments to control
+                                     loopback/sw-handshake/IRQ. */
+
+    char dec400CompTableinput[MAX_PATH];
+    u64 dec400FrameTableSize;
+
+    /* AXI alignment */
+    u32 AXIAlignment;
+
+    /* irq Type mask */
+    u32 irqTypeMask;
+
+    /**Parameters for OSD overlay controls*/
+    char olInput[MAX_OVERLAY_NUM][MAX_PATH];
+    u32 overlayEnables;
+    u32 olFormat[MAX_OVERLAY_NUM];
+    u32 olAlpha[MAX_OVERLAY_NUM];
+    u32 olWidth[MAX_OVERLAY_NUM];
+    u32 olCropWidth[MAX_OVERLAY_NUM];
+    u32 olHeight[MAX_OVERLAY_NUM];
+    u32 olCropHeight[MAX_OVERLAY_NUM];
+    u32 olXoffset[MAX_OVERLAY_NUM];
+    u32 olCropXoffset[MAX_OVERLAY_NUM];
+    u32 olYoffset[MAX_OVERLAY_NUM];
+    u32 olCropYoffset[MAX_OVERLAY_NUM];
+    u32 olYStride[MAX_OVERLAY_NUM];
+    u32 olUVStride[MAX_OVERLAY_NUM];
+    u32 olBitmapY[MAX_OVERLAY_NUM];
+    u32 olBitmapU[MAX_OVERLAY_NUM];
+    u32 olBitmapV[MAX_OVERLAY_NUM];
+    u32 olSuperTile[MAX_OVERLAY_NUM];
+    u32 olScaleWidth[MAX_OVERLAY_NUM];
+    u32 olScaleHeight[MAX_OVERLAY_NUM];
+    char osdDec400CompTableInput[MAX_PATH];
+
+    // Mosaic area
+    u32 mosaicEnables;
+    u32 mosXoffset[MAX_MOSAIC_NUM];
+    u32 mosYoffset[MAX_MOSAIC_NUM];
+    u32 mosWidth[MAX_MOSAIC_NUM];
+    u32 mosHeight[MAX_MOSAIC_NUM];
+
+    /* SRAM power down mode disable */
+    u32 sramPowerdownDisable;
+
+    i32 useVcmd;
+    i32 useDec400;
+    i32 useL2Cache;
+    i32 useAXIFE;
+
+    /*AXI max burst length */
+    u32 burstMaxLength;
+} EsJpegEncParams;
+
+typedef struct EsJpegEncodeContext {
+    const AVClass *class;
+    // common fields of ThreadContext
+    void *tc;
+
+#ifdef FB_SYSLOG_ENABLE
+    LOG_INFO_HEADER log_header;
+#endif
+    char module_name[20];
+
+    JpegEncCfg enc_config;
+    JpegEncInst enc_inst;
+    JpegEncIn enc_input;
+    JpegEncOut enc_output;
+
+    EsJpegEncParams jpeg_enc_params;    /* params set to codec*/
+    EsJpegEncParams jpeg_option_params; /* params set by user @AVOption*/
+
+    /* SW/HW shared memories for input/output buffers */
+    EWLLinearMem_t input_buf_mem;
+    EWLLinearMem_t outbufMem[MAX_STRM_BUF_NUM];
+
+    /* ROI */
+    EWLLinearMem_t roimapMem;
+    bool roi_buffer_alloced;
+    u32 roi_memory_size;
+    u32 roi_enable;
+
+    bool encoder_is_open;
+
+    /* low latency (input line buffer) */
+    int32_t input_line_buf_mode;
+    inputLineBufferCfg lineBufCfg;
+
+    /*  Sliced Frame Coding index*/
+    i32 sliceIdx;
+
+    /*  Thumbnail info*/
+    bool thumbnail_enable;
+    JpegEncThumb jpeg_thumb;
+    u8 *thumb_data; /* thumbnail data buffer */
+
+    /*  when quantization qLevel=9 user defined qTable saved*/
+    u8 qtable_luma[64];
+    u8 qtable_chroma[64];
+
+    /*  Crop info*/
+    char *crop_str;
+
+    // other fields
+    AVCodecContext *avctx;
+
+    u32 out_stream_size; /**< \brief Size of output stream in bytes */
+
+    uint32_t stream_multi_segment_mode; /* VS 9000EJ not support */
+    uint32_t stream_multi_segment_amount;
+
+    struct timeval time_frame_start;
+    struct timeval time_frame_end;
+
+    JpegEncRateCtrl rate_ctrl;
+
+    AVHWFramesContext *hwdevice;
+
+    i32 mb_width;  /**Width of source image of mb. */
+    i32 mb_height; /**Height of source image of mb.*/
+    int compress_rate; // for allocate output buffer as compress rate
+
+    AVFrame *frame;
+} EsJpegEncodeContext;
+
+typedef enum
+{
+    ESJENC_THUMBNAIL_FORMAT_INVALID = 0,   // invalid
+    ESJENC_THUMBNAIL_FORMAT_JPEG = 0x10,   // jpeg
+    ESJENC_THUMBNAIL_FORMAT_RGB8 = 0x11,   // rgb 8
+    ESJENC_THUMBNAIL_FORMAT_RGB24 = 0x13,  // rgb 24
+} JencThumbnailFormat;
+
+typedef struct {
+    JencThumbnailFormat format; /**< \brief Format of the thumbnail */
+    unsigned int width;         /**< \brief Width in pixels of thumbnail */
+    unsigned int height;        /**< \brief Height in pixels of thumbnail */
+    void *data;                 /**< \brief Thumbnail data */
+    unsigned int data_length;   /**< \brief Data amount in bytes */
+} SideDataThumbnail;
+
+/**REGIONS OF INTEREST**/
+typedef struct {
+    int x;
+    int y;
+    int width;
+    int height;
+} SideDataRoiArea;
+
+typedef struct {
+    unsigned int non_roi_qp_level;
+    int non_roi_filter_map[128];
+} SideDataJencNonRoiFilter;
+
+/** Params Function*/
+/**initialization the codecs params*/
+JpegEncRet es_jenc_init_params(AVCodecContext *avctx);
+
+/**Private function ,print the params info*/
+static void es_jenc_print_params(AVCodecContext *avctx, EsJpegEncParams *params);
+
+/**Get Current the codecs params, */
+JpegEncRet es_jenc_get_params(AVCodecContext *avctx, EsJpegEncParams *params);
+
+/**Set the codecs params, If some params you want to fix , call es_jenc_get_params first*/
+JpegEncRet es_jenc_set_params(AVCodecContext *avctx, EsJpegEncParams *params);
+
+av_cold int ff_es_jpeg_encode_init(AVCodecContext *avctx);
+
+av_cold int ff_es_jpeg_encode_close(AVCodecContext *avctx);
+
+int ff_es_jpeg_encode_send_frame(AVCodecContext *avctx, const AVFrame *frame);
+
+int ff_es_jpeg_encode_receive_packet(AVCodecContext *avctx, AVPacket *avpkt);
+
+int ff_es_jpeg_encode_encode2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet);
+
+void es_get_aligned_pic_size_by_format(
+    JpegEncFrameType type, u32 width, u32 height, u32 alignment, u64 *luma_Size, u64 *chroma_Size, u64 *picture_Size);
+#endif
diff --git a/libavcodec/esdec_common.c b/libavcodec/esdec_common.c
new file mode 100644
index 0000000000..7e5485eb06
--- /dev/null
+++ b/libavcodec/esdec_common.c
@@ -0,0 +1,292 @@
+#define LOG_TAG "esdec_common"
+#include "esdec_common.h"
+#include "eslog.h"
+#include "es_codec_private.h"
+
+typedef struct {
+    enum AVPixelFormat pixfmt;
+    enum DecPictureFormat picfmt;
+    const char *pixfmt_name;
+} AvFmtTopicfmt;
+
+static const AvFmtTopicfmt fmttopicfmttable[] = {
+    {AV_PIX_FMT_NV12, DEC_OUT_FRM_YUV420SP, "nv12"},
+    {AV_PIX_FMT_NV21, DEC_OUT_FRM_NV21SP, "nv21"},
+    {AV_PIX_FMT_YUV420P, DEC_OUT_FRM_YUV420P, "yuv420p"},
+    {AV_PIX_FMT_GRAY8, DEC_OUT_FRM_YUV400, "gray"},
+    {AV_PIX_FMT_YUV420P10LE, DEC_OUT_FRM_YUV420P_I010, "yuv420p10le"},
+    {AV_PIX_FMT_P010LE, DEC_OUT_FRM_YUV420SP_P010, "p010le"},
+    {AV_PIX_FMT_RGB24, DEC_OUT_FRM_RGB888, "rgb24"},
+    {AV_PIX_FMT_BGR24, DEC_OUT_FRM_BGR888, "bgr24"},
+    {AV_PIX_FMT_ARGB, DEC_OUT_FRM_ARGB888, "argb24"},
+    {AV_PIX_FMT_ABGR, DEC_OUT_FRM_ABGR888, "abgr24"},
+    {AV_PIX_FMT_0RGB, DEC_OUT_FRM_XRGB888, "0rgb24"},
+    {AV_PIX_FMT_0BGR, DEC_OUT_FRM_XBGR888, "0bgr24"},
+    {AV_PIX_FMT_RGB48LE, DEC_OUT_FRM_R16G16B16, "rgb48le"},
+    {AV_PIX_FMT_BGR48LE, DEC_OUT_FRM_B16G16R16, "bgr48le"},
+    {AV_PIX_FMT_RGBA64LE, DEC_OUT_FRM_A2R10G10B10, "rgba64le"},
+    {AV_PIX_FMT_BGRA64LE, DEC_OUT_FRM_A2B10G10R10, "bgra64le"},
+};
+
+enum AVPixelFormat ff_codec_decfmt_to_pixfmt(enum DecPictureFormat picfmt) {
+    int i;
+
+    for (i = 0; i < sizeof(fmttopicfmttable) / sizeof(AvFmtTopicfmt); i++)
+        if (fmttopicfmttable[i].picfmt == picfmt) return fmttopicfmttable[i].pixfmt;
+
+    return AV_PIX_FMT_NONE;
+}
+
+enum DecPictureFormat ff_codec_pixfmt_to_decfmt(enum AVPixelFormat pixfmt) {
+    int i;
+
+    for (i = 0; i < sizeof(fmttopicfmttable) / sizeof(AvFmtTopicfmt); i++)
+        if (fmttopicfmttable[i].pixfmt == pixfmt) return fmttopicfmttable[i].picfmt;
+
+    return -1;
+}
+
+const char *ff_codec_decfmt_to_char(enum DecPictureFormat picfmt) {
+    for (int i = 0; i < sizeof(fmttopicfmttable) / sizeof(AvFmtTopicfmt); i++)
+        if (fmttopicfmttable[i].picfmt == picfmt) return fmttopicfmttable[i].pixfmt_name;
+
+    return NULL;
+}
+
+const char *ff_codec_pixfmt_to_char(enum AVPixelFormat pixfmt) {
+    for (int i = 0; i < sizeof(fmttopicfmttable) / sizeof(AvFmtTopicfmt); i++)
+        if (fmttopicfmttable[i].pixfmt == pixfmt) return fmttopicfmttable[i].pixfmt_name;
+
+    return NULL;
+}
+
+const char *esdec_get_ppout_enable(int pp_out, int pp_index) {
+    if (pp_out == pp_index) {
+        return "enabled";
+    } else {
+        return "disabled";
+    }
+}
+
+DecPicAlignment esdec_get_align(int stride) {
+    switch (stride) {
+        case 1:
+            return DEC_ALIGN_1B;
+        case 8:
+            return DEC_ALIGN_8B;
+        case 16:
+            return DEC_ALIGN_16B;
+        case 32:
+            return DEC_ALIGN_32B;
+        case 64:
+            return DEC_ALIGN_64B;
+        case 128:
+            return DEC_ALIGN_128B;
+        case 256:
+            return DEC_ALIGN_256B;
+        case 512:
+            return DEC_ALIGN_512B;
+        case 1024:
+            return DEC_ALIGN_1024B;
+        case 2048:
+            return DEC_ALIGN_2048B;
+        default:
+            log_error(NULL, "invaild stride: %d\n", stride);
+    }
+    return DEC_ALIGN_128B;
+}
+
+void ff_esdec_set_ppu_output_pixfmt(int is_8bits, enum AVPixelFormat pixfmt, PpUnitConfig *ppu_cfg) {
+    if (!ppu_cfg) {
+        log_error(NULL, "ppu_cfg is null\n");
+        return;
+    }
+
+    if (!ppu_cfg->enabled) {
+        log_warn(NULL, "pput disenabled\n");
+    } else {
+        enum DecPictureFormat dstpicfmt = ff_codec_pixfmt_to_decfmt(pixfmt);
+        if (!is_8bits) {
+            if (IS_PIC_8BIT_FMT(dstpicfmt)) {
+                ppu_cfg->out_cut_8bits = 1;
+            }
+        }
+        log_info(NULL,
+                 "pixfmt: %d, dstpicfmt: %d, is_8bits: %d, out_cut_8bits: %d\n",
+                 pixfmt,
+                 dstpicfmt,
+                 is_8bits,
+                 ppu_cfg->out_cut_8bits);
+
+        switch (dstpicfmt) {
+            case DEC_OUT_FRM_NV21SP:
+                ppu_cfg->cr_first = 1;
+                break;
+            case DEC_OUT_FRM_YUV420SP:
+                // TODO
+                break;
+            case DEC_OUT_FRM_YUV420P:
+                ppu_cfg->planar = 1;
+                break;
+            case DEC_OUT_FRM_YUV400:
+                ppu_cfg->monochrome = 1;
+                break;
+            case DEC_OUT_FRM_YUV420P_I010:
+                ppu_cfg->planar = 1;
+                ppu_cfg->out_I010 = 1;
+                break;
+            case DEC_OUT_FRM_YUV420SP_P010:
+                ppu_cfg->out_p010 = 1;
+                break;
+            case DEC_OUT_FRM_RGB888:
+            case DEC_OUT_FRM_BGR888:
+            case DEC_OUT_FRM_XRGB888:
+            case DEC_OUT_FRM_XBGR888:
+                ppu_cfg->rgb = 1;
+                ppu_cfg->rgb_format = dstpicfmt;
+                break;
+            case DEC_OUT_FRM_ARGB888:
+            case DEC_OUT_FRM_ABGR888:
+                ppu_cfg->rgb = 1;
+                ppu_cfg->rgb_stan = BT709;
+                ppu_cfg->rgb_alpha = 255;
+                ppu_cfg->rgb_format = dstpicfmt;
+                break;
+            default:
+                log_error(NULL, "not support pixfmt\n");
+                break;
+        }
+    }
+}
+
+void esdec_fill_planes(OutPutInfo *info, struct DecPicture *picture) {
+    if (!info || !picture) {
+        log_info(NULL, "info  or picture is null out: %p\n", info);
+        return;
+    }
+
+    if (!info->enabled) {
+        info->enabled = TRUE;
+    }
+    info->key_frame = (picture->picture_info.pic_coding_type == DEC_PIC_TYPE_I);
+    info->width = picture->pic_width;
+    info->height = picture->pic_height;
+    info->bus_address = picture->luma.bus_address;
+    info->virtual_address = picture->luma.virtual_address;
+    info->format = ff_codec_decfmt_to_pixfmt(picture->picture_info.format);
+    switch (info->format) {
+        case AV_PIX_FMT_NV12:
+        case AV_PIX_FMT_NV21:
+        case AV_PIX_FMT_P010LE:
+            info->n_planes = 2;
+            info->stride[0] = picture->pic_stride;
+            info->stride[1] = picture->pic_stride_ch;
+            info->offset[0] = 0;
+            info->offset[1] = picture->pic_stride * picture->pic_height;
+            info->size = info->offset[1] * 3 / 2;
+            log_debug(NULL,
+                      "format: %d width: %d, height: %d, stride: %d, size: %zu\n",
+                      info->format,
+                      info->width,
+                      info->height,
+                      info->stride[0],
+                      info->size);
+            break;
+        case AV_PIX_FMT_YUV420P:
+        case AV_PIX_FMT_YUV420P10LE:
+            info->n_planes = 3;
+            info->offset[0] = 0;
+            info->stride[0] = picture->pic_stride;
+            info->offset[1] = picture->pic_stride * picture->pic_height;
+            info->stride[1] = picture->pic_stride_ch;
+            info->offset[2] = info->offset[1] + picture->pic_stride_ch * picture->pic_height / 2;
+            info->stride[2] = info->stride[1];
+            info->size = info->offset[1] + picture->pic_stride_ch * picture->pic_height;
+            log_debug(NULL,
+                      "format: %d width: %d, height: %d, stride: %d, size: %zu\n",
+                      info->format,
+                      info->width,
+                      info->height,
+                      info->stride[0],
+                      info->size);
+            break;
+        case AV_PIX_FMT_GRAY8:
+        case AV_PIX_FMT_RGB24:
+        case AV_PIX_FMT_BGR24:
+        case AV_PIX_FMT_ARGB:
+        case AV_PIX_FMT_ABGR:
+        case AV_PIX_FMT_0RGB:
+        case AV_PIX_FMT_0BGR:
+        case AV_PIX_FMT_RGB565:
+        case AV_PIX_FMT_BGR565:
+            info->n_planes = 1;
+            info->stride[0] = picture->pic_stride;
+            info->offset[0] = 0;
+            info->size = picture->pic_stride * picture->pic_height;
+            log_debug(NULL,
+                      "format: %d width: %d, height: %d, stride: %d, size: %zu\n",
+                      info->format,
+                      info->width,
+                      info->height,
+                      info->stride[0],
+                      info->size);
+            break;
+        default: {
+            log_error(NULL, "not support dec format: %d\n", info->format);
+        }
+    }
+}
+
+int32_t ff_codec_compute_size(struct DecPicture *pic) {
+    int32_t size = 0;
+    enum AVPixelFormat format = ff_codec_decfmt_to_pixfmt(pic->picture_info.format);
+    switch (format) {
+        case AV_PIX_FMT_NV12:
+        case AV_PIX_FMT_NV21:
+        case AV_PIX_FMT_P010LE: {
+            size = pic->pic_stride * pic->pic_height * 3 / 2;
+            break;
+        }
+        case AV_PIX_FMT_YUV420P:
+        case AV_PIX_FMT_YUV420P10LE: {
+            size = pic->pic_stride * pic->pic_height + pic->pic_stride_ch * pic->pic_height;
+            break;
+        }
+        case AV_PIX_FMT_GRAY8:
+        case AV_PIX_FMT_RGB24:
+        case AV_PIX_FMT_BGR24:
+        case AV_PIX_FMT_ARGB:
+        case AV_PIX_FMT_ABGR:
+        case AV_PIX_FMT_0RGB:
+        case AV_PIX_FMT_0BGR:
+            size = pic->pic_stride * pic->pic_height;
+            break;
+
+        default: {
+        }
+    }
+    return size;
+}
+
+int ff_codec_dump_data_to_file_by_decpicture(struct DecPicture *pic, DumpHandle *dump_handle) {
+    int len = 0;
+    if (!dump_handle) {
+        return FAILURE;
+    }
+
+    if (ff_codec_compara_timeb(dump_handle->stop_dump_time) > 0) {
+        av_log(NULL, AV_LOG_ERROR, "packe dump need stop\n");
+        return ERR_TIMEOUT;
+    } else {
+        uint8_t *data;
+        int32_t size;
+        data = (uint8_t *)pic->luma.virtual_address;
+        size = pic->luma.size + pic->chroma.size + pic->chroma_cr.size;
+        len = fwrite(data, 1, size, dump_handle->fp);
+        fflush(dump_handle->fp);
+        if (len != size) {
+            av_log(NULL, AV_LOG_ERROR, "write packet error !!! len: %d, size: %d\n", len, size);
+        }
+    }
+    return len;
+}
\ No newline at end of file
diff --git a/libavcodec/esdec_common.h b/libavcodec/esdec_common.h
new file mode 100644
index 0000000000..a8524c2a75
--- /dev/null
+++ b/libavcodec/esdec_common.h
@@ -0,0 +1,71 @@
+#ifndef AVCODEC_ESDEC_COMMON_H__
+#define AVCODEC_ESDEC_COMMON_H__
+#include <dectypes.h>
+#include <libavutil/pixfmt.h>
+#include "es_codec_private.h"
+#include "es_common.h"
+
+#define IS_PIC_8BIT_FMT(fmt) ( \
+  (fmt) == DEC_OUT_FRM_YUV420SP || \
+  (fmt) == DEC_OUT_FRM_YUV420P || \
+  (fmt) == DEC_OUT_FRM_YUV400 || \
+  (fmt) == DEC_OUT_FRM_NV21SP || \
+  (fmt) == DEC_OUT_FRM_RGB888 || \
+  (fmt) == DEC_OUT_FRM_BGR888 || \
+  (fmt) == DEC_OUT_FRM_ARGB888 || \
+  (fmt) == DEC_OUT_FRM_ABGR888 || \
+  (fmt) == DEC_OUT_FRM_XRGB888 || \
+  (fmt) == DEC_OUT_FRM_XBGR888)
+
+  #define IS_PIC_RGB_FMT(fmt) ( \
+  (fmt) == DEC_OUT_FRM_RGB888 || \
+  (fmt) == DEC_OUT_FRM_BGR888 || \
+  (fmt) == DEC_OUT_FRM_R16G16B16 || \
+  (fmt) == DEC_OUT_FRM_B16G16R16 || \
+  (fmt) == DEC_OUT_FRM_ARGB888 || \
+  (fmt) == DEC_OUT_FRM_ABGR888 || \
+  (fmt) == DEC_OUT_FRM_A2R10G10B10 || \
+  (fmt) == DEC_OUT_FRM_A2B10G10R10 || \
+  (fmt) == DEC_OUT_FRM_XRGB888 || \
+  (fmt) == DEC_OUT_FRM_RGB888_P || \
+  (fmt) == DEC_OUT_FRM_BGR888_P || \
+  (fmt) == DEC_OUT_FRM_R16G16B16_P || \
+  (fmt) == DEC_OUT_FRM_B16G16R16_P || \
+  (fmt) == DEC_OUT_FRM_XBGR888)
+
+#define NUM_OF_STREAM_BUFFERS (5)
+#define ES_DEFAULT_STREAM_BUFFER_SIZE (1024 * 1024)  // 1MB
+#define JPEG_DEFAULT_INPUT_MIN_BUFFERS (1)
+#define JPEG_DEFAULT_OUTPUT_MIN_BUFFERS (1)
+#define JPEG_DEFAULT_INPUT_BUFFERS (5)
+#define JPEG_DEFAULT_OUTPUT_BUFFERS (5)
+#define JPEG_DEFAULT_INPUT_MAX_BUFFERS (18)
+#define JPEG_DEFAULT_OUTPUT_MAX_BUFFERS (18)
+#define MAX_BUFFERS 78
+#define MAX_STRM_BUFFERS 18
+
+typedef enum _ESDecState
+{
+    ESDEC_STATE_UNINIT = 0,
+    ESDEC_STATE_STARTED,
+    ESDEC_STATE_STOPPING,
+    ESDEC_STATE_STOPPED,
+    ESDEC_STATE_FLUSHED,
+    ESDEC_STATE_CLOSED
+} ESDecState;
+
+typedef void *ESVDecInst;
+typedef void *ESJDecInst;
+
+enum DecPictureFormat ff_codec_pixfmt_to_decfmt(enum AVPixelFormat pixfmt);
+enum AVPixelFormat ff_codec_decfmt_to_pixfmt(enum DecPictureFormat picfmt);
+void ff_esdec_set_ppu_output_pixfmt(int is_8bits, enum AVPixelFormat pixfmt, PpUnitConfig *ppu_cfg);
+const char *ff_codec_decfmt_to_char(enum DecPictureFormat picfmt);
+const char *ff_codec_pixfmt_to_char(enum AVPixelFormat pixfmt);
+const char *esdec_get_ppout_enable(int pp_out, int pp_index);
+
+DecPicAlignment esdec_get_align(int stride);
+void esdec_fill_planes(OutPutInfo *info, struct DecPicture *picture);
+int32_t ff_codec_compute_size(struct DecPicture *pic);
+int ff_codec_dump_data_to_file_by_decpicture(struct DecPicture *pic, DumpHandle *dump_handle);
+#endif
\ No newline at end of file
diff --git a/libavcodec/esdec_internal.c b/libavcodec/esdec_internal.c
new file mode 100644
index 0000000000..43b862b3e4
--- /dev/null
+++ b/libavcodec/esdec_internal.c
@@ -0,0 +1,985 @@
+#define LOG_TAG "esdec_internal"
+#include <dectypes.h>
+#include <vcdecapi.h>
+#include <jpegdecapi.h>
+#include "eslog.h"
+#include "es_common.h"
+#include "esdec_internal.h"
+#include "esdecbuffer.h"
+#include "esdecapi.h"
+#include "esdec_wrapper.h"
+
+static int esdec_output_buffer_fd_split(void *dwl_inst, void *dec_inst, ESOutputMemory *memory, int pp_count);
+
+void esdec_dwl_memory_free(void *opaque, uint8_t *data) {
+    struct DWLLinearMem *mem = (struct DWLLinearMem *)data;
+    if (!opaque || !mem) {
+        log_error(NULL, "opaque or mem is null mem: %p\n", mem);
+        return;
+    }
+
+    log_info(NULL, "dwl memory free size: %d, vir_addr: %p\n", mem->size, mem->virtual_address);
+    DWLFreeLinear(opaque, mem);
+}
+
+static void esdec_dwl_output_mempry_free(void *opaque, uint8_t *data) {
+    int dma_fd = -1;
+    ESOutputMemory *memory = (ESOutputMemory *)data;
+    if (!opaque || !memory) {
+        log_error(NULL, "opaque or mem is null mem: %p\n", memory);
+        return;
+    }
+
+    dma_fd = ESDecGetDmaBufFd(&memory->mem);
+    log_info(NULL,
+             "output memory dma_fd: %d, size: %d, vir_addr: %p\n",
+             dma_fd,
+             memory->mem.size,
+             memory->mem.virtual_address);
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (memory->fd[i] >= 0) {
+            if (dma_fd != memory->fd[i]) {
+                log_info(NULL, "output buffer close  pp_fd[%d]: %d\n", i, memory->fd[i]);
+                close(memory->fd[i]);
+            }
+
+            memory->fd[i] = -1;
+        }
+    }
+
+    DWLFreeLinear(opaque, &memory->mem);
+    av_free(memory);
+}
+
+void esdec_dwl_release(void *opaque, uint8_t *data) {
+    void *dwl_inst = (void *)data;
+    (void)opaque;
+    if (!dwl_inst) {
+        log_error(NULL, "dwl_inst is null\n");
+        return;
+    }
+    log_info(NULL, "DWLRelease start dwl_inst: %p\n", dwl_inst);
+    DWLRelease(dwl_inst);
+
+    log_info(NULL, "DWLRelease success\n");
+}
+
+void esdec_stream_buffer_consumed(void *stream, void *p_user_data) {
+    int found = 0;
+    struct DWLLinearMem *mem;
+    ESInputPort *port;
+
+    if (!p_user_data) {
+        log_error(NULL, "p_user_data is null\n");
+        return;
+    }
+
+    port = (ESInputPort *)p_user_data;
+    for (int i = 0; i < port->mem_num; i++) {
+        mem = &port->input_mems[i]->mem;
+        if ((uint8_t *)stream >= (uint8_t *)mem->virtual_address
+            && (uint8_t *)stream < (uint8_t *)mem->virtual_address + mem->size) {
+            found = 1;
+            break;
+        }
+    }
+
+    if (found) {
+        InputBuffer buffer;
+        buffer.max_size = mem->size;
+        buffer.bus_address = mem->bus_address;
+        buffer.vir_addr = mem->virtual_address;
+        esdec_release_input_buffer(port->release_queue, &buffer);
+        log_debug(NULL, "input buffer vir_addr: %p consumed\n", mem->virtual_address);
+    } else {
+        log_error(NULL, "input buffer vir_addr: %p don't release\n", stream);
+    }
+}
+
+void esdec_picture_consume(void *opaque, uint8_t *data) {
+    OutputBuffer *buffer;
+    ESOutputPort *port = (ESOutputPort *)opaque;
+    DecPicturePri *pri_pic = (DecPicturePri *)data;
+
+    if (!pri_pic || !port) {
+        log_error(NULL, "pri_pic or port is null port: %p\n", port);
+        return;
+    }
+
+    buffer = (OutputBuffer *)pri_pic->hwpic;
+    if (buffer) {
+        esdec_release_buffer_to_consume_queue(port->consumed_queue, buffer);
+    } else {
+        log_error(NULL, "output buffer: %p is null\n", buffer);
+    }
+}
+
+static int es_decode_alloc_input_memory(void *dwl_inst, ESInputMemory *memory, int size) {
+    int ret = SUCCESS;
+    struct DWLLinearMem *mem;
+    if (!dwl_inst || !memory || size <= 0) {
+        log_error(NULL, "dwl_inst: %p or memory: %p is null size: %d\n", dwl_inst, memory, size);
+        return FAILURE;
+    }
+
+    mem = &memory->mem;
+    mem->mem_type = DWL_MEM_TYPE_DMA_HOST_TO_DEVICE | DWL_MEM_TYPE_CPU;
+    if (DWLMallocLinear(dwl_inst, size, mem) != DWL_OK) {
+        ret = FAILURE;
+        log_error(NULL, "DWLMallocLinear failed size: %d\n", size);
+    } else {
+        memory->buffer_ref =
+            av_buffer_create((uint8_t *)mem, sizeof(*mem), esdec_dwl_memory_free, dwl_inst, AV_BUFFER_FLAG_READONLY);
+        if (!memory->buffer_ref) {
+            ret = FAILURE;
+            esdec_dwl_memory_free(dwl_inst, (uint8_t *)mem);
+            log_error(NULL, "av_buffer_create failed\n");
+        }
+    }
+
+    return ret;
+}
+
+int es_decode_realloc_input_memory(ESInputPort *port, int size, InputBuffer *buffer) {
+    int ret = FAILURE;
+    void *dwl_inst;
+    ESInputMemory *memory = NULL;
+    if (!port || !port->release_queue || !buffer) {
+        log_error(NULL, "input port or buffer is null port: %p, buffer: %p\n", port, buffer);
+        return FAILURE;
+    }
+
+    if (!port->dwl_ref) {
+        log_error(NULL, "input port dwl_ref is null\n");
+        return FAILURE;
+    }
+    dwl_inst = port->dwl_ref->data;
+
+    for (int i = 0; port->input_mems; i++) {
+        if (port->input_mems[i]->mem.virtual_address == buffer->vir_addr) {
+            memory = port->input_mems[i];
+            break;
+        }
+    }
+
+    if (memory) {
+        av_buffer_unref(&memory->buffer_ref);
+        ret = es_decode_alloc_input_memory(dwl_inst, memory, size);
+        if (ret == SUCCESS) {
+            log_info(NULL, "realloc input memory success size: %d\n", size);
+            esdec_input_buffer_init(buffer,
+                                    memory->mem.virtual_address,
+                                    memory->mem.bus_address,
+                                    memory->mem.logical_size,
+                                    memory->mem.size);
+        } else {
+            log_error(NULL, "realloc input memory failed size: %d\n", size);
+        }
+    } else {
+        log_error(NULL, "find memory failed vir_addr: %p\n", buffer->vir_addr);
+    }
+
+    return ret;
+}
+
+ESInputPort *esdec_allocate_input_port(ESDecCodec codec,
+                                       struct AVBufferRef *dwl_ref,
+                                       void *dwl_init,
+                                       int32_t input_buf_num) {
+    int ret = SUCCESS;
+    ESInputPort *port;
+    struct DWLLinearMem *mem;
+    struct DWLInitParam *jpeg_dwl_init = NULL;
+    InputBuffer input_buffer;
+    void *dwl_inst;
+
+    if (!dwl_ref || !dwl_ref->data) {
+        log_error(NULL, "dwl_ref is null dwl_ref: %p\n", dwl_ref);
+        return NULL;
+    }
+
+    if (dwl_init) {
+        jpeg_dwl_init = (struct DWLInitParam *)dwl_init;
+    }
+    dwl_inst = dwl_ref->data;
+
+    if (input_buf_num <= 0) {
+        if (codec != ES_JPEG) {
+            input_buf_num = VCDecMCGetCoreCount() + 1;
+        } else {
+            if (jpeg_dwl_init) {
+#ifdef MODEL_SIMULATION
+                input_buf_num = DWLReadAsicCoreCount() + 1;
+#else
+                input_buf_num = DWLReadAsicCoreCount(jpeg_dwl_init->client_type) + 1;
+#endif
+            } else {
+                input_buf_num = JPEG_DEFAULT_INPUT_MIN_BUFFERS;
+            }
+        }
+    }
+    if (input_buf_num < NUM_OF_STREAM_BUFFERS) {
+        if (codec != ES_JPEG) {
+            input_buf_num = NUM_OF_STREAM_BUFFERS;
+        }
+    } else if (input_buf_num > MAX_STRM_BUFFERS) {
+        input_buf_num = MAX_STRM_BUFFERS;
+    }
+    log_info(NULL, "input_buf_num: %d\n", input_buf_num);
+
+    port = esdec_input_port_create(input_buf_num);
+    if (!port) {
+        return NULL;
+    }
+
+    for (int i = 0; i < input_buf_num; i++) {
+        mem = &port->input_mems[i]->mem;
+        ret = es_decode_alloc_input_memory(dwl_inst, port->input_mems[i], ES_DEFAULT_STREAM_BUFFER_SIZE);
+        if (ret == FAILURE) {
+            ret = FAILURE;
+            log_error(NULL, "index: %d alloc memory failed\n", i);
+            break;
+        } else {
+            log_info(NULL,
+                     "index: %d alloc memory success size: %d, vir_addr: %p\n",
+                     i,
+                     ES_DEFAULT_STREAM_BUFFER_SIZE,
+                     mem->virtual_address);
+        }
+        esdec_input_buffer_init(&input_buffer,
+                                mem->virtual_address,
+                                mem->bus_address,
+                                mem->logical_size,
+                                mem->size);
+        esdec_release_input_buffer(port->release_queue, &input_buffer);
+    }
+    if (ret == FAILURE) {
+        esdec_input_port_unref(&port);
+        log_error(NULL, "allocate input port failed\n");
+    } else {
+        port->dwl_ref = av_buffer_ref(dwl_ref);
+        log_info(NULL, "allocate input port success\n");
+    }
+
+    return port;
+}
+
+int esdec_enlarge_input_port(ESDecCodec codec,
+                                   ESInputPort *port,
+                                   struct AVBufferRef *dwl_ref,
+                                   int32_t buf_num) {
+    int ret = SUCCESS;
+    int rv = 0;
+    struct DWLLinearMem *mem;
+    InputBuffer input_buffer;
+    void *dwl_inst;
+    int mem_num_old = 0;
+
+    if (!dwl_ref || !dwl_ref->data) {
+        log_error(NULL, "dwl_ref is null dwl_ref: %p\n", dwl_ref);
+        return FAILURE;
+    }
+    dwl_inst = dwl_ref->data;
+
+    if (!port) {
+        log_error(NULL, "input port is null\n");
+        return FAILURE;
+    }
+
+    if (buf_num <= 0) {
+        log_error(NULL, "invaild size: %d\n", buf_num);
+        return FAILURE;
+    }
+
+    mem_num_old = port->mem_num;
+    rv = esdec_input_port_enlarge(port, buf_num);
+    if (rv < 0) {
+        log_error(NULL, "esdec_input_port_enlarge failed%p\n");
+        return FAILURE;
+    }
+
+    for (int i = mem_num_old; i < port->mem_num; i++) {
+        mem = &port->input_mems[i]->mem;
+        ret = es_decode_alloc_input_memory(dwl_inst, port->input_mems[i], ES_DEFAULT_STREAM_BUFFER_SIZE);
+        if (ret == FAILURE) {
+            log_error(NULL, "index: %d alloc memory failed\n", i);
+            break;
+        } else {
+            log_info(NULL,
+                     "index: %d alloc memory success size: %d, virtual_address: %p\n",
+                     i,
+                     ES_DEFAULT_STREAM_BUFFER_SIZE,
+                     mem->virtual_address);
+        }
+        esdec_input_buffer_init(&input_buffer,
+                                mem->virtual_address,
+                                mem->bus_address,
+                                mem->logical_size,
+                                mem->size);
+        esdec_release_input_buffer(port->release_queue, &input_buffer);
+    }
+
+    if (ret == FAILURE) {
+        esdec_input_port_unref(&port);
+        log_error(NULL, "enlarge input port failed\n");
+    } else {
+        log_info(NULL, "enlarge input port success size: %d\n", buf_num);
+    }
+
+    return ret;
+}
+
+static enum DecRet esdec_add_one_buffer(ESDecCodec codec, ESVDecInst dec_inst, ESOutputMemory *memory) {
+    enum DecRet rv;
+    struct DWLLinearMem *mem;
+    if (!dec_inst || !memory) {
+        log_error(NULL, "dec_inst: %p or memory: %p is null\n", dec_inst, memory);
+        return DEC_ERROR;
+    }
+
+    if (!memory->is_added && memory->state == OUTPUT_MEMORY_STATE_INITED) {
+        mem = &memory->mem;
+        if (codec != ES_JPEG) {
+            rv = VCDecAddBuffer(dec_inst, mem);
+        } else {
+            rv = JpegDecAddBuffer(dec_inst, mem);
+        }
+        if (rv != DEC_WAITING_FOR_BUFFER && rv != DEC_OK) {
+            log_error(NULL, "VCDecAddBuffer failed\n");
+            return rv;
+        }
+        log_info(NULL, "add buffer rv: %d, vir_addr: %p\n", rv, memory->vir_addr);
+        memory->is_added = TRUE;
+        esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_CONSUMED);
+    } else {
+        log_info(NULL,
+                 "memory is_added: %d, vir_addr: %p, state: %s\n",
+                 memory->is_added,
+                 memory->vir_addr,
+                 esdec_str_output_state(memory->state));
+        rv = DEC_ERROR;
+    }
+
+    return rv;
+}
+
+int esdec_add_all_output_memorys(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst) {
+    int ret = FAILURE;
+    int add_count = 0;
+    enum DecRet rv = DEC_WAITING_FOR_BUFFER;
+    ESOutputMemory *memory;
+    if (!port || !dec_inst) {
+        log_error(NULL, "port: %p, dec_inst: %p\n", port, dec_inst);
+        return FAILURE;
+    }
+
+    esdec_print_output_memory_state(port);
+
+    for (int i = 0; i < port->mem_num; i++) {
+        memory = port->output_mems[i];
+        if (memory->is_added || memory->state != OUTPUT_MEMORY_STATE_INITED) {
+            continue;
+        }
+        rv = esdec_add_one_buffer(codec, dec_inst, memory);
+        if (rv == DEC_WAITING_FOR_BUFFER || rv == DEC_OK) {
+            add_count++;
+        }
+    }
+
+    if (rv == DEC_OK || rv == DEC_WAITING_FOR_BUFFER) {
+        ret = SUCCESS;
+        log_info(NULL, "add all memorys success add_count: %d, mem_num: %d\n", add_count, port->mem_num);
+    } else if (rv == DEC_ERROR) {
+        log_error(NULL, "add all output memorys failed\n");
+    }
+
+    return ret;
+}
+
+static ESOutputMemory *esdec_allocate_one_output_memory(void *dwl_inst, int mem_size) {
+    int ret = FAILURE;
+    AVBufferRef *buffer_ref;
+    ESOutputMemory *memory = NULL;
+    struct DWLLinearMem *mem;
+
+    memory = av_mallocz(sizeof(*memory));
+    do {
+        if (memory) {
+            memory->is_added = FALSE;
+            mem = &memory->mem;
+            mem->mem_type = DWL_MEM_TYPE_DPB;
+            if (DWLMallocLinear(dwl_inst, mem_size, mem) != DWL_OK) {
+                log_error(NULL, "DWLMallocLinear failed size: %d\n", mem_size);
+                break;
+            }
+            if (mem->virtual_address == NULL) {
+                log_error(NULL, "vir_addr is null\n");
+                break;
+            }
+
+            memory->vir_addr = mem->virtual_address;
+            buffer_ref = av_buffer_create(
+                (uint8_t *)memory, sizeof(*memory), esdec_dwl_output_mempry_free, dwl_inst, AV_BUFFER_FLAG_READONLY);
+            if (!buffer_ref) {
+                esdec_dwl_output_mempry_free(dwl_inst, (uint8_t *)memory);
+                memory = NULL;
+                log_error(NULL, "av_buffer_create failed\n");
+                break;
+            }
+            memory->buffer_ref = buffer_ref;
+            ret = SUCCESS;
+        }
+    } while (0);
+
+    if (ret == FAILURE) {
+        if (memory) {
+            av_free(memory);
+            memory = NULL;
+        }
+        log_error(NULL, "allocate one memory failed\n");
+    }
+
+    return memory;
+}
+
+int esdec_allocate_all_output_memorys(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst, void *dwl_inst) {
+    int ret = SUCCESS;
+    int pp_count;
+    ESOutputMemory *memory;
+    if (!port || !dec_inst || !dwl_inst) {
+        return FAILURE;
+    }
+    pp_count = port->pp_count;
+    log_info(NULL, "port->mem_num: %d, pp_count: %d, mem_size: %d\n", port->mem_num, port->pp_count, port->mem_size);
+
+    for (int i = 0; i < port->mem_num; i++) {
+        memory = esdec_allocate_one_output_memory(dwl_inst, port->mem_size);
+        if (memory) {
+            port->output_mems[i] = memory;
+            memory->port_ref = av_buffer_ref(port->port_ref);
+            if (codec != ES_JPEG) {
+                esdec_output_buffer_fd_split(dwl_inst, dec_inst, memory, pp_count);
+            } else {
+                struct ESDecoderWrapper esdec;
+                esdec.codec = DEC_JPEG;
+                esdec.inst = dec_inst;
+                esdec_output_buffer_fd_split(dwl_inst, &esdec, memory, pp_count);
+            }
+            log_info(NULL, "memory: %d allocate success vir_addr: %p\n", i, memory->vir_addr);
+        } else {
+            ret = FAILURE;
+            break;
+        }
+    }
+
+    if (ret == SUCCESS) {
+        log_info(NULL, "output memorys allocate success\n");
+    } else {
+        log_error(NULL, "output memorys allocate failed\n");
+    }
+
+    return ret;
+}
+
+static int esdec_allocate_more_output_memorys(ESDecCodec codec,
+                                              ESOutputPort *port,
+                                              ESVDecInst dec_inst,
+                                              void *dwl_inst,
+                                              int memory_count) {
+    int ret = SUCCESS;
+    int pp_count;
+    int mem_num;
+    ESOutputMemory *memory;
+
+    if (!port || !dec_inst || !dwl_inst || memory_count <= 0) {
+        return FAILURE;
+    }
+
+    if (port->mem_num + memory_count > port->max_mem_num) {
+        log_error(NULL,
+                  "error!!! maximum buffer limit exceeded mem_num: %d, memory_count: %d, max_mem_num: %d\n",
+                  port->mem_num,
+                  memory_count,
+                  port->max_mem_num);
+        mem_num = port->max_mem_num - port->mem_num;
+    } else {
+        mem_num = memory_count;
+    }
+    pp_count = port->pp_count;
+
+    for (int i = 0; i < mem_num; i++) {
+        memory = esdec_allocate_one_output_memory(dwl_inst, port->mem_size);
+        if (memory) {
+            port->output_mems[port->mem_num] = memory;
+            port->mem_num++;
+            memory->port_ref = av_buffer_ref(port->port_ref);
+            if (codec != ES_JPEG) {
+                esdec_output_buffer_fd_split(dwl_inst, dec_inst, memory, pp_count);
+            } else {
+                struct ESDecoderWrapper esdec;
+                esdec.codec = DEC_JPEG;
+                esdec.inst = dec_inst;
+                esdec_output_buffer_fd_split(dwl_inst, &esdec, memory, pp_count);
+            }
+            log_info(NULL, "memory: %d allocate success vir_addr: %p\n", i, memory->vir_addr);
+        } else {
+            ret = FAILURE;
+            break;
+        }
+    }
+
+    if (ret == SUCCESS) {
+        log_info(NULL, "output memorys allocate success mem_num: %d, memory_count: %d\n", mem_num, memory_count);
+    } else {
+        log_error(NULL, "output memorys allocate failed mem_num: %d, memory_count: %d\n", mem_num, memory_count);
+    }
+
+    return ret;
+}
+
+ESOutputPort *esdec_allocate_output_port(ESDecCodec codec,
+                                         ESVDecInst dec_inst,
+                                         struct AVBufferRef *dwl_ref,
+                                         int pp_count) {
+    int ret = FAILURE;
+    enum DecRet rv;
+    struct DecBufferInfo info = {0};
+    void *dwl_inst;
+    ESOutputPort *port = NULL;
+    int32_t output_buf_num;
+    if (!dec_inst || !dwl_ref || !dwl_ref->data) {
+        log_error(NULL, "dec_inst or dwl_inst is null dec_inst: %p\n", dec_inst);
+        return NULL;
+    }
+
+    DWLmemset(&info, 0, sizeof(info));
+    if (codec != ES_JPEG) {
+        rv = VCDecGetBufferInfo(dec_inst, &info);
+    } else {
+        rv = JpegDecGetBufferInfo(dec_inst, &info);
+    }
+    if (info.buf_to_free.virtual_address != NULL) {
+        log_error(NULL, "need to free buffer rv: %d\n", rv);
+    }
+    log_info(NULL, "output buf_num: %d, next_buf_size: %d\n", info.buf_num, info.next_buf_size);
+    dwl_inst = dwl_ref->data;
+
+    do {
+        if (info.next_buf_size != 0) {
+            if (codec != ES_JPEG) {
+                output_buf_num = info.buf_num;
+            } else {
+                output_buf_num = JPEG_DEFAULT_OUTPUT_MIN_BUFFERS;
+            }
+
+            port = esdec_output_port_create(output_buf_num);
+            if (!port) {
+                log_error(NULL, "esdec_output_port_create failed\n");
+                return NULL;
+            }
+            port->mem_size = info.next_buf_size;
+            port->mem_num = output_buf_num > port->max_mem_num ? port->max_mem_num : output_buf_num;
+            port->pp_count = pp_count;
+            ret = esdec_allocate_all_output_memorys(codec, port, dec_inst, dwl_inst);
+            if (ret == FAILURE) {
+                break;
+            }
+
+            ret = esdec_add_all_output_memorys(codec, port, dec_inst);
+            if (ret == FAILURE) {
+                break;
+            }
+            port->dwl_ref = av_buffer_ref(dwl_ref);
+            port->pp_count = pp_count;
+        }
+    } while (0);
+
+    if (ret == FAILURE) {
+        log_info(NULL, "esdec_allocate_out_port failed\n");
+        esdec_output_port_unref(&port);
+    } else {
+        log_info(NULL, "esdec_allocate_out_port success\n");
+    }
+
+    return port;
+}
+
+int esdec_output_port_change(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst, int pp_count, int new_hdr) {
+    int ret;
+    int free_buf_count = 0;
+    enum DecRet rv;
+    void *dwl_inst;
+    struct DecBufferInfo info = {0};
+    if (!dec_inst || !port || !port->dwl_ref) {
+        log_error(NULL, "dec_inst or dwl_inst is null dec_inst: %p\n", dec_inst);
+        return FAILURE;
+    }
+
+    DWLmemset(&info, 0, sizeof(info));
+    do {
+        if (codec != ES_JPEG) {
+            rv = VCDecGetBufferInfo(dec_inst, &info);
+        } else {
+            rv = JpegDecGetBufferInfo(dec_inst, &info);
+        }
+        if (info.buf_to_free.virtual_address != NULL) {
+            log_info(NULL, "need to free buffer rv: %d, vir_addr: %p\n", rv, info.buf_to_free.virtual_address);
+            free_buf_count++;
+        }
+    } while (info.buf_to_free.virtual_address);
+
+    log_info(NULL,
+             "free_buf_count: %d, port mem_num: %d, pp_count: %d, new pp_count: %d, next_buf_size: %d, buf_num: %d\n",
+             free_buf_count,
+             port->mem_num,
+             port->pp_count,
+             pp_count,
+             info.next_buf_size,
+             info.buf_num);
+    if (free_buf_count == 0 && new_hdr) {
+        free_buf_count = port->mem_num;
+        log_info(NULL, "hevc should be here\n");
+    }
+
+    if (free_buf_count > 0 && free_buf_count != port->mem_num) {
+        log_error(NULL, "free_buf_count error !!!!\n");
+        // TODO
+    }
+    dwl_inst = port->dwl_ref->data;
+
+    if (info.next_buf_size <= 0) {
+        log_error(NULL, "next_buf_size: %d, buf_num: %d\n", info.next_buf_size, info.buf_num);
+        return FAILURE;
+    } else if (free_buf_count > 0) {
+        esdec_output_port_memorys_unref(port);
+        port->mem_num = info.buf_num > port->max_mem_num ? port->max_mem_num : info.buf_num;
+        port->mem_size = info.next_buf_size;
+        port->pp_count = pp_count;
+
+        ret = esdec_allocate_all_output_memorys(codec, port, dec_inst, dwl_inst);
+        if (ret == FAILURE) {
+            log_error(NULL, "esdec_allocate_all_output_memorys failed\n");
+            return ret;
+        }
+        ret = esdec_add_all_output_memorys(codec, port, dec_inst);
+    } else if (free_buf_count == 0) {
+        log_info(NULL, "abort should be here\n");
+        ret = esdec_add_all_output_memorys_until_timeout(codec, port, dec_inst, 100 /*ms*/);
+    } else {
+        log_error(NULL, "free_buf_count: %d\n", free_buf_count);
+    }
+
+    return ret;
+}
+
+int esdec_enlarge_output_port(ESDecCodec codec,
+                              ESOutputPort *port,
+                              void* dec_inst,
+                              struct AVBufferRef *dwl_ref,
+                              int buf_num) {
+    struct DecBufferInfo info = {0};
+    int ret = FAILURE;
+    enum DecRet rv;
+    void *dwl_inst;
+
+    if (!port || !dec_inst || !dwl_ref || !dwl_ref->data) {
+        log_error(NULL, "port dec_inst or dwl_inst is null dec_inst: %p\n", dec_inst);
+        return ret;
+    }
+
+    dwl_inst = dwl_ref->data;
+
+    DWLmemset(&info, 0, sizeof(info));
+    if (codec != ES_JPEG) {
+        rv = VCDecGetBufferInfo(dec_inst, &info);
+    } else {
+        rv = JpegDecGetBufferInfo(dec_inst, &info);
+    }
+
+    do {
+        if (port->mem_size > 0) {
+            ret = esdec_allocate_more_output_memorys(codec,
+                                                     port,
+                                                     dec_inst,
+                                                     dwl_inst,
+                                                     buf_num);
+            if (ret == FAILURE) {
+                break;
+            }
+
+            ret = esdec_add_all_output_memorys_until_timeout(codec, port, dec_inst, 100 /*ms*/);
+            if (ret == FAILURE) {
+                break;
+            }
+        }
+    } while (0);
+
+    if (ret == FAILURE) {
+        log_error(NULL, "esdec_enlarge_out_port failed\n");
+    } else {
+        log_info(NULL, "esdec_allocate_out_port success\n");
+    }
+
+    return ret;
+}
+
+int esdec_consumed_one_output_buffer(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst, OutputBuffer *buffer) {
+    int ret = SUCCESS;
+    enum DecRet rv;
+    JpegDecOutput jpic;
+    if (!port || !dec_inst || !buffer) {
+        log_error(NULL, "port: %p or dec_inst: %p or buffer: %p is null\n", port, dec_inst, buffer);
+        return FAILURE;
+    }
+
+    if (esdec_check_output_buffer(port, buffer) == SUCCESS) {
+        ESOutputMemory *memory = esdec_find_memory_by_vir_addr(port, buffer->vir_addr);
+        if (!memory) {
+            ret = FAILURE;
+            log_error(NULL, "memory is null\n");
+        } else if (memory->is_added) {
+            if (codec != ES_JPEG) {
+                rv = VCDecPictureConsumed(dec_inst, &memory->picture);
+            } else {
+                DWLmemset(&jpic, 0, sizeof(JpegDecOutput));
+                for (int i = 0; i < DEC_MAX_OUT_COUNT;i++) {
+                    jpic.pictures[i].output_picture_y = memory->picture.pictures[i].luma;
+                }
+                rv = JpegDecPictureConsumed(dec_inst, &jpic);
+            }
+            esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_CONSUMED);
+            log_debug(NULL, "VCDecPictureConsumed rv: %d\n", rv);
+        } else if (!memory->is_added) {
+            log_info(NULL, "esdec_add_one_buffer\n");
+            esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_INITED);
+            esdec_add_one_buffer(codec, dec_inst, memory);
+            // TODO
+        }
+    } else {
+        ret = FAILURE;
+        log_error(NULL, "esdec_check_output_buffer failed vir_addr: %p\n", buffer->vir_addr);
+    }
+
+    return ret;
+}
+
+int esdec_wait_picture_consumed_until_timeout(ESDecCodec codec,
+                                              ESVDecInst dec_inst,
+                                              ESOutputPort *port,
+                                              int timeout_ms) {
+    int ret;
+    OutputBuffer buffer;
+    if (!port || !dec_inst || timeout_ms < 0) {
+        return FAILURE;
+    }
+
+    ret = esdec_get_consumed_output_buffer(port->consumed_queue, &buffer, timeout_ms);
+    if (ret == SUCCESS) {
+        esdec_consumed_one_output_buffer(codec, port, dec_inst, &buffer);
+    }
+
+    return ret;
+}
+
+int esdec_wait_all_pictures_consumed_unitl_timeout(ESDecCodec codec,
+                                                   ESVDecInst dec_inst,
+                                                   ESOutputPort *port,
+                                                   int timeout_ms) {
+    int ret;
+    int success_count = 0;
+    do {
+        ret = esdec_wait_picture_consumed_until_timeout(codec, dec_inst, port, timeout_ms);
+        if (ret == SUCCESS) {
+            success_count++;
+        }
+        if (timeout_ms > 0) {
+            timeout_ms = 0;
+        }
+
+    } while (ret == SUCCESS);
+
+    if (ret != AVERROR_EXIT && success_count > 0) {
+        ret = SUCCESS;
+    }
+
+    return ret;
+}
+
+int esdec_wait_release_picture_add_buffer(ESDecCodec codec, ESVDecInst dec_inst, ESOutputPort *port, int timeout_ms) {
+    int ret;
+    OutputBuffer buffer;
+    if (!port || !dec_inst || timeout_ms < 0) {
+        return FAILURE;
+    }
+
+    ret = esdec_get_consumed_output_buffer(port->consumed_queue, &buffer, timeout_ms);
+    if (ret == SUCCESS) {
+        enum DecRet rv;
+        ESOutputMemory *memory = esdec_find_memory_by_vir_addr(port, buffer.vir_addr);
+        if (!memory) {
+            ret = FAILURE;
+            return ret;
+        }
+
+        esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_INITED);
+        rv = esdec_add_one_buffer(codec, dec_inst, memory);
+        if (rv == DEC_OK || rv == DEC_WAITING_FOR_BUFFER) {
+            ret = SUCCESS;
+        } else {
+            ret = FAILURE;
+        }
+    } else if (ret != AVERROR_EXIT) {
+        ret = EAGAIN;
+    }
+
+    return ret;
+}
+
+ESOutputMemory *esdec_find_memory_by_picture(ESOutputPort *port, struct DecPicturePpu *pic) {
+    ESOutputMemory *memory = NULL;
+    uint32_t *vir_addr = NULL;
+    if (!port || !pic) {
+        log_error(NULL, "ctx or out_buffers or picture is null\n");
+        return NULL;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (pic->pictures[i].luma.virtual_address != NULL) {
+            vir_addr = pic->pictures[i].luma.virtual_address;
+            log_debug(NULL, "index: %d, vir_addr: %p\n", i, pic->pictures[i].luma.virtual_address);
+            break;
+        }
+    }
+
+    memory = esdec_find_memory_by_vir_addr(port, vir_addr);
+
+    if (!memory) {
+        log_error(NULL, "find vir_addr failed from picture vir_addr: %p\n", vir_addr);
+        return NULL;
+    }
+
+    return memory;
+}
+
+int esdec_end_stream(ESVDecInst dec_inst) {
+    enum DecRet rv;
+    if (!dec_inst) {
+        log_error(NULL, "dec_inst is null");
+        return FAILURE;
+    }
+
+    rv = VCDecEndOfStream(dec_inst);
+    if (rv == DEC_OK) {
+        log_info(NULL, "esdec_end_stream success\n");
+        return SUCCESS;
+    }
+
+    log_info(NULL, "esdec_end_stream failed rv: %d\n", rv);
+    return FAILURE;
+}
+
+static int esdec_output_buffer_fd_split(void *dwl_inst, void *dec_inst, ESOutputMemory *memory, int pp_count) {
+    int ret = SUCCESS;
+    int dma_fd;
+
+    if (!dwl_inst || !dec_inst || !memory) {
+        log_error(NULL, "dwl_inst: %p, dec_inst: %p, memory: %p\n", dwl_inst, dec_inst, memory);
+        return FAILURE;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        memory->fd[i] = -1;
+    }
+
+    if (ESDecIsSimulation()) {
+        return SUCCESS;
+    }
+
+    dma_fd = ESDecGetDmaBufFd(&memory->mem);
+    if (dma_fd < 0) {
+        log_error(NULL, "dma fd is error dma_fd: %d\n", dma_fd);
+        return FAILURE;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        memory->fd[i] = dma_fd;
+    }
+    log_debug(NULL, "pp_count: %d, dma_fd: %d\n", pp_count, dma_fd);
+
+    if (pp_count == ES_VID_DEC_MAX_OUT_COUNT) {
+        ret = ESDecGetDmaFdSplit(dwl_inst, dec_inst, dma_fd, memory->fd, ES_VID_DEC_MAX_OUT_COUNT);
+    }
+
+    return ret;
+}
+
+void esdec_reset_output_memorys(ESOutputPort *port) {
+    int ret;
+    ESOutputMemory *memory;
+    OutputBuffer buffer;
+    if (!port || !port->consumed_queue) {
+        log_error(NULL, "errnor !! port: %p or consumed_queue is null\n", port);
+        return;
+    }
+
+    for (;;) {
+        ret = esdec_get_consumed_output_buffer(port->consumed_queue, &buffer, 0);
+        if (ret == SUCCESS) {
+            memory = esdec_find_memory_by_vir_addr(port, buffer.vir_addr);
+            if (memory) {
+                esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_INITED);
+            }
+        } else {
+            break;
+        }
+    }
+
+    for (int i = 0; i < port->mem_num; i++) {
+        memory = port->output_mems[i];
+        if (!memory) {
+            log_error(NULL, "memory is null\n");
+            continue;
+        }
+        memory->is_added = FALSE;
+        if (memory->state == OUTPUT_MEMORY_STATE_CONSUMED) {
+            esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_INITED);
+        }
+
+        log_info(
+            NULL, "memory: %d , vir_addr: %p, state: %s\n", i, memory->vir_addr, esdec_str_output_state(memory->state));
+    }
+}
+
+int esdec_add_all_output_memorys_until_timeout(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst, int timeout) {
+    int ret;
+    int is_wait = FALSE;
+    ESOutputMemory *memory;
+    if (!port || port->mem_num <= 0 || !dec_inst) {
+        log_error(NULL, "port: %p, dec_inst: %p\n", port, dec_inst);
+        return FAILURE;
+    }
+    esdec_add_all_output_memorys(codec, port, dec_inst);
+
+    for (int i = 0; i < port->mem_num; i++) {
+        memory = port->output_mems[i];
+        if (!memory->is_added) {
+            is_wait = TRUE;
+            break;
+        }
+    }
+
+    if (is_wait) {
+        for (;;) {
+            ret = esdec_wait_release_picture_add_buffer(codec, dec_inst, port, timeout /*ms*/);
+            if (ret == SUCCESS) {
+                timeout = 0;
+                log_info(NULL, "add buffer ok\n");
+            } else {
+                break;
+            }
+        }
+    }
+
+    return SUCCESS;
+}
diff --git a/libavcodec/esdec_internal.h b/libavcodec/esdec_internal.h
new file mode 100644
index 0000000000..9376bef8a6
--- /dev/null
+++ b/libavcodec/esdec_internal.h
@@ -0,0 +1,47 @@
+#ifndef AVCODEC_ESDEC_INTERNAL_H__
+#define AVCODEC_ESDEC_INTERNAL_H__
+#include "esdec_common.h"
+#include "esdecbuffer.h"
+
+void esdec_dwl_memory_free(void *opaque, uint8_t *data);
+void esdec_picture_consume(void *opaque, uint8_t *data);
+void esdec_dwl_release(void *opaque, uint8_t *data);
+void esdec_stream_buffer_consumed(void *stream, void *p_user_data);
+int esdec_end_stream(ESVDecInst dec_inst);
+
+int es_decode_realloc_input_memory(ESInputPort *port, int size, InputBuffer *buffer);
+ESInputPort *esdec_allocate_input_port(ESDecCodec codec,
+                                       struct AVBufferRef *dwl_ref,
+                                       void *dwl_init,
+                                       int32_t input_buf_num);
+ESOutputPort *esdec_allocate_output_port(ESDecCodec codec,
+                                         ESVDecInst dec_inst,
+                                         struct AVBufferRef *dwl_ref,
+                                         int pp_count);
+int esdec_enlarge_input_port(ESDecCodec codec,
+                             ESInputPort *port,
+                             struct AVBufferRef *dwl_ref,
+                             int32_t buf_num);
+int esdec_enlarge_output_port(ESDecCodec codec,
+                              ESOutputPort *port,
+                              void* dec_inst,
+                              struct AVBufferRef *dwl_ref,
+                              int buf_num);
+
+int esdec_wait_picture_consumed_until_timeout(ESDecCodec codec,
+                                              ESVDecInst dec_inst,
+                                              ESOutputPort *port,
+                                              int timeout_ms);
+int esdec_wait_all_pictures_consumed_unitl_timeout(ESDecCodec codec,
+                                                   ESVDecInst dec_inst,
+                                                   ESOutputPort *port,
+                                                   int timeout_ms);
+ESOutputMemory *esdec_find_memory_by_picture(ESOutputPort *port, struct DecPicturePpu *pic);
+int esdec_allocate_all_output_memorys(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst, void *dwl_inst);
+void esdec_reset_output_memorys(ESOutputPort *port);
+int esdec_consumed_one_output_buffer(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst, OutputBuffer *buffer);
+int esdec_wait_release_picture_add_buffer(ESDecCodec codec, ESVDecInst dec_inst, ESOutputPort *port, int timeout_ms);
+int esdec_output_port_change(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst, int pp_count, int new_hdr);
+int esdec_add_all_output_memorys(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst);
+int esdec_add_all_output_memorys_until_timeout(ESDecCodec codec, ESOutputPort *port, ESVDecInst dec_inst, int timeout);
+#endif
\ No newline at end of file
diff --git a/libavcodec/esdec_wrapper.c b/libavcodec/esdec_wrapper.c
new file mode 100644
index 0000000000..78123913a4
--- /dev/null
+++ b/libavcodec/esdec_wrapper.c
@@ -0,0 +1,102 @@
+#define LOG_TAG "vcdec_wrapper"
+#include <dectypes.h>
+#include <hevcdecapi.h>
+#include <h264decapi.h>
+#include <jpegdecapi.h>
+#include "es_common.h"
+#include "eslog.h"
+#include "esdec_wrapper.h"
+
+int ESDecIsSimulation(void) {
+    int result;
+#ifndef MODEL_SIMULATION
+    result = FALSE;
+#else
+    result = TRUE;
+#endif
+
+    log_info(NULL, "is simulation: %d\n", result);
+    return result;
+}
+
+int ESDecGetDmaBufFd(struct DWLLinearMem *mem) {
+    int fd = -1;
+    if (!mem) {
+        log_error(NULL, "error !!! mem is null\n");
+        return -1;
+    }
+#ifdef SUPPORT_DMA_HEAP
+    if (mem->dma_buf) {
+        fd = mem->dma_buf->dmabuf_fd;
+    } else {
+        fd = -1;
+        log_error(NULL, "dma_buf is null\n");
+    }
+#endif
+    log_info(NULL, "dmabuf_fd: %d\n", fd);
+
+    return fd;
+}
+
+#ifndef MODEL_SIMULATION
+static enum DecRet ESDecGetPPXBufferSize(void *inst, u32 pp_index, u32 *buf_size) {
+    enum DecRet rv;
+    struct ESDecoderWrapper *esdec = (ESDecoderWrapper *)inst;
+    if (!esdec || !esdec->inst || !buf_size) {
+        log_error(NULL, "inst or buf_size is null inst: %p, buf_size: %p\ns", inst, buf_size);
+        return DEC_PARAM_ERROR;
+    }
+
+    if (esdec->codec == DEC_HEVC) {
+        rv = HevcDecGetPPXBufferSize(esdec->inst, pp_index, buf_size);
+    } else if (esdec->codec == DEC_H264_H10P || esdec->codec == DEC_H264) {
+        rv = H264DecGetPPXBufferSize(esdec->inst, pp_index, buf_size);
+    } else if (esdec->codec == DEC_JPEG) {
+        rv = JpegDecGetPPXBufferSize(esdec->inst, pp_index, buf_size);
+    } else {
+        rv = DEC_PARAM_ERROR;
+    }
+
+    log_info(NULL, "rv: %d, pp_index: %d, buf_size: %d\n", rv, pp_index, *buf_size);
+
+    return rv;
+}
+#endif
+
+int ESDecGetDmaFdSplit(void *dwl_inst, void *dec_inst, int dmabuf_fd, int *split_fds, int fd_array_size) {
+    enum DecRet rv;
+    int valid_fd_num = 0;
+    uint32_t buf_size = 0, offset = 0;
+
+    log_info(NULL, "dmabuf_fd: %d, pp_count: %d\n", dmabuf_fd, fd_array_size);
+    if (!split_fds) {
+        return FAILURE;
+    }
+
+    for (int i = 0; i < fd_array_size; i++) {
+        split_fds[i] = -1;
+#ifndef MODEL_SIMULATION
+        rv = ESDecGetPPXBufferSize(dec_inst, i, &buf_size);
+        if (rv == DEC_OK && buf_size > 0) {
+            // split_fds[i] = DWLDmaBufFdSplit(dwl_inst, dmabuf_fd, offset, buf_size);
+            offset += buf_size;
+            if (split_fds[i] < 0) {
+                log_error(NULL, "DWLDmaBufFdSplit failed\n");
+            }
+            else{
+                valid_fd_num++;
+            }
+        }
+        log_info(NULL,
+                 "rv: %d, split_fds[%d]: %d, buf_size: %d, offset: %d, valid_fd_num: %d\n",
+                 rv,
+                 i,
+                 split_fds[i],
+                 buf_size,
+                 offset,
+                 valid_fd_num);
+#endif
+    }
+
+    return SUCCESS;
+}
\ No newline at end of file
diff --git a/libavcodec/esdec_wrapper.h b/libavcodec/esdec_wrapper.h
new file mode 100644
index 0000000000..80c498fcc3
--- /dev/null
+++ b/libavcodec/esdec_wrapper.h
@@ -0,0 +1,13 @@
+#ifndef AVCODEC_ESDEC_WRAPPER_H__
+#define AVCODEC_ESDEC_WRAPPER_H__
+#include <dwl.h>
+typedef struct ESDecoderWrapper {
+    enum DecCodec codec;
+    void *inst;
+} ESDecoderWrapper;
+
+int ESDecIsSimulation(void);
+int ESDecGetDmaBufFd(struct DWLLinearMem *mem);
+int ESDecGetDmaFdSplit(void *dwl_inst, void *dec_inst, int dmabuf_fd, int *split_fds, int pp_count);
+
+#endif
\ No newline at end of file
diff --git a/libavcodec/esdecapi.c b/libavcodec/esdecapi.c
new file mode 100644
index 0000000000..d85084aaab
--- /dev/null
+++ b/libavcodec/esdecapi.c
@@ -0,0 +1,1189 @@
+#define LOG_TAG "esdecapi"
+#include "avcodec.h"
+#include <hevcdecapi.h>
+#include <h264decapi.h>
+#include "vcdecapi.h"
+#include "esdecapi.h"
+#include "es_common.h"
+#include "eslog.h"
+#include "esqueue.h"
+#include "esdecbuffer.h"
+#include "esdec_internal.h"
+#include "esdec_wrapper.h"
+
+#ifdef MODEL_SIMULATION
+#include <deccfg.h>
+extern u32 g_hw_build_id;
+extern u32 g_hw_id;
+extern u32 g_hw_ver;
+#endif
+
+static int esdec_get_next_picture(ESVDECContext *dec_ctx);
+
+static int esdec_reorder_packet_enqueue(ESVDECContext *dec_ctx, ReorderPkt *pkt) {
+    int ret = FAILURE;
+    if (!dec_ctx || !pkt) {
+        return FAILURE;
+    }
+
+    ret = es_reorder_packet_enqueue(dec_ctx->reorder_queue, pkt);
+    return ret;
+}
+
+static int esdec_reorder_pkt_dequeue(ESVDECContext *dec_ctx, int pic_id, struct ReorderPkt *out_pkt) {
+    int ret;
+    if (!dec_ctx || !out_pkt) {
+        return FAILURE;
+    }
+
+    ret = es_reorder_packet_dequeue(dec_ctx->reorder_queue, pic_id, out_pkt);
+    return ret;
+}
+
+static int esdec_reorder_pkt_store(ESVDECContext *dec_ctx, ReorderPkt *pkt) {
+    if (!dec_ctx || !pkt || !dec_ctx->reorder_pkt) {
+        log_error(dec_ctx, "dec_ctx or pkt is null dec_ctx; %p, pkt: %p\n", dec_ctx, pkt);
+        return FAILURE;
+    }
+
+    *dec_ctx->reorder_pkt = *pkt;
+    return SUCCESS;
+}
+
+static int esdec_get_reorder_pkt(ESVDECContext *dec_ctx, int pic_id, struct ReorderPkt *out_pkt) {
+    if (!dec_ctx || !out_pkt || !dec_ctx->reorder_pkt) {
+        log_error(dec_ctx, "dec_ctx  or out_pkt is null dec_ctx: %p, out_pkt; %p\n", dec_ctx, out_pkt);
+        return FAILURE;
+    }
+
+    *out_pkt = *dec_ctx->reorder_pkt;
+    return SUCCESS;
+}
+
+static void esdec_report_decode_info(ESVDECContext *dec_ctx) {
+    struct DecPicturePpu *pic = NULL;
+    struct DecPicture *picture;
+    if (!dec_ctx || !dec_ctx->picture) {
+        log_error(NULL, "esvdec  dec_ctx or picture is null dec_ctx: %p\n", dec_ctx);
+        return;
+    }
+
+    pic = dec_ctx->picture;
+    if (pic) {
+        log_warn(NULL,
+                 "original resolution: %dx%d, %dbit stream, stride_align: %d, output_num: %u, decode_num: %d\n",
+                 dec_ctx->pic_width,
+                 dec_ctx->pic_height,
+                 dec_ctx->bit_depth,
+                 dec_ctx->stride_align,
+                 dec_ctx->pic_output_number,
+                 dec_ctx->pic_display_number);
+        for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+            picture = &pic->pictures[i];
+            if (picture->luma.virtual_address) {
+                log_warn(NULL,
+                         "pp%d resolution: %dx%d, pic_stride: %d, pixpmt: %s, target_pp: %s\n",
+                         i,
+                         picture->pic_width,
+                         picture->pic_height,
+                         picture->pic_stride,
+                         ff_codec_decfmt_to_char(picture->picture_info.format),
+                         esdec_get_ppout_enable(dec_ctx->target_pp, i));
+            }
+        }
+    }
+}
+
+static int esdec_set_init_params(ESVDECContext *dec_ctx, ESDecCodec codec) {
+    struct DecInitConfig *config;
+    struct DWLInitParam dwl_params = {DWL_CLIENT_TYPE_HEVC_DEC};
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dec_ctx is null\n");
+        return FAILURE;
+    }
+
+#ifdef MODEL_SIMULATION
+    g_hw_build_id = 0x1FB2;
+    g_hw_ver = 19001;
+    g_hw_id = 1000;
+#endif
+
+    config = &dec_ctx->init_config;
+    memset(config, 0, sizeof(struct DecInitConfig));
+
+    dec_ctx->codec = codec;
+    if (codec == ES_H264_H10P) {
+        config->mvc = 0;
+        config->rlc_mode = 0;
+        config->mc_cfg.mc_enable = 0;
+        if (config->mc_cfg.mc_enable) {
+            config->mc_cfg.stream_consumed_callback = esdec_stream_buffer_consumed;
+        }
+        config->codec = DEC_H264_H10P;
+        dwl_params.client_type = DWL_CLIENT_TYPE_H264_DEC;
+    } else if (codec == ES_HEVC) {
+        config->mc_cfg.mc_enable = 0;
+        if (config->mc_cfg.mc_enable) {
+            config->mc_cfg.stream_consumed_callback = esdec_stream_buffer_consumed;
+        }
+        config->codec = DEC_HEVC;
+        dwl_params.client_type = DWL_CLIENT_TYPE_HEVC_DEC;
+    } else {
+        log_error(dec_ctx, "not support codec: %d\n", codec);
+        return FAILURE;
+    }
+
+    config->full_stream_mode = 0;
+    config->disable_picture_reordering = 0;
+    config->use_ringbuffer = 0;
+    config->use_video_compressor = 0;
+    config->decoder_mode = DEC_NORMAL;  // DEC_INTRA_ONLY or DEC_NORMAL;
+    config->num_frame_buffers = 0;
+    config->auxinfo = 0;
+
+#ifdef USE_EXTERNAL_BUFFER
+    config->guard_size = dec_ctx->extra_hw_frames;
+    config->use_adaptive_buffers = 1;
+#endif
+    config->dwl_inst = DWLInit(&dwl_params);
+    if (!config->dwl_inst) {
+        log_error(dec_ctx, "DWLInit failed\n");
+        return FAILURE;
+    }
+    dec_ctx->dwl_inst = config->dwl_inst;
+    dec_ctx->dwl_ref = av_buffer_create(
+        (uint8_t *)dec_ctx->dwl_inst, sizeof(dec_ctx->dwl_inst), esdec_dwl_release, NULL, AV_BUFFER_FLAG_READONLY);
+    if (!dec_ctx->dwl_ref) {
+        esdec_dwl_release(NULL, dec_ctx->dwl_inst);
+        dec_ctx->dwl_inst = NULL;
+        log_error(dec_ctx, "av_buffer_create dwl ref failed\n");
+        return FAILURE;
+    }
+
+    if (config->decoder_mode == DEC_INTRA_ONLY || config->disable_picture_reordering) {
+        dec_ctx->reorder_pkt = (ReorderPkt *)av_mallocz(sizeof(*dec_ctx->reorder_pkt));
+        if (!dec_ctx->reorder_pkt) {
+            log_error(dec_ctx, "reorder_pkt malloc failed\n");
+            return FAILURE;
+        }
+        dec_ctx->store_reorder_pkt = esdec_reorder_pkt_store;
+        dec_ctx->get_reorder_pkt_by_pic_id = esdec_get_reorder_pkt;
+
+    } else {
+        dec_ctx->reorder_queue = es_queue_create();
+        if (!dec_ctx->reorder_queue) {
+            log_error(dec_ctx, "reorder_queue create failed\n");
+            return FAILURE;
+        }
+        dec_ctx->store_reorder_pkt = esdec_reorder_packet_enqueue;
+        dec_ctx->get_reorder_pkt_by_pic_id = esdec_reorder_pkt_dequeue;
+    }
+
+    dec_ctx->frame = av_frame_alloc();
+    if (!dec_ctx->frame) {
+        log_error(dec_ctx, "av_frame_alloc failed\n");
+        return FAILURE;
+    }
+
+    dec_ctx->dump_pkt_handle = NULL;
+    for (int i = 0; i < 2; i++) {
+        dec_ctx->dump_frm_handle[i] = NULL;
+    }
+
+    log_info(dec_ctx, "esdec_set_init_params success dwl_inst: %p\n", dec_ctx->dwl_inst);
+    return SUCCESS;
+}
+
+static void esdec_parse_pp_config(ESVDECContext *dec_ctx, struct DecConfig *config) {
+    PpUnitConfig *ppu_cfg = NULL;
+    if (!dec_ctx || !config) {
+        log_error(dec_ctx, "dec_ctx or config is null dec_ctx: %p, config: %p\n", dec_ctx, config);
+        return;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        CropInfo crop = {0};
+        ScaleInfo scale = {0};
+
+        ppu_cfg = &config->ppu_cfg[i];
+        ppu_cfg->enabled = dec_ctx->pp_enabled[i];
+        if (!ppu_cfg->enabled) {
+            log_info(dec_ctx, "pp%d disabled\n", i);
+            continue;
+        } else {
+            log_info(dec_ctx, "pp%d enabled\n", i);
+        }
+
+        if (dec_ctx->crop[i]) {
+            log_info(dec_ctx, "i: %d, crop: %s\n", i, dec_ctx->crop[i]);
+        }
+
+        if (es_codec_get_crop(dec_ctx->crop[i], &crop) == 0) {
+            if (crop.crop_xoffset >= 0 && crop.crop_yoffset >= 0 && crop.crop_height > 0 && crop.crop_width > 0) {
+                ppu_cfg->crop.enabled = 1;
+                ppu_cfg->crop.set_by_user = 1;
+                ppu_cfg->crop.x = crop.crop_xoffset;
+                ppu_cfg->crop.y = crop.crop_yoffset;
+                ppu_cfg->crop.width = crop.crop_width;
+                ppu_cfg->crop.height = crop.crop_height;
+            }
+            log_info(dec_ctx,
+                     "crop index: %d, enabled: %d, cx: %d, cy: %d, cw: %d, ch: %d\n",
+                     i,
+                     ppu_cfg->crop.enabled,
+                     crop.crop_xoffset,
+                     crop.crop_yoffset,
+                     crop.crop_width,
+                     crop.crop_height);
+        }
+
+        if (i == 1 && (es_codec_get_scale(dec_ctx->scale, &scale) == 0)) {
+            if ((scale.scale_height == 0 && scale.scale_width == 0)
+                || (scale.scale_height == -1 && scale.scale_width == -1)) {
+                ppu_cfg->scale.enabled = 0;
+            } else {
+                ppu_cfg->scale.enabled = 1;
+                if (scale.scale_width <= -2 && scale.scale_height <= -2) {
+                    ppu_cfg->scale.scale_by_ratio = 1;
+                    ppu_cfg->scale.ratio_x = -scale.scale_width;
+                    ppu_cfg->scale.ratio_y = -scale.scale_height;
+                } else {
+                    ppu_cfg->scale.width = scale.scale_width;
+                    ppu_cfg->scale.height = scale.scale_height;
+                }
+            }
+
+            log_info(dec_ctx,
+                     "scale index: %d, enabled: %d, scale_width: %d, scale_height: %d\n",
+                     i,
+                     ppu_cfg->scale.enabled,
+                     scale.scale_width,
+                     scale.scale_height);
+        }
+    }
+}
+
+static void esdec_set_dec_params(ESVDECContext *dec_ctx) {
+    struct DecConfig *dec_config = NULL;
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dec_ctx is null\n");
+        return;
+    }
+    dec_config = &dec_ctx->dec_config;
+    memset(dec_config, 0, sizeof(struct DecConfig));
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        PpUnitConfig *ppu_cfg = &dec_config->ppu_cfg[i];
+        ppu_cfg->pp_filter = 1;
+        ppu_cfg->video_range = 1;
+        ppu_cfg->x_filter_param = 2;
+        ppu_cfg->y_filter_param = 2;
+    }
+
+    dec_config->hw_conceal = dec_ctx->hw_conceal = 1;
+    dec_config->disable_slice = dec_ctx->disable_slice = 0;
+    dec_config->align = esdec_get_align(dec_ctx->stride_align);
+
+    log_info(dec_ctx, "dec_config->align: %d\n", dec_config->align);
+    // TODO config->delogo_params
+
+    esdec_parse_pp_config(dec_ctx, dec_config);
+}
+
+static int es_decode_set_pkt_dump_params(ESVDECContext *dec_ctx) {
+    DumpParas paras;
+    if (dec_ctx->packet_dump && !dec_ctx->dump_pkt_handle) {
+        paras.width = dec_ctx->pic_width;
+        paras.height = dec_ctx->pic_height;
+        paras.pic_stride = 0;
+        paras.pic_stride_ch = 0;
+        paras.prefix_name = "vdec";
+        if (dec_ctx->codec == ES_HEVC)
+            paras.suffix_name = "hevc";
+        else if (dec_ctx->codec == ES_H264_H10P)
+            paras.suffix_name = "h264_h10p";
+        else
+            paras.suffix_name = "h264";
+        paras.fmt = NULL;
+        dec_ctx->dump_pkt_handle = ff_codec_dump_file_open(dec_ctx->dump_path, dec_ctx->packet_dump_time, &paras);
+    } else {
+        log_info(dec_ctx, "packet_dump disable\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int es_decode_set_frame_dump_params(ESVDECContext *dec_ctx, struct DecPicturePpu *pic) {
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (dec_ctx->pp_enabled[i] && dec_ctx->frame_dump[i] && !dec_ctx->dump_frm_handle[i]) {
+            DumpParas paras;
+            paras.width = pic->pictures[i].pic_width;
+            paras.height = pic->pictures[i].pic_height;
+            paras.pic_stride = pic->pictures[i].pic_stride;
+            paras.pic_stride_ch = pic->pictures[i].pic_stride_ch;
+            paras.prefix_name = "vdec";
+
+            if (i == 0)
+                paras.ppu_channel = "pp0";
+            else
+                paras.ppu_channel = "pp01";
+
+            if (IS_PIC_RGB_FMT(pic->pictures[i].picture_info.format))
+                paras.suffix_name = "rgb";
+            else
+                paras.suffix_name = "yuv";
+
+            paras.fmt = ff_codec_decfmt_to_char(pic->pictures[i].picture_info.format);
+
+            dec_ctx->dump_frm_handle[i] =
+                ff_codec_dump_file_open(dec_ctx->dump_path, dec_ctx->frame_dump_time[i], &paras);
+        }
+    }
+
+    return 0;
+}
+
+static int es_decode_frame_dump(ESVDECContext *dec_ctx, struct DecPicturePpu *pic) {
+    int ret = 0;
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (dec_ctx->pp_enabled[i] && dec_ctx->frame_dump[i] && dec_ctx->dump_frm_handle[i]) {
+            if (dec_ctx->dump_frm_handle[i]->fp) {
+                ret = ff_codec_dump_data_to_file_by_decpicture(&(pic->pictures[i]), dec_ctx->dump_frm_handle[i]);
+                if (ret == ERR_TIMEOUT) {
+                    av_log(NULL, AV_LOG_INFO, "frame dump timeout\n");
+                    ff_codec_dump_file_close(&dec_ctx->dump_frm_handle[i]);
+                    dec_ctx->frame_dump[i] = 0;
+                    return 0;
+                } else if (ret < 0) {
+                    av_log(NULL, AV_LOG_ERROR, "write file error\n");
+                    return -1;
+                }
+            } else {
+                av_log(NULL, AV_LOG_ERROR, "fp is not inited\n");
+                return -1;
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int es_decode_pkt_dump(ESVDECContext *dec_ctx, void *data, int size) {
+    int ret = 0;
+    if (dec_ctx->packet_dump) {
+        if (dec_ctx->dump_pkt_handle) {
+            ret = ff_codec_dump_bytes_to_file(data, size, dec_ctx->dump_pkt_handle);
+            if (ret == ERR_TIMEOUT) {
+                av_log(NULL, AV_LOG_INFO, "pkt dump timeout\n");
+                ff_codec_dump_file_close(&dec_ctx->dump_pkt_handle);
+                dec_ctx->packet_dump = 0;
+                return 0;
+            } else if (ret < 0) {
+                av_log(NULL, AV_LOG_ERROR, "write frame into file failed\n");
+                return -1;
+            }
+        }
+    }
+
+    return 0;
+}
+
+int es_decode_set_params(ESVDECContext *dec_ctx, ESDecCodec codec) {
+    int ret = FAILURE;
+    struct DecInitConfig *config;
+    if (!dec_ctx) {
+        log_error(dec_ctx, "avctx is null\n");
+        return FAILURE;
+    }
+
+    config = &dec_ctx->init_config;
+    memset(config, 0, sizeof(struct DecInitConfig));
+
+    ret = esdec_set_init_params(dec_ctx, codec);
+    if (ret == FAILURE) {
+        return ret;
+    }
+    esdec_set_dec_params(dec_ctx);
+
+    es_decode_set_pkt_dump_params(dec_ctx);
+
+    log_info(dec_ctx, "codec: %d set_decoder_params success\n", codec);
+    return SUCCESS;
+}
+
+int es_decode_init(ESVDECContext *dec_ctx) {
+    enum DecRet rv;
+    int ret = FAILURE;
+    ESInputPort *port;
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dec_ctx is null\n");
+        return FAILURE;
+    }
+
+    rv = VCDecInit((const void **)&dec_ctx->dec_inst, &dec_ctx->init_config);
+    if (rv == DEC_OK) {
+        log_info(dec_ctx, "VCDecInit success\n");
+    } else {
+        log_error(dec_ctx, "VCDecInit failed\n");
+        return ret;
+    }
+
+    port = esdec_allocate_input_port(dec_ctx->codec, dec_ctx->dwl_ref, NULL, dec_ctx->input_buf_num);
+    if (port) {
+        dec_ctx->input_port = port;
+        ret = SUCCESS;
+    } else {
+        log_error(dec_ctx, "es_decode_allocate_input_port failed\n");
+    }
+
+    return ret;
+}
+
+static int esdec_modify_config_by_sequence_info(ESVDECContext *dec_ctx) {
+    int ret = FAILURE;
+    enum DecRet rv;
+    int dec_crop_enable = 0;
+    struct DecConfig *config;
+    struct DecSequenceInfo sequence_info = {0};
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dectx is null\n");
+        return FAILURE;
+    }
+
+    rv = VCDecGetInfo(dec_ctx->dec_inst, &sequence_info);
+    if (rv != DEC_OK) {
+        log_error(dec_ctx, "VCDecGetInfo failed\n");
+        return FAILURE;
+    }
+    if (sequence_info.h264_base_mode == 1) {
+        dec_ctx->init_config.use_ringbuffer = 0;
+        dec_ctx->init_config.mc_cfg.mc_enable = 0;
+        dec_ctx->init_config.mc_cfg.stream_consumed_callback = NULL;
+    }
+
+    dec_ctx->bit_depth = sequence_info.bit_depth_luma;
+
+    if (sequence_info.crop_params.crop_left_offset != 0 || sequence_info.crop_params.crop_top_offset != 0
+        || (sequence_info.crop_params.crop_out_width != sequence_info.pic_width
+            && sequence_info.crop_params.crop_out_width != 0)
+        || (sequence_info.crop_params.crop_out_height != sequence_info.pic_height
+            && sequence_info.crop_params.crop_out_height != 0)) {
+        dec_crop_enable = 1;
+    }
+
+    log_info(dec_ctx,
+             "pic_width: %d, pic_height: %d, dec_crop_enable: %d, bit_depth: %d\n",
+             sequence_info.pic_width,
+             sequence_info.pic_height,
+             dec_crop_enable,
+             dec_ctx->bit_depth);
+
+    config = &dec_ctx->dec_config;
+    dec_ctx->pp_count = 0;
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        PpUnitConfig *ppu_cfg = &config->ppu_cfg[i];
+        uint32_t original_width = sequence_info.pic_width;
+        uint32_t original_height = sequence_info.pic_height;
+
+        if (!ppu_cfg->enabled) {
+            continue;
+        }
+        dec_ctx->pp_count++;
+
+        if (dec_crop_enable) {
+            original_width = (sequence_info.crop_params.crop_out_width + 1) & ~0x1;
+            original_height = (sequence_info.crop_params.crop_out_height + 1) & ~0x1;
+            if (!ppu_cfg->crop.enabled) {
+                ppu_cfg->crop.x = sequence_info.crop_params.crop_left_offset;
+                ppu_cfg->crop.y = sequence_info.crop_params.crop_top_offset;
+                ppu_cfg->crop.width = original_width;
+                ppu_cfg->crop.height = original_height;
+            } else {
+                ppu_cfg->crop.x += sequence_info.crop_params.crop_left_offset;
+                ppu_cfg->crop.y += sequence_info.crop_params.crop_top_offset;
+            }
+            ppu_cfg->crop.enabled = 1;
+
+            log_info(dec_ctx,
+                     "crop index: %d, enabled: %d, cx: %d, cy: %d, cw: %d, ch: %d\n",
+                     i,
+                     ppu_cfg->crop.enabled,
+                     ppu_cfg->crop.x,
+                     ppu_cfg->crop.y,
+                     ppu_cfg->crop.width,
+                     ppu_cfg->crop.height);
+        }
+
+        dec_ctx->pic_width = original_width;
+        dec_ctx->pic_height = original_height;
+
+        if (ppu_cfg->crop.enabled) {
+            if (ppu_cfg->crop.width > original_width || ppu_cfg->crop.width < 48
+                || ppu_cfg->crop.height > original_height || ppu_cfg->crop.height < 48) {
+                ppu_cfg->crop.enabled = 0;
+            } else {
+                original_width = ppu_cfg->crop.width;
+                original_height = ppu_cfg->crop.height;
+            }
+        }
+
+        if (ppu_cfg->scale.enabled) {
+            if (ppu_cfg->scale.width == -1 && ppu_cfg->scale.height > 0) {
+                ppu_cfg->scale.width = (original_width * ppu_cfg->crop.height / original_height) & ~0x1;
+            }
+            if (ppu_cfg->scale.height == -1 && ppu_cfg->scale.width > 0) {
+                ppu_cfg->scale.height = (original_height * ppu_cfg->crop.width / original_width) & ~0x1;
+            }
+
+            if (ppu_cfg->scale.width > original_width || ppu_cfg->scale.height > original_height) {
+                ppu_cfg->scale.enabled = 0;
+            }
+        }
+        log_info(dec_ctx,
+                 "i: %d, crop enable: %d, scale enable: %d, width: %d, height: %d\n",
+                 i,
+                 ppu_cfg->crop.enabled,
+                 ppu_cfg->scale.enabled,
+                 ppu_cfg->scale.width,
+                 ppu_cfg->scale.height);
+
+        ff_esdec_set_ppu_output_pixfmt(dec_ctx->bit_depth == 8, dec_ctx->pp_fmt[i], ppu_cfg);
+
+        // es_decode_set_pkt_dump_params(dec_ctx);
+    }
+
+    rv = VCDecSetInfo(dec_ctx->dec_inst, config);
+    if (rv != DEC_OK) {
+        ret = FAILURE;
+        log_error(dec_ctx, "VCDecSetInfo failed\n");
+    } else {
+        ret = SUCCESS;
+        log_info(dec_ctx, "VCDecSetInfo success ppu_count: %d\n", dec_ctx->pp_count);
+    }
+
+    return ret;
+}
+
+static int esdec_decode(ESVDECContext *dec_ctx, InputBuffer *input_buffer, int *peek_frame) {
+    int ret = SUCCESS;
+    enum DecRet rv;
+    int new_hdr = FALSE;
+    ReorderPkt reorder_pkt;
+    struct DWLLinearMem *buffer = NULL;
+    struct DecInputParameters input_param;
+    struct DecOutput dec_out = {0};
+
+    if (!dec_ctx || !input_buffer || !peek_frame) {
+        log_error(dec_ctx, "error dec_ctx: %p, buffer: %p\n", dec_ctx, input_buffer);
+        return FAILURE;
+    }
+    *peek_frame = 0;
+    log_debug(dec_ctx, "input_buffer->size: %d\n", input_buffer->size);
+
+    reorder_pkt.pts = input_buffer->pts;
+    reorder_pkt.reordered_opaque = input_buffer->reordered_opaque;
+
+    dec_out.buff_size = input_buffer->max_size;
+    dec_out.data_left = input_buffer->size;
+    dec_out.strm_curr_pos = dec_out.strm_buff = (uint8_t *)input_buffer->vir_addr;
+    dec_out.strm_buff_bus_address = input_buffer->bus_address;
+
+    DWLmemset(&input_param, 0, sizeof(struct DecInputParameters));
+    buffer = &input_param.stream_buffer;
+
+    // dump packet
+    es_decode_pkt_dump(dec_ctx, (void *)input_buffer->vir_addr, input_buffer->size);
+
+    do {
+        buffer->virtual_address = (uint32_t *)dec_out.strm_buff;
+        buffer->bus_address = dec_out.strm_buff_bus_address;
+        buffer->size = dec_out.buff_size;
+        input_param.p_user_data = (void *)dec_ctx->input_port;
+        input_param.stream = dec_out.strm_curr_pos;
+        input_param.strm_len = dec_out.data_left;
+        input_param.pic_id = dec_ctx->pic_decode_number;
+        // input_param.sei_buffer = dec.sei_buffer; TODO
+
+        rv = VCDecDecode(dec_ctx->dec_inst, &dec_out, &input_param);
+        if (rv == DEC_HDRS_RDY) {
+            new_hdr = TRUE;
+            ret = esdec_modify_config_by_sequence_info(dec_ctx);
+            if (ret < 0) {
+                break;
+            }
+            if (dec_out.data_left <= 0) {
+                break;
+            }
+        } else if (rv == DEC_WAITING_FOR_BUFFER) {
+            if (!dec_ctx->output_port) {
+                dec_ctx->output_port =
+                    esdec_allocate_output_port(dec_ctx->codec, dec_ctx->dec_inst, dec_ctx->dwl_ref, dec_ctx->pp_count);
+            } else {
+                ret = esdec_output_port_change(dec_ctx->codec,
+                                               dec_ctx->output_port,
+                                               dec_ctx->dec_inst,
+                                               dec_ctx->pp_count, new_hdr);
+            }
+            if (new_hdr) {
+                new_hdr = FALSE;
+            }
+        } else if (rv == DEC_NO_DECODING_BUFFER) {
+            ret = esdec_wait_all_pictures_consumed_unitl_timeout(dec_ctx->codec,
+                                                                 dec_ctx->dec_inst,
+                                                                 dec_ctx->output_port,
+                                                                 20 /*ms*/);
+            if (ret == AVERROR_EXIT) {
+                break;
+            }
+        } else if (rv == DEC_ADVANCED_TOOLS && dec_ctx->init_config.mc_cfg.mc_enable) {
+            log_error(dec_ctx, "detected and not supported in multicore mode\n");
+            break;
+        } else if (rv == DEC_PIC_DECODED) {
+            reorder_pkt.pic_id = dec_ctx->pic_decode_number;
+            if (dec_ctx->store_reorder_pkt) {
+                dec_ctx->store_reorder_pkt(dec_ctx, &reorder_pkt);
+            }
+            dec_ctx->pic_decode_number += 1;
+            *peek_frame = 1;
+            log_debug(dec_ctx, "pic_decode_number: %u\n", dec_ctx->pic_decode_number);
+        } else if (rv == DEC_PENDING_FLUSH) {
+            log_info(dec_ctx, "dec get all next pictures\n");
+            do {
+                ret = esdec_get_next_picture(dec_ctx);
+                log_info(dec_ctx, "esdec_get_next_picture ret: %d\n", ret);
+            } while (ret != FAILURE);
+            log_info(NULL, "pending flush end\n");
+        } else if (rv == DEC_ABORTED) {
+            rv = VCDecAbortAfter(dec_ctx->dec_inst);
+            log_info(dec_ctx, "VCDecAbortAfter rv: %d\n", rv);
+            esdec_reset_output_memorys(dec_ctx->output_port);
+            if (new_hdr) {
+                new_hdr = FALSE;
+            }
+        } else if (rv < 0) {
+            break;
+        }
+
+        esdec_timed_printf_memory_state(dec_ctx->output_port);
+
+    } while (dec_out.data_left > 0);
+
+    return ret;
+}
+
+static int ff_esdec_fill_frame_prop(ESVDECContext *dec_ctx, OutputBuffer *buffer, AVFrame *frame) {
+    int ret = SUCCESS;
+    DecPicturePri *pri_pic;
+    OutPutInfo *info;
+    uint64_t dma_fd;
+    ESOutputMemory *memory;
+    if (!dec_ctx || !buffer || !buffer->memory || !frame) {
+        return FAILURE;
+    }
+
+    memory = buffer->memory;
+    pri_pic = &memory->pic_pri;
+    info = pri_pic->default_pic;
+
+    frame->format = info->format;
+    frame->width = info->width;
+    frame->height = info->height;
+    frame->key_frame = info->key_frame;
+    frame->pts = buffer->pts;
+    frame->reordered_opaque = buffer->reordered_opaque;
+    for (int i = 0; i < info->n_planes; i++) {
+        frame->data[i] = (uint8_t *)info->virtual_address + info->offset[i];
+        frame->linesize[i] = info->stride[i];
+    }
+    if (ESDecIsSimulation()) {
+        dma_fd = (uint64_t)info->virtual_address;
+    } else {
+        dma_fd = (uint64_t)info->fd;
+    }
+    ff_es_codec_add_fd_to_side_data(frame, dma_fd);
+
+    frame->buf[0] = av_buffer_create(
+        (uint8_t *)pri_pic, sizeof(*pri_pic), esdec_picture_consume, dec_ctx->output_port, AV_BUFFER_FLAG_READONLY);
+    if (!frame->buf[0]) {
+        ret = FAILURE;
+        log_error(dec_ctx, "av_buffer_create frame[0] failed\n");
+    }
+
+    return ret;
+}
+
+static int esdec_drop_frame(ESVDECContext *dec_ctx, OutputBuffer *buffer, AVFrame *frame) {
+    int ret = FAILURE;
+    ESOutputPort *port;
+    if (!dec_ctx || !dec_ctx->output_port || !frame || !buffer) {
+        log_error(dec_ctx, "dec_ctx or frame or ppu is null\n");
+        return FAILURE;
+    }
+    port = dec_ctx->output_port;
+
+    frame->width = dec_ctx->pic_width;
+    frame->height = dec_ctx->pic_height;
+    frame->pts = buffer->pts;
+    frame->reordered_opaque = buffer->reordered_opaque;
+    frame->buf[0] = av_buffer_create(NULL, 0, NULL, dec_ctx, AV_BUFFER_FLAG_READONLY);
+    frame->flags |= AV_FRAME_FLAG_DISCARD;
+
+    esdec_release_buffer_to_consume_queue(port->consumed_queue, buffer);
+
+    return ret;
+}
+
+static int esdec_check_discard_frame(uint32_t decode_num, int32_t drop_frame_interval) {
+    int ret = FALSE;
+    if (drop_frame_interval > 0) {
+        ret = decode_num % drop_frame_interval ? TRUE : FALSE;
+    }
+    return ret;
+}
+
+static int esdec_fill_output_info(ESVDECContext *dec_ctx, struct DecPicturePpu *pic) {
+    int ret = SUCCESS;
+    int index = FAILURE;
+    OutputBuffer *buffer = NULL;
+    ESOutputMemory *memory;
+    DecPicturePri *pri_pic = NULL;
+    ESOutputPort *port;
+    if (!dec_ctx || !pic || !dec_ctx->output_port) {
+        log_error(dec_ctx, "error !!! dec_ctx: %p, pic: %p\n", dec_ctx, pic);
+        return FAILURE;
+    }
+    port = dec_ctx->output_port;
+
+    // dump frame
+    es_decode_frame_dump(dec_ctx, pic);
+
+    memory = esdec_find_memory_by_picture(port, pic);
+    if (!memory) {
+        log_error(dec_ctx, "esdec_find_memory_index_by_picture failed\n");
+        return FAILURE;
+    } else {
+        log_debug(
+            dec_ctx, "find memory vir_addr: %p, state: %s\n", memory->vir_addr, esdec_str_output_state(memory->state));
+    }
+
+    buffer = &memory->buffer;
+    buffer->memory = memory;
+    buffer->vir_addr = memory->vir_addr;
+    buffer->buffer_ref = av_buffer_ref(memory->buffer_ref);
+    buffer->port_ref = av_buffer_ref(memory->port_ref);
+
+    memory->picture = *pic;
+    pri_pic = &memory->pic_pri;
+    pri_pic->hwpic = (void *)buffer;
+
+    pri_pic->stride_align = dec_ctx->stride_align;
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (pic->pictures[i].luma.virtual_address != NULL) {
+            pri_pic->pic_count++;
+            pri_pic->pictures[i].fd = memory->fd[i];
+            esdec_fill_planes(&pri_pic->pictures[i], &pic->pictures[i]);
+            if (i == dec_ctx->target_pp) {
+                pri_pic->default_index = i;
+                pri_pic->default_pic = &pri_pic->pictures[i];
+            } else if (index == -1) {
+                index = i;
+            }
+            log_debug(dec_ctx, "index: %d, vir_addr: %p\n", i, pic->pictures[i].luma.virtual_address);
+        } else if (pri_pic->pictures[i].enabled) {
+            pri_pic->pictures[i].enabled = FALSE;
+        }
+    }
+
+    if (pri_pic->pic_count > 0) {
+        uint32_t pic_id;
+        ReorderPkt pkt;
+        if (!pri_pic->default_pic) {
+            pri_pic->default_index = index;
+            pri_pic->default_pic = &pri_pic->pictures[index];
+            log_info(dec_ctx, "DEFAULT_INDEX: %d, real pic_index: %d\n", dec_ctx->target_pp, index);
+            dec_ctx->target_pp = index;
+        }
+
+        pic_id = pic->pictures[pri_pic->default_index].picture_info.pic_id;
+        if (dec_ctx->get_reorder_pkt_by_pic_id) {
+            int ret = dec_ctx->get_reorder_pkt_by_pic_id(dec_ctx, pic_id, &pkt);
+            if (ret == SUCCESS) {
+                buffer->pts = pkt.pts;
+                buffer->reordered_opaque = pkt.reordered_opaque;
+            } else {
+                log_error(dec_ctx, "get reorder pkt failed pic_id: %d\n", pic_id);
+            }
+        }
+
+        if (!dec_ctx->picture) {
+            dec_ctx->picture = av_mallocz(sizeof(*dec_ctx->picture));
+            if (!dec_ctx->picture) {
+                log_error(dec_ctx, "av_malloc picture fialed\n");
+            } else {
+                *dec_ctx->picture = *pic;
+            }
+        }
+
+        esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_FRAME_QUEUE);
+        ret = esdec_push_frame_output_buffer(port->frame_queue, buffer);
+        if (ret == FAILURE) {
+            esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_ERROR);
+            log_error(dec_ctx, "esdec_push_frame_output_buffer failed vir_addr: %p\n", buffer->vir_addr);
+        } else {
+            log_debug(dec_ctx, "esdec_push_frame_output_buffer vir_addr: %p\n", memory->vir_addr);
+        }
+    } else {
+        log_error(dec_ctx, "no picture\n");
+        return FAILURE;
+    }
+
+    if (ret == FAILURE) {
+        av_buffer_unref(&buffer->port_ref);
+        av_buffer_unref(&buffer->buffer_ref);
+    }
+
+    return ret;
+}
+
+static int esdec_get_next_picture(ESVDECContext *dec_ctx) {
+    int ret;
+    enum DecRet rv;
+    struct DecPicturePpu pic;
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dec_ctx is null\n");
+        return FAILURE;
+    }
+
+    rv = VCDecNextPicture(dec_ctx->dec_inst, &pic);
+    if (rv == DEC_PIC_RDY) {
+        es_decode_set_frame_dump_params(dec_ctx, &pic);
+        ret = esdec_fill_output_info(dec_ctx, &pic);
+        if (ret == FAILURE) {
+            ESOutputMemory *memory;
+            memory = esdec_find_memory_by_picture(dec_ctx->output_port, &pic);
+            if (memory) {
+                esdec_release_buffer_to_consume_queue(dec_ctx->output_port->consumed_queue, &memory->buffer);
+            } else {
+                VCDecPictureConsumed(dec_ctx->dec_inst, &pic);
+            }
+            log_error(dec_ctx, "fill output info failed\n");
+        }
+    } else {
+        log_debug(dec_ctx, "VCDecNextPicture rv: %d\n", rv);
+        ret = FAILURE;
+    }
+
+    return ret;
+}
+
+void es_decode_print_version_info(ESVDECContext *dec_ctx) {
+    uint32_t n_cores;
+    struct DecApiVersion dec_api;
+    struct DecSwHwBuild dec_build;
+#ifdef MODEL_SIMULATION
+    // TODO solve compilation problem
+    if (dec_ctx) {
+        dec_build = HevcDecGetBuild();
+    } else {
+        dec_build = H264DecGetBuild();
+    }
+#else
+    dec_build = VCDecGetBuild(DWL_CLIENT_TYPE_HEVC_DEC);
+#endif
+
+    dec_api = VCDecGetAPIVersion();
+    dec_build = VCDecGetBuild(DWL_CLIENT_TYPE_HEVC_DEC);
+    n_cores = VCDecMCGetCoreCount();
+
+    log_info(dec_ctx,
+             "Decoder API v%d.%d - SW build: %d.%d - HW build: 0x%x, %d cores\n",
+             dec_api.major,
+             dec_api.minor,
+             dec_build.sw_build >> 16,
+             dec_build.sw_build & 0xFFFF,
+             dec_build.hw_build,
+             n_cores);
+}
+
+int es_decode_send_packet(ESVDECContext *dec_ctx, AVPacket *pkt, int timeout) {
+    int ret;
+    int data_size = 0;
+    InputBuffer buffer;
+    ESInputPort *port;
+
+    if (!dec_ctx || !dec_ctx->input_port) {
+        return AVERROR(EINVAL);
+    }
+    port = dec_ctx->input_port;
+
+    if (pkt) {
+        data_size = pkt->size;
+    }
+
+    ret = esdec_get_input_buffer_unitl_timeout(port->release_queue, &buffer, timeout);
+    if (ret == SUCCESS) {
+        if (buffer.max_size < data_size) {
+            ret = es_decode_realloc_input_memory(port, data_size + ES_DEFAULT_STREAM_BUFFER_SIZE, &buffer);
+        }
+
+        if (ret == SUCCESS) {
+            buffer.size = data_size;
+            if (pkt) {
+                buffer.pts = pkt->pts;
+                buffer.reordered_opaque = dec_ctx->reordered_opaque;
+                memcpy((void *)buffer.vir_addr, pkt->data, data_size);
+            }
+            esdec_push_input_packet_buffer(port->packet_queue, &buffer);
+        }
+    }
+
+    return ret;
+}
+
+int es_decode_send_packet_receive_frame(ESVDECContext *dec_ctx, AVPacket *pkt, AVFrame *frame) {
+    int ret;
+    int loop_count = 0;
+    if (!dec_ctx || !pkt || !frame) {
+        log_error(dec_ctx, "error !!! dec_ctx or pkt or frame is null pkt: %p, frame: %p\n", pkt, frame);
+        return FAILURE;
+    }
+
+    for (;;) {
+        ret = es_decode_send_packet(dec_ctx, pkt, 20 /*20ms*/);
+        if (ret == SUCCESS) {
+            ret = es_decode_get_frame(dec_ctx, frame, 0);
+            av_packet_unref(pkt);
+            break;
+        } else {
+            ret = es_decode_get_frame(dec_ctx, frame, 0);
+            if (ret == SUCCESS) {
+                log_info(dec_ctx, "get frame data_left: %d\n", pkt->size);
+                break;
+            }
+            else{
+                loop_count++;
+                if (loop_count >= 2){
+                    break;
+                }
+            }
+        }
+    }
+
+    if (frame->buf[0]) {
+        ret = SUCCESS;
+    } else {
+        ret = AVERROR(EAGAIN);
+    }
+
+    return ret;
+}
+
+int es_decode_get_frame(ESVDECContext *dec_ctx, AVFrame *frame, int timeout_ms) {
+    int ret;
+    int is_discard;
+    OutputBuffer buffer;
+    ESOutputPort *port;
+    if (!dec_ctx || !frame) {
+        return AVERROR(EINVAL);
+    }
+    port = dec_ctx->output_port;
+    if (!port) {
+        return AVERROR(EAGAIN);
+    }
+
+    ret = esdec_get_output_frame_buffer(port->frame_queue, &buffer, timeout_ms);
+    if (ret == SUCCESS) {
+        is_discard = esdec_check_discard_frame(dec_ctx->pic_display_number, dec_ctx->drop_frame_interval);
+        if (is_discard) {
+            esdec_drop_frame(dec_ctx, &buffer, frame);
+        } else {
+            ret = ff_esdec_fill_frame_prop(dec_ctx, &buffer, frame);
+            if (ret < 0) {
+                esdec_release_buffer_to_consume_queue(port->consumed_queue, &buffer);
+            } else {
+                dec_ctx->pic_output_number++;
+                esdec_set_output_buffer_state(buffer.memory, OUTPUT_MEMORY_STATE_FFMPEG);
+            }
+        }
+        dec_ctx->pic_display_number++;
+    }
+
+    if (frame->buf[0]) {
+        log_info(dec_ctx, "buffer vir_addr: %p\n", buffer.vir_addr);
+        ret = SUCCESS;
+    }
+
+    return ret;
+}
+
+static void esdec_eos_process(ESVDECContext *dec_ctx) {
+    int ret;
+    if (!dec_ctx || !dec_ctx->output_port) {
+        return;
+    }
+    log_info(dec_ctx, "VCDecEndOfStream start\n");
+    VCDecEndOfStream(dec_ctx->dec_inst);
+
+    for (;;) {
+        ret = esdec_get_next_picture(dec_ctx);
+        if (ret == FAILURE) {
+            OutputBuffer buffer = {0};
+            buffer.flags = OUTPUT_BUFFERFLAG_EOS;
+            esdec_push_frame_output_buffer(dec_ctx->output_port->frame_queue, &buffer);
+            log_info(dec_ctx, "push eos frames\n");
+            break;
+        }
+    }
+    log_info(dec_ctx, "end\n");
+}
+
+static void *esdec_decode_thread_run(void *ctx) {
+    int ret = FAILURE;
+    int end_stream = FALSE;
+    int peek_frame;
+    int abort_request = FALSE;
+    InputBuffer buffer;
+    ESInputPort *input_port;
+    ESVDECContext *dec_ctx = (ESVDECContext *)ctx;
+    if (!dec_ctx || !dec_ctx->input_port) {
+        log_error(dec_ctx, "error !!! dec_ctx or input_port is null\n");
+        return NULL;
+    }
+
+    input_port = dec_ctx->input_port;
+
+    while (!abort_request) {
+        ret = esdec_get_input_packet_buffer(input_port->packet_queue, &buffer);
+        if (ret == AVERROR_EXIT) {
+            log_info(dec_ctx, "decode thread will be exit\n");
+            abort_request = TRUE;
+            continue;
+        } else if (ret < 0) {
+            continue;
+        }
+
+        ret = esdec_wait_all_pictures_consumed_unitl_timeout(
+            dec_ctx->codec, dec_ctx->dec_inst, dec_ctx->output_port, 0 /*without waiting*/);
+        if (ret == AVERROR_EXIT) {
+            abort_request = TRUE;
+            continue;
+        }
+
+        if (buffer.size <= 0) {
+            esdec_eos_process(dec_ctx);
+            end_stream = TRUE;
+            esdec_release_input_buffer(input_port->release_queue, &buffer);
+            continue;
+        }
+
+        ret = esdec_decode(dec_ctx, &buffer, &peek_frame);
+        if (ret == AVERROR_EXIT) {
+            abort_request = TRUE;
+            continue;
+        } else if (peek_frame) {
+            do {
+                ret = esdec_get_next_picture(dec_ctx);
+                log_debug(dec_ctx, "esdec_get_next_picture ret: %d\n", ret);
+            } while (ret != FAILURE);
+        }
+
+        if (dec_ctx->init_config.mc_cfg.stream_consumed_callback == NULL) {
+            log_debug(dec_ctx, "release input buffer\n");
+            esdec_release_input_buffer(input_port->release_queue, &buffer);
+        }
+    }
+
+    esdec_output_port_clear(dec_ctx->output_port, esdec_picture_consume);
+    if (dec_ctx->reorder_queue) {
+        es_reorder_queue_clear(dec_ctx->reorder_queue);
+        av_freep(&dec_ctx->reorder_queue);
+    }
+
+    if (dec_ctx->reorder_pkt) {
+        av_freep(&dec_ctx->reorder_pkt);
+    }
+
+    if (!end_stream) {
+        log_info(dec_ctx, "dec end stream\n");
+        VCDecEndOfStream(dec_ctx->dec_inst);
+    }
+
+    if (dec_ctx->dec_inst) {
+        if (dec_ctx->codec == ES_HEVC) {
+            VCDecAbort(dec_ctx->dec_inst);
+        }
+    }
+
+    if (dec_ctx->picture) {
+        esdec_report_decode_info(dec_ctx);
+        av_freep(&dec_ctx->picture);
+    }
+
+    if (dec_ctx->frame) {
+        av_frame_free(&dec_ctx->frame);
+    }
+    av_buffer_unref(&dec_ctx->hwframe);
+    av_buffer_unref(&dec_ctx->hwdevice);
+
+    return NULL;
+}
+
+int es_decode_start(ESVDECContext *dec_ctx) {
+    if (!dec_ctx) {
+        log_error(dec_ctx, "error !!! dec_ctx is null\n");
+        return FAILURE;
+    }
+
+    if (pthread_create(&dec_ctx->tid, NULL, esdec_decode_thread_run, dec_ctx)) {
+        log_info(dec_ctx, "esdec_decode_thread_run create failed\n");
+        return FAILURE;
+    }
+
+    log_info(dec_ctx, "esdec_decode_thread_run create success\n");
+
+    return SUCCESS;
+}
+
+int es_decode_close(ESVDECContext *dec_ctx) {
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dec_ctx is null\n");
+        return FAILURE;
+    }
+
+    esdec_input_port_stop(dec_ctx->input_port);
+    esdec_output_port_stop(dec_ctx->output_port);
+
+    pthread_join(dec_ctx->tid, NULL);
+
+    if (dec_ctx->dec_inst) {
+        VCDecRelease(dec_ctx->dec_inst);
+        dec_ctx->dec_inst = NULL;
+        log_info(NULL, "dec_inst release success\n");
+    }
+
+    esdec_input_port_unref(&dec_ctx->input_port);
+    esdec_output_port_unref(&dec_ctx->output_port);
+
+    av_buffer_unref(&dec_ctx->dwl_ref);
+
+    log_info(dec_ctx, "es_decode_close success\n");
+
+    return SUCCESS;
+}
+
+int es_decode_flush(ESVDECContext *dec_ctx) {
+    if (!dec_ctx || !dec_ctx->dec_inst) {
+        log_error(dec_ctx, "dec_ctx: %p is null\n", dec_ctx);
+        return FAILURE;
+    }
+    log_info(dec_ctx, "flush enter\n");
+
+    esdec_clear_input_packets(dec_ctx->input_port);
+    VCDecAbort(dec_ctx->dec_inst);
+    esdec_clear_output_frames(dec_ctx->output_port);
+
+    log_info(dec_ctx, "flush exit\n");
+
+    return SUCCESS;
+}
diff --git a/libavcodec/esdecapi.h b/libavcodec/esdecapi.h
new file mode 100644
index 0000000000..3ec6069d07
--- /dev/null
+++ b/libavcodec/esdecapi.h
@@ -0,0 +1,105 @@
+#ifndef AVCODEC_ESDEC_API_H__
+#define AVCODEC_ESDEC_API_H__
+
+#include <libavutil/opt.h>
+#include <libavutil/buffer.h>
+#include <libavutil/frame.h>
+#include "avcodec.h"
+#include "dectypes.h"
+#include "es_common.h"
+#include "esdec_common.h"
+#include "es_codec_private.h"
+
+struct AVCodecContext;
+struct AVBuffer;
+struct ESQueue;
+struct ESInputPort;
+struct ESOutputPort;
+struct ReorderPkt;
+
+typedef struct ESVDECContext ESVDECContext;
+
+typedef int (*StoreReorderPktFunction)(ESVDECContext *dec_ctx, struct ReorderPkt *reorder_pkt);
+typedef int (*GetReorderPktFunction)(ESVDECContext *dec_ctx, int pic_id, struct ReorderPkt *out_pkt);
+
+struct ESVDECContext {
+    const AVClass *class;
+
+    int stride_align;
+    int target_pp;
+    int drop_frame_interval;
+    char *scale;
+    int pp_enabled[ES_VID_DEC_MAX_OUT_COUNT];
+    char *crop[ES_VID_DEC_MAX_OUT_COUNT];
+    int32_t pp_fmt[ES_VID_DEC_MAX_OUT_COUNT];
+    int32_t input_buf_num;
+
+    int extra_hw_frames;
+
+    int32_t hw_conceal;
+    int32_t disable_slice;
+
+    int packet_dump;
+    char *dump_path;
+    int packet_dump_time;
+    int dump_pkt_count;
+    int dump_frame_count[2];
+    int pmode;
+    int fmode;
+    DumpHandle *dump_pkt_handle;
+    DumpHandle *dump_frm_handle[ES_VID_DEC_MAX_OUT_COUNT];
+
+    int frame_dump[ES_VID_DEC_MAX_OUT_COUNT];
+    int frame_dump_time[ES_VID_DEC_MAX_OUT_COUNT];
+
+    ESDecState state;
+    ESVDecInst dec_inst;
+    void *dwl_inst;
+    struct AVBufferRef *dwl_ref;
+
+    ESDecCodec codec;
+    int pic_width;
+    int pic_height;
+    int bit_depth;
+
+    uint32_t got_package_number;
+    uint32_t pic_decode_number;
+    uint32_t pic_display_number;
+    uint32_t pic_output_number;
+
+    int pp_count;
+    struct DecInitConfig init_config;
+    struct DecConfig dec_config;
+    struct DecPicturePpu *picture;
+
+    struct ReorderPkt *reorder_pkt;
+    struct ESQueue *reorder_queue;
+    StoreReorderPktFunction store_reorder_pkt;
+    GetReorderPktFunction get_reorder_pkt_by_pic_id;
+
+    struct ESInputPort *input_port;
+    struct ESOutputPort *output_port;
+    struct AVBufferRef *input_port_ref;
+    struct AVBufferRef *output_port_ref;
+
+    AVPacket pkt;
+    AVFrame *frame;
+    AVBufferRef *hwdevice;
+    AVBufferRef *hwframe;
+
+    int64_t reordered_opaque;
+
+    pthread_t tid;
+};
+
+void es_decode_print_version_info(ESVDECContext *dec_ctx);
+int es_decode_init(ESVDECContext *dec_ctx);
+int es_decode_set_params(ESVDECContext *dec_ctx, ESDecCodec codec);
+int es_decode_get_frame(ESVDECContext *dec_ctx, AVFrame *frame, int timeout_ms);
+int es_decode_start(ESVDECContext *dec_ctx);
+int es_decode_close(ESVDECContext *dec_ctx);
+int es_decode_flush(ESVDECContext *dec_ctx);
+int es_decode_send_packet(ESVDECContext *dec_ctx, AVPacket *pkt, int timeout);
+int es_decode_send_packet_receive_frame(ESVDECContext *dec_ctx, AVPacket *pkt, AVFrame *frame);
+
+#endif
\ No newline at end of file
diff --git a/libavcodec/esdecbuffer.c b/libavcodec/esdecbuffer.c
new file mode 100644
index 0000000000..88f3947a6d
--- /dev/null
+++ b/libavcodec/esdecbuffer.c
@@ -0,0 +1,731 @@
+#define LOG_TAG "esdecbuffer"
+#include "esdecbuffer.h"
+#include "eslog.h"
+#include "es_common.h"
+
+#define MAX_OUTPUT_BUFFERS 40
+
+static int esdec_queue_pop(ESFifoQueue *queue, void *buffer, int size) {
+    int ret = FAILURE;
+    if (!queue || !buffer || size <= 0) {
+        log_error(NULL, "params error size: %d\n", size);
+        return FAILURE;
+    }
+
+    ret = es_fifo_queue_pop(queue, buffer, size);
+    if (ret != SUCCESS && queue->abort_request) {
+        log_info(NULL, "queue pop return AVERROR_EXIT\n");
+        ret = AVERROR_EXIT;
+    }
+
+    return ret;
+}
+
+static int esdec_queue_push(ESFifoQueue *queue, void *buffer, int size) {
+    int ret;
+    if (!queue || !buffer || size <= 0) {
+        log_error(NULL, "params error size: %d\n", size);
+        return FAILURE;
+    }
+
+    ret = es_fifo_queue_push(queue, buffer, size);
+    return ret;
+}
+
+static int esdec_get_output_buffer(ESFifoQueue *queue, void *buffer, int size, int timeout_ms) {
+    int ret;
+    if (!queue || !buffer || size <= 0) {
+        return FAILURE;
+    }
+
+    ret = es_fifo_queue_pop_until_timeout(queue, buffer, size, timeout_ms);
+    if (ret != SUCCESS && queue->abort_request) {
+        ret = AVERROR_EXIT;
+    }
+
+    return ret;
+}
+
+void esdec_input_buffer_init(InputBuffer *buffer,
+                             uint32_t *vir_addr,
+                             size_t bus_address,
+                             uint32_t logical_size,
+                             int max_size) {
+    if (!buffer) {
+        return;
+    }
+
+    memset(buffer, 0, sizeof(*buffer));
+    buffer->max_size = max_size;
+    buffer->vir_addr = vir_addr;
+    buffer->bus_address = bus_address;
+    buffer->logical_size = logical_size;
+}
+
+int esdec_get_input_packet_buffer(ESFifoQueue *queue, InputBuffer *buffer) {
+    int ret = esdec_queue_pop(queue, buffer, sizeof(*buffer));
+    return ret;
+}
+
+int esdec_push_input_packet_buffer(ESFifoQueue *queue, InputBuffer *buffer) {
+    int ret = esdec_queue_push(queue, buffer, sizeof(*buffer));
+    return ret;
+}
+
+int esdec_get_input_buffer_unitl_timeout(ESFifoQueue *queue, InputBuffer *buffer, int timeout) {
+    int ret;
+    if (!queue || !buffer) {
+        log_error(NULL, "params error buffer: %p, queue: %p\n", buffer, queue);
+        return FAILURE;
+    }
+
+    ret = es_fifo_queue_pop_until_timeout(queue, buffer, sizeof(InputBuffer), timeout);
+    return ret;
+}
+
+int esdec_release_input_buffer(ESFifoQueue *queue, InputBuffer *buffer) {
+    int ret;
+    buffer->pts = 0;
+    buffer->size = 0;
+    buffer->reordered_opaque = 0;
+
+    ret = esdec_queue_push(queue, buffer, sizeof(InputBuffer));
+    return ret;
+}
+
+int esdec_release_output_buffer(ESFifoQueue *queue, OutputBuffer *buffer) {
+    int ret;
+    struct AVBufferRef *buffer_ref = NULL, *port_ref = NULL;
+    if (!buffer) {
+        return FAILURE;
+    }
+
+    buffer->flags = 0;
+    buffer->reordered_opaque = 0;
+    if (buffer->buffer_ref) {
+        buffer_ref = buffer->buffer_ref;
+        buffer->buffer_ref = NULL;
+    } else {
+        buffer->memory = NULL;
+    }
+
+    if (buffer->port_ref) {
+        port_ref = buffer->port_ref;
+        buffer->port_ref = NULL;
+    }
+    esdec_set_output_buffer_state(buffer->memory, OUTPUT_MEMORY_STATE_CONSUME_QUEUE);
+    buffer->memory = NULL;
+    ret = esdec_queue_push(queue, buffer, sizeof(OutputBuffer));
+    if (buffer_ref) {
+        av_buffer_unref(&buffer_ref);
+    }
+    if (port_ref) {
+        av_buffer_unref(&port_ref);
+    }
+
+    return ret;
+}
+
+int esdec_push_frame_output_buffer(ESFifoQueue *queue, OutputBuffer *buffer) {
+    int ret = esdec_queue_push(queue, buffer, sizeof(OutputBuffer));
+    return ret;
+}
+
+int esdec_get_consumed_output_buffer(ESFifoQueue *queue, OutputBuffer *buffer, int timeout_ms) {
+    int ret = esdec_get_output_buffer(queue, buffer, sizeof(*buffer), timeout_ms);
+    return ret;
+}
+
+int esdec_get_output_frame_buffer(ESFifoQueue *queue, OutputBuffer *buffer, int timeout_ms) {
+    int ret = esdec_get_output_buffer(queue, buffer, sizeof(*buffer), timeout_ms);
+    if (!ret && buffer->flags == OUTPUT_BUFFERFLAG_EOS) {
+        ret = AVERROR_EOF;
+    }
+    return ret;
+}
+
+static void esdec_input_port_free(void *opaque, uint8_t *input_port) {
+    ESInputPort *port = (ESInputPort *)input_port;
+    if (!port) {
+        log_error(NULL, "input port is null\n");
+        return;
+    }
+
+    log_info(NULL, "enter esdec_input_port_free\n");
+    for (int i = 0; i < port->mem_num; i++) {
+        av_free(port->input_mems[i]);
+    }
+    es_fifo_queue_free(&port->packet_queue);
+    es_fifo_queue_free(&port->release_queue);
+    av_freep(&port->input_mems);
+    if (port->dwl_ref) {
+        log_info(NULL, "dwl_ref count: %d\n", av_buffer_get_ref_count(port->dwl_ref) - 1);
+        av_buffer_unref(&port->dwl_ref);
+    }
+
+    av_free(port);
+
+    log_info(NULL, "esdec_input_port_free success\n");
+}
+
+static void esdec_output_port_free(void *opaque, uint8_t *output_port) {
+    ESOutputPort *port = (ESOutputPort *)output_port;
+    if (!port) {
+        log_error(NULL, "output port is null\n");
+        return;
+    }
+
+    es_fifo_queue_free(&port->frame_queue);
+    es_fifo_queue_free(&port->consumed_queue);
+    av_freep(&port->output_mems);
+    if (port->dwl_ref) {
+        log_info(NULL, "dwl_ref count: %d\n", av_buffer_get_ref_count(port->dwl_ref) - 1);
+        av_buffer_unref(&port->dwl_ref);
+    }
+
+    av_free(port);
+
+    log_info(NULL, "esdec_output_port_free success\n");
+}
+
+void esdec_input_port_unref(ESInputPort **input_port) {
+    int mem_num;
+    ESInputMemory *mem;
+    ESInputPort *port;
+    if (!input_port || !*input_port) {
+        log_error(NULL, "error input_port is null %p\n", input_port);
+        return;
+    }
+
+    port = *input_port;
+    mem_num = port->mem_num;
+    for (int i = 0; i < mem_num; i++) {
+        mem = port->input_mems[i];
+        if (mem && mem->buffer_ref) {
+            log_info(NULL, "i: %d buffer_ref count: %d\n", i, av_buffer_get_ref_count(mem->buffer_ref) - 1);
+            av_buffer_unref(&mem->buffer_ref);
+        }
+        if (mem && mem->port_ref) {
+            log_info(NULL, "i: %d port_ref count: %d\n", i, av_buffer_get_ref_count(mem->port_ref) - 1);
+            av_buffer_unref(&mem->port_ref);
+        }
+    }
+    if (port->port_ref) {
+        log_info(NULL, "port_ref count: %d\n", av_buffer_get_ref_count(port->port_ref) - 1);
+        av_buffer_unref(&port->port_ref);
+    }
+
+    *input_port = NULL;
+}
+
+void esdec_output_port_memorys_unref(ESOutputPort *port) {
+    int mem_num;
+    ESOutputMemory *memory;
+    if (!port || port->mem_num <= 0) {
+        return;
+    }
+    mem_num = port->mem_num;
+    port->mem_num = 0;
+    for (int i = 0; i < mem_num; i++) {
+        memory = port->output_mems[i];
+        port->output_mems[i] = NULL;
+        if (memory) {
+            if (memory->buffer_ref && memory->port_ref) {
+                log_info(NULL,
+                         "i: %d, vir_addr: %p, buffer_ref count: %d, port_ref count: %d, state: %s\n",
+                         i,
+                         memory->vir_addr,
+                         av_buffer_get_ref_count(memory->buffer_ref) - 1,
+                         av_buffer_get_ref_count(memory->port_ref) - 1,
+                         esdec_str_output_state(memory->state));
+            }
+
+            av_buffer_unref(&memory->port_ref);
+            av_buffer_unref(&memory->buffer_ref);
+        }
+    }
+}
+
+void esdec_output_port_unref(ESOutputPort **output_port) {
+    ESOutputPort *port;
+    if (!output_port || !*output_port) {
+        log_error(NULL, "output_port is null %p\n", output_port);
+        return;
+    }
+
+    port = *output_port;
+    esdec_output_port_memorys_unref(port);
+
+    if (port->port_ref) {
+        log_info(NULL, "port_ref count: %d\n", av_buffer_get_ref_count(port->port_ref) - 1);
+        av_buffer_unref(&port->port_ref);
+    }
+    *output_port = NULL;
+}
+
+ESInputPort *esdec_input_port_create(int mem_num) {
+    int ret = FAILURE;
+    ESInputMemory *memory;
+    ESInputPort *port;
+    if (mem_num <= 0) {
+        log_error(NULL, "mem_num: %d\n", mem_num);
+        return NULL;
+    }
+
+    port = av_mallocz(sizeof(*port));
+    if (!port) {
+        log_error(NULL, "av_mallocz failed\n");
+        return NULL;
+    }
+
+    port->port_ref =
+        av_buffer_create((uint8_t *)port, sizeof(*port), esdec_input_port_free, NULL, AV_BUFFER_FLAG_READONLY);
+    if (!port->port_ref) {
+        esdec_input_port_free(NULL, (uint8_t *)port);
+        log_error(NULL, "av_buffer_create port_ref failed\n");
+        return NULL;
+    }
+
+    do {
+        port->packet_queue = es_fifo_queue_create(mem_num, sizeof(InputBuffer), "packet_queue");
+        if (!port->packet_queue) {
+            log_error(NULL, "es_fifo_queue_create packet_queue failed\n");
+            break;
+        }
+        port->release_queue = es_fifo_queue_create(mem_num, sizeof(InputBuffer), "release_queue");
+        if (!port->release_queue) {
+            log_error(NULL, "es_fifo_queue_create release_queue failed\n");
+            break;
+        }
+        port->input_mems = av_mallocz_array(sizeof(*port->input_mems), mem_num);
+        if (!port->input_mems) {
+            log_error(NULL, "av_mallocz_array input_mems failed\n");
+            break;
+        }
+
+        for (int i = 0; i < mem_num; i++) {
+            memory = av_mallocz(sizeof(*memory));
+            if (memory) {
+                memory->port_ref = av_buffer_ref(port->port_ref);
+                port->input_mems[i] = memory;
+                port->mem_num++;
+                if (port->mem_num == mem_num) {
+                    log_info(NULL, "input memorys malloc success mem_num: %d\n", mem_num);
+                    ret = SUCCESS;
+                    break;
+                }
+            } else {
+                log_error(NULL, "av_mallocz failed\n");
+                break;
+            }
+        }
+    } while (0);
+
+    if (ret == FAILURE) {
+        log_error(NULL, "input_port_create failed port mem_num: %d, mem_num: %d\n", port->mem_num, mem_num);
+        esdec_input_port_unref(&port);
+    } else {
+        log_info(NULL, "esdec_input_port_create success\n");
+    }
+
+    return port;
+}
+
+int esdec_input_port_enlarge(ESInputPort *port, uint32_t size) {
+    int ret = FAILURE;
+    int rv = 0;
+    ESInputMemory *memory;
+    ESInputMemory **input_mems_new;
+    uint32_t mem_size_new = 0;
+    if (!port) {
+        log_error(NULL, "input port is null\n");
+        return ret;
+    }
+
+    if (size < 0 || size <= port->mem_num) {
+        log_error(NULL, "error!!! input port mem_num: %d, enlarge to size: %d\n", port->mem_num, size);
+        return ret;
+    }
+
+    do {
+        rv = es_fifo_queue_enlarge(port->packet_queue, size, sizeof(InputBuffer));
+        if (rv < 0) {
+            log_error(NULL, "es_fifo_queue_enlarge packet_queue failed\n");
+            break;
+        }
+        rv = es_fifo_queue_enlarge(port->release_queue, size, sizeof(InputBuffer));
+        if (rv < 0) {
+            log_error(NULL, "es_fifo_queue_enlarge release_queue failed\n");
+            break;
+        }
+        input_mems_new = av_mallocz_array(sizeof(*port->input_mems), size);
+        if (!input_mems_new) {
+            log_error(NULL, "av_mallocz_array input_mems_new failed\n");
+            break;
+        }
+
+        for(int i = 0; i < port->mem_num; i++) {
+            input_mems_new[i] = port->input_mems[i];
+            mem_size_new ++;
+        }
+
+        for (int i = port->mem_num; i < size; i++) {
+            memory = av_mallocz(sizeof(*memory));
+            if (memory) {
+                memory->port_ref = av_buffer_ref(port->port_ref);
+                input_mems_new[i] = memory;
+                mem_size_new++;
+                if (mem_size_new == size) {
+                    log_info(NULL, "new input memorys malloc success mem_num: %d\n", size);
+                    av_freep(&port->input_mems);
+                    port->input_mems = input_mems_new;
+                    port->mem_num = mem_size_new;
+                    ret = SUCCESS;
+                    break;
+                }
+            } else {
+                log_error(NULL, "av_mallocz failed\n");
+                break;
+            }
+        }
+
+    } while (0);
+
+    if (ret == FAILURE) {
+        log_error(NULL, "input_port_enlarge failed port mem_num: %d, to size: %d\n", port->mem_num, size);
+        av_freep(input_mems_new);
+    } else {
+        log_info(NULL, "input_port_enlarge success\n");
+    }
+
+    return ret;
+}
+
+ESOutputPort *esdec_output_port_create(int mem_num) {
+    int ret = FAILURE;
+    ESOutputPort *port;
+    if (mem_num <= 0) {
+        log_error(NULL, "mem_num: %d\n", mem_num);
+        return NULL;
+    }
+
+    port = av_mallocz(sizeof(*port));
+    if (!port) {
+        log_error(NULL, "av_mallocz failed\n");
+        return NULL;
+    }
+
+    port->max_mem_num = MAX_OUTPUT_BUFFERS;
+    log_info(NULL, "output port mem_num: %d, max_mem_num: %d\n", mem_num, port->max_mem_num);
+    if (mem_num > port->max_mem_num) {
+        mem_num = port->max_mem_num;
+    }
+
+    port->port_ref =
+        av_buffer_create((uint8_t *)port, sizeof(*port), esdec_output_port_free, NULL, AV_BUFFER_FLAG_READONLY);
+    if (!port->port_ref) {
+        log_error(NULL, "av_buffer_create failed\n");
+        esdec_output_port_free(NULL, (uint8_t *)port);
+        return NULL;
+    }
+
+    do {
+        port->frame_queue = es_fifo_queue_create(MAX_OUTPUT_BUFFERS, sizeof(OutputBuffer), "frame_queue");
+        if (!port->frame_queue) {
+            log_error(NULL, "frame_queue create failed\n");
+            break;
+        }
+        port->consumed_queue = es_fifo_queue_create(MAX_OUTPUT_BUFFERS, sizeof(OutputBuffer), "consumed_queue");
+        if (!port->consumed_queue) {
+            log_error(NULL, "consumed_queue create failed\n");
+            break;
+        }
+        port->output_mems = av_mallocz_array(sizeof(*port->output_mems), MAX_OUTPUT_BUFFERS);
+        if (!port->output_mems) {
+            log_error(NULL, "av_mallocz_array output_mems failed\n");
+            break;
+        }
+        ret = SUCCESS;
+    } while (0);
+
+    if (ret == FAILURE) {
+        esdec_output_port_unref(&port);
+        log_error(NULL, "output port create failed\n");
+    } else {
+        log_info(NULL, "output port create success\n");
+    }
+
+    return port;
+}
+
+int esdec_release_buffer_to_consume_queue(ESFifoQueue *queue, OutputBuffer *buffer) {
+    int ret;
+    if (!queue || !buffer) {
+        log_error(NULL, "queue: %p, buffer: %p\n", queue, buffer);
+        return FAILURE;
+    }
+
+    ret = esdec_release_output_buffer(queue, buffer);
+    if (ret == FAILURE) {
+        log_error(NULL, "esdec_release_output_buffer\n");
+    }
+
+    return ret;
+}
+
+void esdec_output_port_clear(ESOutputPort *port, void (*free)(void *opaque, uint8_t *data)) {
+    int ret;
+    OutputBuffer buffer = {0};
+    if (!port || !port->frame_queue || !free) {
+        log_error(NULL, "port or frame queue is null %p, free: %p\n", port, free);
+        return;
+    }
+
+    log_info(NULL, "esdec_output_port_clear start\n");
+    for (;;) {
+        ret = es_fifo_queue_pop_ignore_abort(port->frame_queue, &buffer, sizeof(buffer));
+        if (ret == SUCCESS) {
+            if (free && buffer.memory) {
+                log_info(NULL, "output frame buffer clear\n");
+                free(port, (uint8_t *)(&buffer.memory->pic_pri));
+            }
+        } else {
+            break;
+        }
+    }
+    log_info(NULL, "esdec_output_port_clear end\n");
+}
+
+void esdec_clear_input_packets(ESInputPort *port) {
+    int ret;
+    InputBuffer buffer;
+    if (!port || !port->packet_queue || !port->release_queue) {
+        log_error(NULL, "inputport: %p is null\n", port);
+        return;
+    }
+
+    for (;;) {
+        ret = esdec_get_input_buffer_unitl_timeout(port->packet_queue, &buffer, 0);
+        if (ret == SUCCESS) {
+            log_info(NULL, "release input buffer size: %d, vir_addr: %p\n", buffer.size, buffer.vir_addr);
+            esdec_release_input_buffer(port->release_queue, &buffer);
+        } else {
+            if (ret == AVERROR_EXIT) {
+                log_info(NULL, "decode will be exit\n");
+            }
+            break;
+        }
+    }
+    log_info(NULL, "clear input packets success\n");
+}
+
+void esdec_clear_output_frames(ESOutputPort *port) {
+    int ret;
+    OutputBuffer buffer;
+    if (!port || !port->frame_queue || !port->consumed_queue) {
+        log_error(NULL, "outputport: %p is null\n", port);
+        return;
+    }
+
+    for (;;) {
+        ret = esdec_get_output_frame_buffer(port->frame_queue, &buffer, 0);
+        if (ret == SUCCESS) {
+            log_info(NULL, "release output buffer vir_addr: %p\n", buffer.vir_addr);
+            esdec_release_buffer_to_consume_queue(port->consumed_queue, &buffer);
+        } else {
+            if (ret == AVERROR_EXIT) {
+                log_info(NULL, "decode will be exit\n");
+            }
+            break;
+        }
+    }
+    log_info(NULL, "clear output frames success\n");
+}
+
+void esdec_output_port_stop(ESOutputPort *port) {
+    if (!port) {
+        return;
+    }
+    es_fifo_queue_abort(port->frame_queue);
+    es_fifo_queue_abort(port->consumed_queue);
+}
+
+void esdec_input_port_stop(ESInputPort *port) {
+    if (!port) {
+        return;
+    }
+    es_fifo_queue_abort(port->packet_queue);
+    es_fifo_queue_abort(port->release_queue);
+}
+
+int es_reorder_packet_enqueue(ESQueue *queue, ReorderPkt *pkt) {
+    int ret;
+    ReorderPkt *new_pkt;
+    if (!queue || !pkt) {
+        log_error(NULL, "queue or pkt is null queue: %p\n", queue);
+        return FAILURE;
+    }
+
+    new_pkt = (ReorderPkt *)av_mallocz(sizeof(ReorderPkt));
+    if (!new_pkt) {
+        log_error(NULL, "malloc ReorderPkt failed\n");
+        return FAILURE;
+    }
+
+    *new_pkt = *pkt;
+    ret = es_queue_push_tail(queue, new_pkt);
+    if (ret == SUCCESS) {
+        log_debug(NULL, "es_queue_push_tail success pic_id: %d\n", pkt->pic_id);
+    } else {
+        log_error(NULL, "es_queue_push_tail failed pic_id: %d\n", pkt->pic_id);
+    }
+
+    return ret;
+}
+
+int es_reorder_packet_dequeue(ESQueue *queue, uint32_t pic_id, ReorderPkt *out_pkt) {
+    int found = FALSE;
+    int ret = FAILURE;
+    List *list;
+    ReorderPkt *pkt = NULL;
+    if (!out_pkt || !queue) {
+        return FAILURE;
+    }
+
+    list = queue->head;
+    while (list) {
+        pkt = (ReorderPkt *)list->data;
+        if (pkt->pic_id == pic_id) {
+            found = TRUE;
+            break;
+        }
+        list = list->next;
+    }
+    if (!found) {
+        log_error(NULL, "find pic_id: %d failed\n", pic_id);
+    } else {
+        ret = SUCCESS;
+        *out_pkt = *pkt;
+        es_queue_delete_data(queue, pkt);
+        av_free(pkt);
+    }
+
+    return ret;
+}
+
+void es_reorder_queue_clear(ESQueue *queue) {
+    ReorderPkt *pkt;
+    while (pkt = (ReorderPkt *)es_queue_pop_head(queue)) {
+        log_info(NULL, "reorder queue pic_id: %d\n", pkt->pic_id);
+        av_free(pkt);
+    }
+}
+
+const char *esdec_str_output_state(OutputMemoryState state) {
+    switch (state) {
+        case OUTPUT_MEMORY_STATE_INITED:
+            return "inited";
+        case OUTPUT_MEMORY_STATE_CONSUMED:
+            return "consumed";
+        case OUTPUT_MEMORY_STATE_CONSUME_QUEUE:
+            return "consume_queue";
+        case OUTPUT_MEMORY_STATE_FRAME_QUEUE:
+            return "frame_queue";
+        case OUTPUT_MEMORY_STATE_FFMPEG:
+            return "ffmpeg";
+        case OUTPUT_MEMORY_STATE_ERROR:
+            return "erronr";
+        default:
+            return "unknown";
+    }
+}
+
+void esdec_set_output_buffer_state(ESOutputMemory *memory, OutputMemoryState state) {
+    OutputMemoryState old_state;
+    if (!memory) {
+        log_error(NULL, "memory is null\n");
+        return;
+    }
+
+    old_state = memory->state;
+    memory->state = state;
+    log_debug(NULL,
+              "vir_addr: %p, old_state: %s, memory new_state: %s\n",
+              memory->vir_addr,
+              esdec_str_output_state(old_state),
+              esdec_str_output_state(state));
+}
+
+void esdec_print_output_memory_state(ESOutputPort *port) {
+    ESOutputMemory *memory;
+    if (!port || !port->output_mems || port->mem_num == 0) {
+        return;
+    }
+
+    for (int i = 0; i < port->mem_num; i++) {
+        memory = port->output_mems[i];
+        log_info(NULL,
+                 "memory: %d, vir_addr: %p, is_added: %d, state: %s\n",
+                 i,
+                 memory->vir_addr,
+                 memory->is_added,
+                 esdec_str_output_state(memory->state));
+    }
+}
+
+void esdec_timed_printf_memory_state(ESOutputPort *port) {
+    int64_t now_time, start_time;
+
+    if (!port) {
+        return;
+    }
+    start_time = port->base_time;
+
+    now_time = av_gettime_relative();
+    if (now_time - start_time >= 5000000) {
+        port->base_time = now_time;
+        esdec_print_output_memory_state(port);
+    }
+}
+
+int esdec_check_output_buffer(ESOutputPort *port, OutputBuffer *buffer) {
+    int ret = FAILURE;
+    if (!port || !port->output_mems || !buffer) {
+        log_error(NULL, "port or buffer is null port: %p, buffer: %p\n", port, buffer);
+        return FAILURE;
+    }
+
+    for (int i = 0; i < port->mem_num; i++) {
+        if (buffer->vir_addr == port->output_mems[i]->vir_addr) {
+            ret = SUCCESS;
+            break;
+        }
+    }
+
+    if (ret == FAILURE) {
+        log_error(NULL, "outbuffer check failed vir_addr: %p\n", buffer->vir_addr);
+    }
+
+    return ret;
+}
+
+ESOutputMemory *esdec_find_memory_by_vir_addr(ESOutputPort *port, uint32_t *vir_addr) {
+    ESOutputMemory *memory = NULL;
+    if (!port || port->mem_num <= 0 || !vir_addr) {
+        log_error(NULL, "port: %p, vir_addr: %p\n", port, vir_addr);
+        return NULL;
+    }
+
+    for (int i = 0; i < port->mem_num; i++) {
+        memory = port->output_mems[i];
+        if (memory->vir_addr == vir_addr) {
+            break;
+        }
+    }
+
+    if (!memory) {
+        log_error(NULL, "find memory failed vir_addr: %p\n", vir_addr);
+    }
+
+    return memory;
+}
diff --git a/libavcodec/esdecbuffer.h b/libavcodec/esdecbuffer.h
new file mode 100644
index 0000000000..d450f4eefb
--- /dev/null
+++ b/libavcodec/esdecbuffer.h
@@ -0,0 +1,135 @@
+#ifndef AVCODEC_ES_DEC_BUFFER_H__
+#define AVCODEC_ES_DEC_BUFFER_H__
+
+#include <dectypes.h>
+#include "esqueue.h"
+#include "es_common.h"
+#include "es_codec_private.h"
+
+#define OUTPUT_BUFFERFLAG_EOS (1)
+
+struct AVPacket;
+struct DecPicturePpu;
+typedef struct ESOutputMemory ESOutputMemory;
+
+typedef struct InputBuffer {
+    int32_t size;
+    int32_t max_size;
+    int64_t pts;
+    uint32_t *vir_addr;
+    size_t bus_address;
+    uint32_t logical_size;
+    int64_t reordered_opaque;
+} InputBuffer;
+
+typedef struct OutputBuffer {
+    int flags;
+    int64_t pts;
+    int64_t reordered_opaque;
+    struct AVBufferRef *buffer_ref;
+    struct AVBufferRef *port_ref;
+    uint32_t *vir_addr;
+    ESOutputMemory *memory;
+} OutputBuffer;
+
+typedef struct ReorderPkt {
+    uint32_t pic_id;
+    int64_t dts;
+    int64_t pts;
+    int64_t reordered_opaque;
+} ReorderPkt;
+
+typedef struct ESInputMemory {
+    int fd;
+    struct DWLLinearMem mem;
+    struct AVBufferRef *buffer_ref;
+    struct AVBufferRef *port_ref;
+} ESInputMemory;
+
+typedef struct ESInputPort {
+    int mem_num;
+    ESInputMemory **input_mems;
+    ESFifoQueue *packet_queue;
+    ESFifoQueue *release_queue;
+    struct AVBufferRef *port_ref;
+    struct AVBufferRef *dwl_ref;
+} ESInputPort;
+
+typedef enum OutputMemoryState
+{
+    OUTPUT_MEMORY_STATE_INITED = 0,
+    OUTPUT_MEMORY_STATE_CONSUMED,
+    OUTPUT_MEMORY_STATE_CONSUME_QUEUE,
+    OUTPUT_MEMORY_STATE_FRAME_QUEUE,
+    OUTPUT_MEMORY_STATE_FFMPEG,
+    OUTPUT_MEMORY_STATE_ERROR,
+} OutputMemoryState;
+
+struct ESOutputMemory {
+    int is_added;
+    OutputMemoryState state;
+    int fd[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t *vir_addr;
+    OutputBuffer buffer;
+    struct DWLLinearMem mem;
+    DecPicturePri pic_pri;
+    struct DecPicturePpu picture;
+    struct AVBufferRef *buffer_ref;
+    struct AVBufferRef *port_ref;
+};
+
+typedef struct ESOutputPort {
+    int mem_num;
+    int max_mem_num;
+    int mem_size;
+    int pp_count;
+    ESOutputMemory **output_mems;
+    ESFifoQueue *frame_queue;
+    ESFifoQueue *consumed_queue;
+    struct AVBufferRef *port_ref;
+    struct AVBufferRef *dwl_ref;
+    int64_t base_time;
+} ESOutputPort;
+
+void esdec_input_buffer_init(InputBuffer *buffer,
+                             uint32_t *vir_addr,
+                             size_t bus_address,
+                             uint32_t logical_size,
+                             int max_size);
+int esdec_get_input_packet_buffer(ESFifoQueue *queue, InputBuffer *buffer);
+int esdec_push_input_packet_buffer(ESFifoQueue *queue, InputBuffer *buffer);
+int esdec_release_input_buffer(ESFifoQueue *queue, InputBuffer *buffer);
+int esdec_get_input_buffer_unitl_timeout(ESFifoQueue *queue, InputBuffer *buffer, int timeout);
+
+int esdec_release_output_buffer(ESFifoQueue *queue, OutputBuffer *buffer);
+int esdec_push_frame_output_buffer(ESFifoQueue *queue, OutputBuffer *buffer);
+int esdec_get_consumed_output_buffer(ESFifoQueue *queue, OutputBuffer *buffer, int timeout_ms);
+int esdec_get_output_frame_buffer(ESFifoQueue *queue, OutputBuffer *buffer, int timeout_ms);
+int esdec_release_buffer_to_consume_queue(ESFifoQueue *queue, OutputBuffer *buffer);
+
+ESInputPort *esdec_input_port_create(int mem_num);
+ESOutputPort *esdec_output_port_create(int mem_num);
+int esdec_input_port_enlarge(ESInputPort *port, uint32_t size);
+void esdec_input_port_unref(ESInputPort **input_port);
+void esdec_input_port_stop(ESInputPort *port);
+void esdec_output_port_memorys_unref(ESOutputPort *port);
+void esdec_output_port_unref(ESOutputPort **output_port);
+void esdec_output_port_stop(ESOutputPort *port);
+
+void esdec_clear_input_packets(ESInputPort *port);
+void esdec_clear_output_frames(ESOutputPort *port);
+
+void esdec_output_port_clear(ESOutputPort *port, void (*free_buffer)(void *opaque, uint8_t *data));
+
+void es_reorder_queue_clear(ESQueue *queue);
+int es_reorder_packet_enqueue(ESQueue *queue, ReorderPkt *pkt);
+int es_reorder_packet_dequeue(ESQueue *queue, uint32_t pic_id, ReorderPkt *out_pkt);
+
+void esdec_print_output_memory_state(ESOutputPort *port);
+void esdec_timed_printf_memory_state(ESOutputPort *port);
+int esdec_check_output_buffer(ESOutputPort *port, OutputBuffer *buffer);
+const char *esdec_str_output_state(OutputMemoryState state);
+void esdec_set_output_buffer_state(ESOutputMemory *memory, OutputMemoryState state);
+ESOutputMemory *esdec_find_memory_by_vir_addr(ESOutputPort *port, uint32_t *vir_addr);
+
+#endif
\ No newline at end of file
diff --git a/libavcodec/esdecode.c b/libavcodec/esdecode.c
new file mode 100644
index 0000000000..7379da255b
--- /dev/null
+++ b/libavcodec/esdecode.c
@@ -0,0 +1,448 @@
+#define LOG_TAG "esdecode"
+#include <libavutil/log.h>
+#include "libavutil/pixdesc.h"
+#include "libavutil/hwcontext_es.h"
+#include "hwconfig.h"
+#include "internal.h"
+#include "decode.h"
+#include "esdecapi.h"
+#include "eslog.h"
+#include "esdecbuffer.h"
+#include "encode.h"
+#include "codec_internal.h"
+
+static void ff_es_vdec_flush(AVCodecContext *avctx);
+static enum AVPixelFormat ff_es_vdec_get_format(ESVDECContext *dec_ctx) {
+    enum AVPixelFormat format = AV_PIX_FMT_NV12;
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dec_ctx is null\n");
+        return AV_PIX_FMT_NONE;
+    }
+
+    for (int i = 0; i < 2; i++) {
+        log_info(dec_ctx, "pp_enabled[%d]: %d, target_pp: %d\n", i , dec_ctx->pp_enabled[i], dec_ctx->target_pp);
+        if (dec_ctx->pp_enabled[i] && (dec_ctx->target_pp == -1 || dec_ctx->target_pp == i)) {
+            format = dec_ctx->pp_fmt[i];
+            log_info(dec_ctx, "target pp: %d, format: %d\n", i, format);
+            break;
+        }
+    }
+
+    return format;
+}
+
+static av_cold int ff_es_vdec_init(AVCodecContext *avctx) {
+    int ret = FAILURE;
+    AVHWFramesContext *hwframe_ctx;
+    ESDecCodec codec;
+    ESVDECContext *dec_ctx;
+
+    if (!avctx || !avctx->priv_data) {
+        log_error(avctx, "avctx or priv_data is null avctx: %p\n", avctx);
+        return FAILURE;
+    }
+
+    dec_ctx = (ESVDECContext *)avctx->priv_data;
+    es_decode_print_version_info(dec_ctx);
+
+    if (!dec_ctx->pp_enabled[0] && !dec_ctx->pp_enabled[1]) {
+        dec_ctx->pp_enabled[1] = 1;
+        dec_ctx->target_pp = 1;
+    }
+
+    avctx->sw_pix_fmt = ff_es_vdec_get_format(dec_ctx);
+    enum AVPixelFormat pix_fmts[3] = {AV_PIX_FMT_ES, avctx->sw_pix_fmt, AV_PIX_FMT_NONE};
+    avctx->pix_fmt = ff_get_format(avctx, pix_fmts);
+
+    log_info(avctx,
+             "avctx sw_pix_fmt: %s, pix_fmt: %s\n",
+             av_get_pix_fmt_name(avctx->sw_pix_fmt),
+             av_get_pix_fmt_name(avctx->pix_fmt));
+
+    if (avctx->hw_frames_ctx) {
+        dec_ctx->hwframe = av_buffer_ref(avctx->hw_frames_ctx);
+    } else {
+        if (avctx->hw_device_ctx) {
+            dec_ctx->hwdevice = av_buffer_ref(avctx->hw_device_ctx);
+            if (!dec_ctx->hwdevice) {
+                log_error(dec_ctx, "av_buffer_ref hw_device_ctx failed\n");
+                return FAILURE;
+            }
+        } else {
+            ret = av_hwdevice_ctx_create(&dec_ctx->hwdevice, AV_HWDEVICE_TYPE_ES, "es", NULL, 0);
+            if (ret) {
+                log_error(dec_ctx, "av_hwdevice_ctx_create failed\n");
+                return FAILURE;
+            }
+        }
+
+        dec_ctx->hwframe = av_hwframe_ctx_alloc(dec_ctx->hwdevice);
+        if (!dec_ctx->hwframe) {
+            log_error(dec_ctx, "av_hwframe_ctx_alloc failed\n");
+            return FAILURE;
+        }
+        hwframe_ctx = (AVHWFramesContext *)dec_ctx->hwframe->data;
+        hwframe_ctx->format = AV_PIX_FMT_ES;
+        hwframe_ctx->sw_format = avctx->sw_pix_fmt;
+    }
+
+    if (avctx->codec_id == AV_CODEC_ID_H264) {
+        codec = ES_H264_H10P;
+    } else if (avctx->codec_id == AV_CODEC_ID_HEVC) {
+        codec = ES_HEVC;
+    } else {
+        log_error(dec_ctx, "not support codec id: 0x%x\n", avctx->codec_id);
+        return FAILURE;
+    }
+
+    if (avctx->extra_hw_frames > 0) {
+        dec_ctx->extra_hw_frames = avctx->extra_hw_frames;
+    }
+
+    if (dec_ctx->extra_hw_frames <= 0) {
+        dec_ctx->extra_hw_frames = 2;
+    }
+    log_info(dec_ctx,
+             "dec_ctx extra_hw_frames: %d, avctx extra_hw_frames: %d\n",
+             dec_ctx->extra_hw_frames,
+             avctx->extra_hw_frames);
+
+    ret = es_decode_set_params(dec_ctx, codec);
+    if (ret == FAILURE) {
+        log_error(dec_ctx, "codec id: 0x%x, codec: %d set params failed\n", avctx->codec_id, codec);
+        return ret;
+    } else {
+        log_info(dec_ctx, "codec id: 0x%x, codec: %d set params success\n", avctx->codec_id, codec);
+    }
+
+    ret = es_decode_init(dec_ctx);
+    if (ret == FAILURE) {
+        log_error(dec_ctx, "init decoder failed\n");
+        return ret;
+    }
+
+    ret = es_decode_start(dec_ctx);
+    if (ret == SUCCESS) {
+        dec_ctx->state = ESDEC_STATE_FLUSHED;
+        avctx->apply_cropping = 0;
+        log_info(dec_ctx, "ff_es_vdec_init success\n");
+    } else {
+        log_error(dec_ctx, "ff_es_vdec_init failed\n");
+    }
+
+    return ret;
+}
+
+static int ff_es_vdec_eof_proc(ESVDECContext *dec_ctx, AVFrame *frame) {
+    int ret;
+    if (!dec_ctx) {
+        return AVERROR(EINVAL);
+    }
+
+    log_info(dec_ctx, "dec_ctx->state: %d\n", dec_ctx->state);
+    if (dec_ctx->state == ESDEC_STATE_STARTED) {
+        ret = es_decode_send_packet(dec_ctx, NULL, -1 /*always waiting*/);
+        if (ret == SUCCESS) {
+            dec_ctx->state = ESDEC_STATE_STOPPING;
+            log_info(dec_ctx, "send eos packet success enter stopping\n");
+        } else {
+            dec_ctx->state = ESDEC_STATE_STOPPED;
+            log_info(dec_ctx, "dec_ctx->state: %d\n", dec_ctx->state);
+        }
+    }
+
+    if (dec_ctx->state == ESDEC_STATE_STOPPING) {
+        ret = es_decode_get_frame(dec_ctx, frame, -1 /* always waiting */);
+        if (ret == AVERROR_EOF || ret == AVERROR_EXIT) {
+            dec_ctx->state = ESDEC_STATE_STOPPED;
+            log_info(dec_ctx, "recv eof decode enter stopped\n");
+        } else {
+            log_info(dec_ctx, "decode state stopping get frame ret: %d\n", ret);
+        }
+    }
+
+    return ret;
+}
+
+static int ff_es_vdec_receive_frame(AVCodecContext *avctx, AVFrame *frame) {
+    int ret = SUCCESS;
+    ESVDECContext *dec_ctx;
+    AVPacket *avpkt;
+
+    if (!avctx || !avctx->priv_data || !frame) {
+        log_error(dec_ctx, "avctx or private or frame is null avctx: %p, frame: %p\n", avctx, frame);
+        return AVERROR(EINVAL);
+    }
+
+    dec_ctx = (ESVDECContext *)avctx->priv_data;
+    avpkt = &dec_ctx->pkt;
+
+    if (dec_ctx->state == ESDEC_STATE_UNINIT) {
+        log_error(dec_ctx, "dec_ctx state: %d error\n", dec_ctx->state);
+        return AVERROR(EINVAL);
+    } else if (dec_ctx->state == ESDEC_STATE_STOPPED || dec_ctx->state == ESDEC_STATE_CLOSED) {
+        log_warn(dec_ctx, "dec_ctx state: %d closed\n", dec_ctx->state);
+        return AVERROR_EOF;
+    }
+
+    do {
+        if (dec_ctx->state == ESDEC_STATE_STOPPING) {
+            ret = ff_es_vdec_eof_proc(dec_ctx, frame);
+            break;
+        }
+
+        if (!avpkt->data || avpkt->size <= 0) {
+            ret = ff_decode_get_packet(avctx, avpkt);
+            log_debug(dec_ctx, "ff_decode_get_packet ret: 0x%x, size: %d, flags: %d\n", ret, avpkt->size, avpkt->flags);
+            if (ret == SUCCESS) {
+                dec_ctx->reordered_opaque = avctx->reordered_opaque;
+            }
+        } else {
+            log_debug(dec_ctx, "use last pkt size: %d\n", avpkt->size);
+        }
+
+        if (ret == AVERROR(EAGAIN)) {
+            ret = es_decode_get_frame(dec_ctx, frame, 0 /*without waiting*/);
+            if (ret == FAILURE) {
+                ret = AVERROR(EAGAIN);
+                log_debug(dec_ctx, "EAGAIN ret: %d\n", ret);
+            }
+            break;
+        } else if (ret == AVERROR_EOF) {
+            ret = ff_es_vdec_eof_proc(dec_ctx, frame);
+            break;
+        } else if (ret < 0) {
+            log_error(dec_ctx, "ff_decode_get_packet failed ret: 0x%x\n", ret);
+            break;
+        }
+
+        if (dec_ctx->state == ESDEC_STATE_FLUSHED) {
+            dec_ctx->state = ESDEC_STATE_STARTED;
+        }
+
+        ret = es_decode_send_packet_receive_frame(dec_ctx, avpkt, frame);
+    } while (0);
+
+    if (ret == SUCCESS) {
+        if (avctx->width != frame->width || avctx->height != frame->height) {
+            avctx->width = frame->width;
+            avctx->height = frame->height;
+        }
+
+        if (avctx->pix_fmt == AV_PIX_FMT_ES) {
+            frame->format = AV_PIX_FMT_ES;
+            frame->hw_frames_ctx = av_buffer_ref(dec_ctx->hwframe);
+        } else if (frame->flags & AV_FRAME_FLAG_DISCARD) {
+            frame->format = avctx->sw_pix_fmt;
+        }
+    }
+
+    return ret;
+}
+
+static void ff_es_vdec_flush(AVCodecContext *avctx) {
+    ESVDECContext *dec_ctx;
+    if (!avctx || !avctx->priv_data) {
+        log_info(avctx, "avctx or dec_ctx is null avctx: %p\n", avctx);
+        return;
+    }
+
+    if (dec_ctx->state != ESDEC_STATE_UNINIT && dec_ctx->state != ESDEC_STATE_CLOSED
+        && dec_ctx->state != ESDEC_STATE_FLUSHED) {
+        dec_ctx = (ESVDECContext *)avctx->priv_data;
+        es_decode_flush(dec_ctx);
+        dec_ctx->state = ESDEC_STATE_FLUSHED;
+    }
+
+    log_info(avctx, "ff_es_vdec_flush dec_ctx->state: %d\n", dec_ctx->state);
+}
+
+static av_cold int ff_es_vdec_close(AVCodecContext *avctx) {
+    ESVDECContext *dec_ctx;
+    if (!avctx || !avctx->priv_data) {
+        log_info(avctx, "avctx or dec_ctx is null avctx: %p\n", avctx);
+        return 0;
+    }
+
+    log_info(avctx, "ff_es_vdec_close start\n");
+    dec_ctx = (ESVDECContext *)avctx->priv_data;
+    if (dec_ctx->state != ESDEC_STATE_CLOSED) {
+        dec_ctx->state = ESDEC_STATE_CLOSED;
+        es_decode_close(dec_ctx);
+    }
+
+    if (dec_ctx->dump_pkt_handle) {
+        ff_codec_dump_file_close(&dec_ctx->dump_pkt_handle);
+    }
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (dec_ctx->dump_frm_handle[i]) {
+            ff_codec_dump_file_close(&dec_ctx->dump_frm_handle[i]);
+        }
+    }
+
+    log_info(avctx, "ff_es_vdec_close end\n");
+
+    return 0;
+}
+
+#define OFFSET(x) offsetof(ESVDECContext, x)
+#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM
+static const AVOption options[] = {
+    {"stride_align", "set out stride", OFFSET(stride_align), AV_OPT_TYPE_INT, {.i64 = 64}, 1, 1024, VD},
+    {"drop_frame_interval",
+     "set drop frame interval",
+     OFFSET(drop_frame_interval),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     INT_MAX,
+     VD},
+    {"extra_output_frames",
+     "set extra output frame number",
+     OFFSET(extra_hw_frames),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     128,
+     VD},
+    {"pp0", "pp0 enable", OFFSET(pp_enabled[0]), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, VD, "enable pp"},
+    {"pp1", "pp1 enable", OFFSET(pp_enabled[1]), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, VD, "enable pp"},
+    {"enable", "enable pp", 0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VD, "enable pp"},
+    {"disable", "disable pp", 0, AV_OPT_TYPE_CONST, {.i64 = 0}, 0, 0, VD, "enable pp"},
+    {"crop", "crop (top)x(bottom)x(left)x(right)", OFFSET(crop[1]), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, VD},
+    {"pp0_crop", "crop (top)x(bottom)x(left)x(right)", OFFSET(crop[0]), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, VD},
+    {"pp1_crop", "crop (top)x(bottom)x(left)x(right)", OFFSET(crop[1]), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, VD},
+    {"down_scale", "width:height or ratio_x:ratio_y", OFFSET(scale), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, VD},
+    {"pixfmt",
+     "set output pix_fmt",
+     OFFSET(pp_fmt[1]),
+     AV_OPT_TYPE_INT,
+     {.i64 = AV_PIX_FMT_NV12},
+     -1,
+     INT_MAX,
+     VD,
+     "pp1_fmt"},
+    {"pp0_pixfmt",
+     "set pp0 pix_fmt",
+     OFFSET(pp_fmt[0]),
+     AV_OPT_TYPE_INT,
+     {.i64 = AV_PIX_FMT_NV12},
+     -1,
+     INT_MAX,
+     VD,
+     "pp0_fmt"},
+    {"nv12", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_NV12}, 0, 0, VD, "pp0_fmt"},
+    {"nv21", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_NV21}, 0, 0, VD, "pp0_fmt"},
+    {"yuv420p", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_YUV420P}, 0, 0, VD, "pp0_fmt"},
+    {"gray", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_GRAY8}, 0, 0, VD, "pp0_fmt"},
+    {"p010le", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_P010LE}, 0, 0, VD, "pp0_fmt"},
+    {"pp1_pixfmt",
+     "set pp1 pix_fmt",
+     OFFSET(pp_fmt[1]),
+     AV_OPT_TYPE_INT,
+     {.i64 = AV_PIX_FMT_NV12},
+     -1,
+     INT_MAX,
+     VD,
+     "pp1_fmt"},
+    {"nv12", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_NV12}, 0, 0, VD, "pp1_fmt"},
+    {"nv21", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_NV21}, 0, 0, VD, "pp1_fmt"},
+    {"yuv420p", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_YUV420P}, 0, 0, VD, "pp1_fmt"},
+    {"gray", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_GRAY8}, 0, 0, VD, "pp1_fmt"},
+    {"p010le", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_P010LE}, 0, 0, VD, "pp1_fmt"},
+    {"rgb", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_RGB24}, 0, 0, VD, "pp1_fmt"},
+    {"bgr", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_BGR24}, 0, 0, VD, "pp1_fmt"},
+    {"argb", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_ARGB}, 0, 0, VD, "pp1_fmt"},
+    {"abgr", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_ABGR}, 0, 0, VD, "pp1_fmt"},
+    {"xrgb", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_0RGB}, 0, 0, VD, "pp1_fmt"},
+    {"xbgr", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_0BGR}, 0, 0, VD, "pp1_fmt"},
+    {"rgb48le", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_RGB48LE}, 0, 0, VD, "pp1_fmt"},
+    {"bgr48le", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_BGR48LE}, 0, 0, VD, "pp1_fmt"},
+    {"rbga64le", "", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_RGBA64LE}, 0, 0, VD, "pp1_fmt"},
+    {"bgra64le", "output format", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_BGRA64LE}, 0, 0, VD, "pp1_fmt"},
+    {"target_pp", "", OFFSET(target_pp), AV_OPT_TYPE_INT, {.i64 = -1}, -1, 1, VD, "target_pp"},
+    {"auto",
+     "both pp0&pp1 enabled and the target is pp0, pp0 or pp1 is enabled, the target is pp0 or pp1",
+     0,
+     AV_OPT_TYPE_CONST,
+     {.i64 = -1},
+     0,
+     0,
+     VD,
+     "target_pp"},
+    {"pp0", "the target to pp0", 0, AV_OPT_TYPE_CONST, {.i64 = 0}, 0, 0, VD, "target_pp"},
+    {"pp1", "the target to pp1", 0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, 0, VD, "target_pp"},
+    {"packet_dump", "set dump packet", OFFSET(packet_dump), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, VD},
+    {"dump_path", "set dump packet path", OFFSET(dump_path), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, VD},
+    {"packet_dump_time", "set dump packet time", OFFSET(packet_dump_time), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 60000, VD},
+    {"pp0_frame_dump", "set pp0 frame dump", OFFSET(frame_dump[0]), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, VD},
+    {"pp1_frame_dump", "set pp1 frame dump", OFFSET(frame_dump[1]), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, VD},
+    {"pp0_frame_dump_time",
+     "dump pp0 frame time",
+     OFFSET(frame_dump_time[0]),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     60000,
+     VD},
+    {"pp1_frame_dump_time",
+     "set dump pp1 frame time",
+     OFFSET(frame_dump_time[1]),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     60000,
+     VD},
+    {NULL},
+};
+
+static const AVCodecHWConfigInternal *es_hw_configs[] = {
+    &(const AVCodecHWConfigInternal){
+        .public =
+            {
+                .pix_fmt = AV_PIX_FMT_ES,
+                .methods = AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX | AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX
+                           | AV_CODEC_HW_CONFIG_METHOD_INTERNAL,
+                .device_type = AV_HWDEVICE_TYPE_ES,
+            },
+        .hwaccel = NULL,
+    },
+    NULL};
+
+static const enum AVPixelFormat es_vdec_support_pixfmts[] = {AV_PIX_FMT_ES,
+                                                             AV_PIX_FMT_YUV420P,
+                                                             AV_PIX_FMT_NV12,
+                                                             AV_PIX_FMT_NV21,
+                                                             AV_PIX_FMT_GRAY8,
+                                                             AV_PIX_FMT_P010,
+                                                             AV_PIX_FMT_NONE};
+
+#define ES_VIDEO_DEC(ctype, CTYPE)                                                               \
+    static const AVClass es_##ctype##_decoder_class = {                                          \
+        .class_name = #ctype "_esvdec",                                                          \
+        .item_name = av_default_item_name,                                                       \
+        .option = options,                                                                       \
+        .version = LIBAVUTIL_VERSION_INT,                                                        \
+    };                                                                                           \
+    FFCodec ff_##ctype##_es_decoder = {                                                          \
+        .p.name = #ctype "_esvdec",                                                                \
+        .p.long_name = NULL_IF_CONFIG_SMALL("Eswin " #ctype " video decoder"),                     \
+        .p.type = AVMEDIA_TYPE_VIDEO,                                                              \
+        .p.id = AV_CODEC_ID_##CTYPE,                                                               \
+        .priv_data_size = sizeof(ESVDECContext),                                                 \
+        .p.priv_class = &es_##ctype##_decoder_class,                                               \
+        .init = ff_es_vdec_init,                                                                 \
+        .close = ff_es_vdec_close,                                                               \
+        FF_CODEC_RECEIVE_FRAME_CB(ff_es_vdec_receive_frame),                                     \
+        .flush = ff_es_vdec_flush,                                                               \
+        .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
+        .p.pix_fmts = es_vdec_support_pixfmts,                                                     \
+        .hw_configs = es_hw_configs,                                                             \
+        .p.wrapper_name = "esvdec",                                                                \
+        .bsfs = #ctype "_mp4toannexb",                                                           \
+    };
+
+ES_VIDEO_DEC(hevc, HEVC)
+ES_VIDEO_DEC(h264, H264)
+
+#undef ES_VIDEO_DEC
\ No newline at end of file
diff --git a/libavcodec/esenc_common.c b/libavcodec/esenc_common.c
new file mode 100644
index 0000000000..97dd3ed793
--- /dev/null
+++ b/libavcodec/esenc_common.c
@@ -0,0 +1,325 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include "esenc_common.h"
+#include "codec_internal.h"
+
+static int esenc_fifo_init(FifoQueue *fifo_queue, unsigned nmemb, unsigned task_size) {
+    if (!fifo_queue || !nmemb || !task_size) return -1;
+
+    fifo_queue->fifo = av_fifo_alloc_array(nmemb, task_size);
+    if (!fifo_queue->fifo) return -1;
+
+    fifo_queue->cur_index = 0;
+    fifo_queue->depth = nmemb;
+    fifo_queue->task_size = task_size;
+
+    pthread_mutex_init(&fifo_queue->fifo_mutex, NULL);
+    pthread_cond_init(&fifo_queue->fifo_cond, NULL);
+    pthread_cond_init(&fifo_queue->fifo_writable_cond, NULL);
+
+    return 0;
+}
+
+static int esenc_fifo_deinit(FifoQueue *fifo_queue) {
+    if (!fifo_queue) return -1;
+    pthread_mutex_destroy(&fifo_queue->fifo_mutex);
+    pthread_cond_destroy(&fifo_queue->fifo_cond);
+    pthread_cond_destroy(&fifo_queue->fifo_writable_cond);
+    av_fifo_freep(&fifo_queue->fifo);
+    fifo_queue->fifo = NULL;
+
+    return 0;
+}
+
+static int esenc_fifo_push(FifoQueue *fifo_queue, FifoTask *task) {
+    if (!fifo_queue || !task) return -1;
+
+    pthread_mutex_lock(&fifo_queue->fifo_mutex);
+    if (!av_fifo_space(fifo_queue->fifo)) {
+        pthread_cond_wait(&fifo_queue->fifo_writable_cond, &fifo_queue->fifo_mutex);
+    }
+    av_fifo_generic_write(fifo_queue->fifo, task, sizeof(FifoTask), NULL);
+    pthread_mutex_unlock(&fifo_queue->fifo_mutex);
+    pthread_cond_signal(&fifo_queue->fifo_cond);
+
+    return 0;
+}
+
+static int esenc_fifo_pop(FifoQueue *fifo_queue, FifoTask *task) {
+    if (!fifo_queue || !task) return -1;
+
+    pthread_mutex_lock(&fifo_queue->fifo_mutex);
+    av_fifo_generic_read(fifo_queue->fifo, task, sizeof(FifoTask), NULL);
+    pthread_mutex_unlock(&fifo_queue->fifo_mutex);
+    pthread_cond_signal(&fifo_queue->fifo_writable_cond);
+
+    return 0;
+}
+
+static int esenc_fifo_size(FifoQueue *fifo_queue) {
+    int ret = 0;
+    if (!fifo_queue) return -1;
+
+    pthread_mutex_lock(&fifo_queue->fifo_mutex);
+    ret = av_fifo_size(fifo_queue->fifo);
+    pthread_mutex_unlock(&fifo_queue->fifo_mutex);
+
+    return ret;
+}
+
+static int esenc_fifo_wait(FifoQueue *fifo_queue) {
+    int ret = 0;
+    if (!fifo_queue) return -1;
+
+    pthread_mutex_lock(&fifo_queue->fifo_mutex);
+    ret = pthread_cond_wait(&fifo_queue->fifo_cond, &fifo_queue->fifo_mutex);
+    pthread_mutex_unlock(&fifo_queue->fifo_mutex);
+
+    return ret;
+}
+
+static int esenc_fifo_signal(FifoQueue *fifo_queue) {
+    int ret = 0;
+    if (!fifo_queue) return -1;
+
+    pthread_mutex_lock(&fifo_queue->fifo_mutex);
+    ret = pthread_cond_signal(&fifo_queue->fifo_cond);
+    pthread_mutex_unlock(&fifo_queue->fifo_mutex);
+
+    return ret;
+}
+
+static int esenc_fifo_broadcast(FifoQueue *fifo_queue) {
+    int ret = 0;
+    if (!fifo_queue) return -1;
+
+    pthread_mutex_lock(&fifo_queue->fifo_mutex);
+    ret = pthread_cond_broadcast(&fifo_queue->fifo_cond);
+    pthread_mutex_unlock(&fifo_queue->fifo_mutex);
+
+    return ret;
+}
+
+static void esenc_thread_free(void *tc);
+
+static void *attribute_align_arg esenc_thread_worker(void *v) {
+    ThreadContext *c = (ThreadContext *)v;
+    AVPacket *pkt = NULL;
+    AVCodecContext *avctx = c->avctx;
+
+    av_log(NULL, AV_LOG_INFO, "encoder worker in\n");
+
+    while (!atomic_load(&c->exit)) {
+        int got_packet, ret;
+        AVFrame *frame;
+        FifoTask task;
+        FifoTask out_task;
+        int in_frame_fifo_size = 0;
+
+        while ((in_frame_fifo_size = esenc_fifo_size(&c->in_frame_queue)) <= 0 && !atomic_load(&c->exit)) {
+            if (in_frame_fifo_size < 0) return NULL;
+            esenc_fifo_wait(&c->in_frame_queue);
+        }
+
+        // av_log(NULL, AV_LOG_INFO, "encoder worker fifo size: %d\n", in_frame_fifo_size);
+        if (in_frame_fifo_size > 0) {
+            // streaming packet
+            if (!pkt) pkt = av_packet_alloc();
+            if (!pkt) continue;
+            av_init_packet(pkt);
+
+            esenc_fifo_pop(&c->in_frame_queue, &task);
+            frame = (AVFrame *)task.buf;
+            av_log(avctx,
+                   AV_LOG_DEBUG,
+                   "worker, get one frame: %p, pts = %" PRId64 ", dts = %" PRId64 " from input queue\n",
+                   frame,
+                   frame ? frame->pts : AV_NOPTS_VALUE,
+                   frame ? frame->pkt_dts : AV_NOPTS_VALUE);
+
+            // FFmpeg5.1.2 fixed:
+            ret = c->es_encode_func(avctx, pkt, frame, &got_packet);
+            // ret = avctx->codec->encode2(avctx, pkt, frame, &got_packet);
+            if (got_packet) {
+                av_packet_make_refcounted(pkt);
+                // put into out_packet_queue
+                out_task.buf = (void *)pkt;
+                out_task.index = c->out_packet_queue.cur_index;
+                esenc_fifo_push(&c->out_packet_queue, &out_task);
+                c->out_packet_queue.cur_index = (c->out_packet_queue.cur_index + 1) % OUT_PACKET_FIFO_DEPTH;
+                av_log(NULL, AV_LOG_DEBUG, "worker, push one packet to output queue\n");
+            } else {
+                av_packet_free(&pkt);
+            }
+            pkt = NULL;
+
+            // av_frame_unref(frame);
+            av_frame_free(&frame);
+
+            if (ret == AVERROR_EOF) {
+                c->is_eof = 1;
+                av_log(NULL, AV_LOG_INFO, "encoder worker is_eof = 1\n");
+                esenc_fifo_broadcast(&c->out_packet_queue);
+            } else {
+                c->is_eof = 0;
+            }
+        }
+    }
+
+    av_log(NULL, AV_LOG_INFO, "encoder worker exit\n");
+    return NULL;
+}
+
+static int esenc_thread_init(
+    void **tc,
+    AVCodecContext *avctx,
+    int (*es_encode_func)(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, int *)) {
+    ThreadContext *c = (ThreadContext *)av_mallocz(sizeof(ThreadContext));
+    *tc = c;
+
+    if (!c) return AVERROR(ENOMEM);
+
+    c->avctx = avctx;
+    c->es_encode_func = es_encode_func;
+
+    if (esenc_fifo_init(&c->in_frame_queue, IN_FRMAE_FIFO_DEPTH, sizeof(FifoTask))) {
+        goto fail;
+    }
+
+    if (esenc_fifo_init(&c->out_packet_queue, OUT_PACKET_FIFO_DEPTH, sizeof(FifoTask))) {
+        goto fail;
+    }
+
+    atomic_init(&c->exit, 0);
+
+    if (pthread_create(&c->worker, NULL, esenc_thread_worker, (void *)c)) {
+        goto fail;
+    }
+
+    return 0;
+
+fail:
+    av_log(NULL, AV_LOG_ERROR, "%s failed\n", __FUNCTION__);
+    return -1;
+}
+
+static void esenc_thread_free(void *tc) {
+    ThreadContext *c = (ThreadContext *)tc;
+
+    atomic_store(&c->exit, 1);
+    esenc_fifo_broadcast(&c->in_frame_queue);
+    esenc_fifo_broadcast(&c->out_packet_queue);
+    pthread_join(c->worker, NULL);
+
+    while (esenc_fifo_size(&c->in_frame_queue) > 0) {
+        FifoTask task;
+        AVFrame *frame;
+        esenc_fifo_pop(&c->in_frame_queue, &task);
+        frame = (AVFrame *)task.buf;
+        av_frame_free(&frame);
+        task.buf = NULL;
+    }
+
+    while (esenc_fifo_size(&c->out_packet_queue) > 0) {
+        FifoTask task;
+        AVPacket *pkt;
+        esenc_fifo_pop(&c->out_packet_queue, &task);
+        pkt = (AVPacket *)task.buf;
+        av_packet_free(&pkt);
+        task.buf = NULL;
+    }
+
+    esenc_fifo_deinit(&c->in_frame_queue);
+    esenc_fifo_deinit(&c->out_packet_queue);
+    av_freep(&tc);
+}
+
+int esenc_send_frame(void *tc, const AVFrame *frame) {
+    ThreadContext *c = (ThreadContext *)tc;
+    FifoTask task;
+    AVFrame *new_frame = NULL;;
+
+    if (frame && !c->enc_flushing) {
+        new_frame = av_frame_alloc();
+        if (!new_frame) {
+            av_log(NULL, AV_LOG_ERROR, "%s av_frame_alloc failed\n", __FUNCTION__);
+            return AVERROR(ENOMEM);
+        }
+        av_frame_move_ref(new_frame, frame);
+    } else {
+        if (!c->enc_flushing) c->enc_flushing = 1;
+    }
+
+    task.index = c->in_frame_queue.cur_index;
+    task.buf = (void *)new_frame;
+    esenc_fifo_push(&c->in_frame_queue, &task);
+    c->in_frame_queue.cur_index = (c->in_frame_queue.cur_index + 1) % IN_FRMAE_FIFO_DEPTH;
+
+    return 0;
+}
+
+int esenc_receive_packet(void *tc, AVPacket *pkt) {
+    ThreadContext *c = (ThreadContext *)tc;
+    FifoTask task;
+    int size = 0;
+
+    while ((size = esenc_fifo_size(&c->out_packet_queue)) <= 0 && !atomic_load(&c->exit)) {
+        if (size < 0) {
+            return AVERROR(EINVAL);
+        } else if (!size) {
+            if (c->is_eof) {
+                av_log(NULL, AV_LOG_INFO, "receive_packet is_eof\n");
+                return AVERROR_EOF;
+            } else if (!c->avctx->internal->draining) {
+                return AVERROR(EAGAIN);
+            } else {
+                av_log(NULL, AV_LOG_DEBUG, "receive pkt, wait\n");
+                if (!c->is_eof) esenc_fifo_wait(&c->out_packet_queue);
+            }
+        }
+    }
+
+    // get streaming form queue
+    if (esenc_fifo_pop(&c->out_packet_queue, &task) < 0) {
+        return AVERROR(EINVAL);
+    }
+
+    if (pkt) {
+        *pkt = *(AVPacket *)(task.buf);
+    }
+
+    if (pkt->size) av_log(NULL, AV_LOG_DEBUG, "%s, size: %d out\n", __FUNCTION__, pkt->size);
+
+    return 0;
+}
+
+int esenc_init(void **tc,
+               AVCodecContext *avctx,
+               int (*es_encode_func)(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, int *)) {
+    int ret;
+
+    ret = esenc_thread_init(tc, avctx, es_encode_func);
+
+    return ret;
+}
+
+void esenc_close(void *tc) {
+    esenc_thread_free(tc);
+}
diff --git a/libavcodec/esenc_common.h b/libavcodec/esenc_common.h
new file mode 100644
index 0000000000..6203ae7b85
--- /dev/null
+++ b/libavcodec/esenc_common.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ESENC_COMMON_H
+#define AVCODEC_ESENC_COMMON_H
+
+#include <stdatomic.h>
+#include "libavutil/fifo.h"
+#include "libavutil/avassert.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/thread.h"
+#include "libavutil/eval.h"
+#include "libavutil/internal.h"
+#include "libavutil/opt.h"
+#include "libavutil/mem.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/stereo3d.h"
+#include "libavutil/intreadwrite.h"
+#include "avcodec.h"
+#include "internal.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_es.h"
+
+#define IN_FRMAE_FIFO_DEPTH (15)
+#define OUT_PACKET_FIFO_DEPTH IN_FRMAE_FIFO_DEPTH
+
+typedef struct {
+    void *buf;
+    unsigned index;
+} FifoTask;
+
+typedef struct {
+    unsigned cur_index;
+    unsigned depth;
+    unsigned task_size;
+    AVFifoBuffer *fifo;
+    pthread_mutex_t fifo_mutex;
+    pthread_cond_t fifo_cond;
+    pthread_cond_t fifo_writable_cond;
+} FifoQueue;
+
+typedef struct {
+    AVCodecContext *avctx;
+    // input frame queue
+    FifoQueue in_frame_queue;
+    // output packet queue
+    FifoQueue out_packet_queue;
+
+    pthread_t worker;
+    atomic_int exit;
+    uint8_t enc_flushing;
+    uint8_t is_eof;
+
+    /**
+     * Encode data to an AVPacket.
+     *
+     * @param      avctx          codec context
+     * @param      avpkt          output AVPacket
+     * @param[in]  frame          AVFrame containing the raw data to be encoded
+     * @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
+     *                            non-empty packet was returned in avpkt.
+     * @return 0 on success, negative error code on failure
+     */
+    int (*es_encode_func)(struct AVCodecContext *avctx,
+                          struct AVPacket *avpkt,
+                          const struct AVFrame *frame,
+                          int *got_packet_ptr);
+} ThreadContext;
+
+int esenc_send_frame(void *tc, const AVFrame *frame);
+
+int esenc_receive_packet(void *tc, AVPacket *avpkt);
+
+int esenc_init(void **tc,
+               AVCodecContext *avctx,
+               int (*es_encode_func)(struct AVCodecContext *, struct AVPacket *, const struct AVFrame *, int *));
+
+void esenc_close(void *tc);
+#endif
diff --git a/libavcodec/esenc_h26x.c b/libavcodec/esenc_h26x.c
new file mode 100644
index 0000000000..cb00d55977
--- /dev/null
+++ b/libavcodec/esenc_h26x.c
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <float.h>
+#include <limits.h>
+#include "libavutil/opt.h"
+#include "hwconfig.h"
+#include "esenc_vid.h"
+#include "codec_internal.h"
+
+#define OFFSET(x) offsetof(ESEncVidContext, x)
+#define FLAGS (AV_OPT_FLAG_ENCODING_PARAM | AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_EXPORT)
+
+// define common options for h264 and h265 encoder
+#define ESENC_H26X_OPTS                                                                                                \
+        {"stream_type",                                                                                                \
+        "Set stream byte. 0: NAL UNIT, 1: byte stream",                                                                \
+        OFFSET(byte_stream),                                                                                           \
+        AV_OPT_TYPE_INT,                                                                                               \
+        {.i64 = 1},                                                                                                    \
+        0,                                                                                                             \
+        1,                                                                                                             \
+        FLAGS},                                                                                                        \
+        {"idr_interval", "Intra frame interval", OFFSET(intra_pic_rate), AV_OPT_TYPE_INT, {.i64 = 30}, 0, 120, FLAGS}, \
+        {"bitdepth",                                                                                                   \
+         "Bitdepth. 8=8-bit, 10=10-bit.",                                                                              \
+         OFFSET(bitdepth),                                                                                             \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 8},                                                                                                   \
+         8,                                                                                                            \
+         10,                                                                                                           \
+         FLAGS,                                                                                                        \
+         "bitdepth"},                                                                                                  \
+        {"rotation",                                                                                                   \
+         "pre-processor, rotation. 0=0 degree, 1=right 90 degree, 2=left 90 degree, 3=right 180 degree.",              \
+         OFFSET(rotation),                                                                                             \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         3,                                                                                                            \
+         FLAGS,                                                                                                        \
+         "rotation"},                                                                                                  \
+        {"0", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_ROTATE_0}, 0, 0, FLAGS, "rotation"},                             \
+        {"90R", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_ROTATE_90R}, 0, 0, FLAGS, "rotation"},                         \
+        {"90L", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_ROTATE_90L}, 0, 0, FLAGS, "rotation"},                         \
+        {"180R", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_ROTATE_180R}, 0, 0, FLAGS, "rotation"},                       \
+        {"crop",                                                                                                       \
+         "crop 'cx:N,cy:N,cw:N,ch:N',mean crop xoffset,yoffset,out_width,out_heigh",                                   \
+         OFFSET(crop_str),                                                                                             \
+         AV_OPT_TYPE_STRING,                                                                                           \
+         {.str = "cx:0,cy:0,cw:0,ch:0"},                                                                               \
+         0,                                                                                                            \
+         0,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"rc_mode",                                                                                                    \
+         "Set RC mode, CVBR: 0, CBR:1, VBR:2, ABR:3, CRF:4, CQP:5",                                                    \
+         OFFSET(rc_mode),                                                                                              \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         5,                                                                                                            \
+         FLAGS,                                                                                                        \
+         "RC"},                                                                                                        \
+        {"cvbr", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCE_RC_CVBR}, 0, 0, FLAGS, "RC"},                                   \
+        {"cbr", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCE_RC_CBR}, 0, 0, FLAGS, "RC"},                                     \
+        {"vbr", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCE_RC_VBR}, 0, 0, FLAGS, "RC"},                                     \
+        {"abr", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCE_RC_ABR}, 0, 0, FLAGS, "RC"},                                     \
+        {"crf", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCE_RC_CRF}, 0, 0, FLAGS, "RC"},                                     \
+        {"cqp", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCE_RC_CQP}, 0, 0, FLAGS, "RC"},                                     \
+        {"rc_window",                                                                                                  \
+         "Bitrate window length in frames [1..300]",                                                                   \
+         OFFSET(bitrate_window),                                                                                       \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 100},                                                                                                 \
+         1,                                                                                                            \
+         300,                                                                                                          \
+         FLAGS},                                                                                                       \
+        {"fixed_qp_I",                                                                                                 \
+         "the QP for I frame while rc mode is CQP",                                                                    \
+         OFFSET(fixed_qp_I),                                                                                           \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 30},                                                                                                  \
+         0,                                                                                                            \
+         51,                                                                                                           \
+         FLAGS},                                                                                                       \
+        {"fixed_qp_B",                                                                                                 \
+         "the QP for B frame while rc mode is CQP",                                                                    \
+         OFFSET(fixed_qp_B),                                                                                           \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 32},                                                                                                  \
+         0,                                                                                                            \
+         51,                                                                                                           \
+         FLAGS},                                                                                                       \
+        {"fixed_qp_P",                                                                                                 \
+         "the QP for P frame while rc mode is CQP",                                                                    \
+         OFFSET(fixed_qp_P),                                                                                           \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 32},                                                                                                  \
+         0,                                                                                                            \
+         51,                                                                                                           \
+         FLAGS},                                                                                                       \
+        {"slice_size",                                                                                                 \
+         "slice size in number of CTU rows. (default [0], 0..height/ctu_size)",                                        \
+         OFFSET(slice_size),                                                                                           \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         INT_MAX,                                                                                                      \
+         FLAGS},                                                                                                       \
+        {"enable_sei",                                                                                                 \
+         "Enable SEI message, 0: disable, 1:enable",                                                                   \
+         OFFSET(enable_sei),                                                                                           \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"enable_deblock",                                                                                             \
+         "Enable deblock filter",                                                                                      \
+         OFFSET(enable_deblocking),                                                                                    \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 1},                                                                                                   \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"roi",                                                                                                        \
+         "roi area config, 'rN:enable(0/1):isAbsQp(0/1):qp value:x:y:width:height;' N: which roi area 0~7, "           \
+         "multiple rois are separated by ';'",                                                                         \
+         OFFSET(roi_str),                                                                                              \
+         AV_OPT_TYPE_STRING,                                                                                           \
+         {.str = "r0:0:1:30:0:0:63:63;r1:0:0:-30:64:0:63:63"},                                                         \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"enable_vui",                                                                                                 \
+         "Enable Write VUI timing info in SPS",                                                                        \
+         OFFSET(enable_vui),                                                                                           \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 1},                                                                                                   \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"svct_maxlayer", "set SVC-T max layers", OFFSET(max_TLayers), AV_OPT_TYPE_INT, {.i64 = 1}, 1, 5, FLAGS},      \
+        {"b_nums", "set number of B frame between P-P", OFFSET(b_nums), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 4, FLAGS},     \
+        {"insert_aud", "insert AUD nal type. 1:enable", OFFSET(insert_AUD), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, FLAGS}, \
+        {"insert_sps_pps",                                                                                             \
+         "force insert sps pps nal.1:enable",                                                                          \
+         OFFSET(insert_SPS_PPS),                                                                                       \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"stride_align",                                                                                               \
+         "set the stride alignment of input frame, multiple of 16",                                                    \
+         OFFSET(exp_of_input_alignment),                                                                               \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 64},                                                                                                  \
+         64,                                                                                                           \
+         4096,                                                                                                         \
+         FLAGS},                                                                                                       \
+        {"hdr10_display",                                                                                              \
+         "hdr10display config, 'enable:dx0:dy0:dx1:dy1:dx2:dy2:wx:wy:max:min'.",                                       \
+         OFFSET(hdr_display_str),                                                                                      \
+         AV_OPT_TYPE_STRING,                                                                                           \
+         {.str = "h0:0:0:0:0:0:0:0:0:0:0"},                                                                            \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"hdr10_light",                                                                                                \
+         "hdr10light config, 'enable:maxlevel:avglevel'.",                                                             \
+         OFFSET(hdr_light_str),                                                                                        \
+         AV_OPT_TYPE_STRING,                                                                                           \
+         {.str = "h0:0:0"},                                                                                            \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"hdr10_color",                                                                                                \
+         "hdr10color config, 'enable:primary:matrix:transfer'.",                                                       \
+         OFFSET(hdr_color_str),                                                                                        \
+         AV_OPT_TYPE_STRING,                                                                                           \
+         {.str = "h0:9:9:0"},                                                                                          \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"skip_cumap_enable",                                                                                          \
+         "enable skip CU map,0: disable,1: enable",                                                                    \
+         OFFSET(skip_map_enable),                                                                                      \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"roi_qpmap_enable",                                                                                           \
+         "enable roi qp map,0: disable,1: enable",                                                                     \
+         OFFSET(roi_map_delta_qp_enable),                                                                              \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"enable_const_chroma",                                                                                        \
+         "enable setting chroma a constant pixel value.",                                                              \
+         OFFSET(const_chroma_en),                                                                                      \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"const_cb",                                                                                                   \
+         "The constant pixel value for Cb. for 8bit default [0], 0..255, for 10bit default [0], 0..1023)",             \
+         OFFSET(const_cb),                                                                                             \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         1023,                                                                                                         \
+         FLAGS},                                                                                                       \
+        {"const_cr",                                                                                                   \
+         "The constant pixel value for Cr. for 8bit 0..255, for 10bit 0..1023)",                                       \
+         OFFSET(const_cr),                                                                                             \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         1023,                                                                                                         \
+         FLAGS},                                                                                                       \
+        {"rdo_level",                                                                                                  \
+         "Programable hardware RDO Level.Lower value means lower quality but better performance, "                     \
+         "Higher value means higher quality but worse performance.",                                                   \
+         OFFSET(rdo_level),                                                                                            \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 1},                                                                                                   \
+         1,                                                                                                            \
+         3,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"ipcm",                                                                                                       \
+         "ipcm area config, 'iN:enable(0/1):x:y:width:height;' N: which ipcm area 0~1, "                               \
+         "multiple ipcm are separated by ';'",                                                                         \
+         OFFSET(ipcm_str),                                                                                             \
+         AV_OPT_TYPE_STRING,                                                                                           \
+         {.str = "i0:0:0:0:63:63;i1:0:64:0:63:63"},                                                                    \
+         0,                                                                                                            \
+         1,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"linebuf_mode",                                                                                               \
+         "The line buf mode.0 = Disable input line buffer.1 = Enable SW handshaking Loop-back enabled.2 = Enable HW "  \
+         "handshaking Loop-back enabled.3 = Enable SW handshaking Loop-back disabled.4 = Enable HW handshaking "       \
+         "Loop-back disabled.",                                                                                        \
+         OFFSET(input_line_buf_mode),                                                                                  \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         4,                                                                                                            \
+         FLAGS},                                                                                                       \
+        {"linebuf_depth",                                                                                              \
+         "The number of CTB/MB rows to control loop-back and handshaking",                                             \
+         OFFSET(input_line_buf_depth),                                                                                 \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 1},                                                                                                   \
+         0,                                                                                                            \
+         511,                                                                                                          \
+         FLAGS},                                                                                                       \
+        {"linebuf_amount",                                                                                             \
+         "Handshake sync amount for every loop-back.",                                                                 \
+         OFFSET(amount_per_loop_back),                                                                                 \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 1},                                                                                                   \
+         0,                                                                                                            \
+         1023,                                                                                                         \
+         FLAGS},                                                                                                       \
+        {"dump_path", "dump directory", OFFSET(dump_path), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, FLAGS},            \
+        {"frame_dump", "frame dump enable", OFFSET(dump_frame_enable), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, FLAGS},      \
+        {"packet_dump", "packet dump enable", OFFSET(dump_pkt_enable), AV_OPT_TYPE_INT, {.i64 = 0}, 0, 1, FLAGS},      \
+        {"frame_dump_time",                                                                                            \
+         "the time length of dumpping frame",                                                                          \
+         OFFSET(dump_frame_time),                                                                                      \
+         AV_OPT_TYPE_INT,                                                                                              \
+         {.i64 = 0},                                                                                                   \
+         0,                                                                                                            \
+         INT_MAX,                                                                                                      \
+         FLAGS},                                                                                                       \
+    {                                                                                                                  \
+        "packet_dump_time", "the time length of dumpping packet", OFFSET(dump_pkt_time), AV_OPT_TYPE_INT, {.i64 = 0},  \
+            0, INT_MAX, FLAGS                                                                                          \
+    }
+
+static const AVOption h264_es_options[] = {
+    // encoder common setting
+    ESENC_H26X_OPTS,
+    {"profile",
+     "Set encode profile.[9, 12]: 9-Baseline, 10-Main, 11-High, 12-High 10",
+     OFFSET(profile),
+     AV_OPT_TYPE_INT,
+     {.i64 = 11},
+     9,
+     12,
+     FLAGS,
+     "profile"},
+    {"baseline", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_BASE_PROFILE}, 0, 0, FLAGS, "profile"},
+    {"main", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_MAIN_PROFILE}, 0, 0, FLAGS, "profile"},
+    {"high", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_HIGH_PROFILE}, 0, 0, FLAGS, "profile"},
+    {"high10", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_HIGH_10_PROFILE}, 0, 0, FLAGS, "profile"},
+    {"level", "Set encode level.[10, 99]", OFFSET(level), AV_OPT_TYPE_INT, {.i64 = 51}, 10, 99, FLAGS, "level"},
+    {"1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_1}, 0, 0, FLAGS, "level"},
+    {"1.b", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_1_b}, 0, 0, FLAGS, "level"},
+    {"1.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_1_1}, 0, 0, FLAGS, "level"},
+    {"1.2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_1_2}, 0, 0, FLAGS, "level"},
+    {"1.3", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_1_3}, 0, 0, FLAGS, "level"},
+    {"2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_2}, 0, 0, FLAGS, "level"},
+    {"2.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_2_1}, 0, 0, FLAGS, "level"},
+    {"2.2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_2_2}, 0, 0, FLAGS, "level"},
+    {"3", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_3}, 0, 0, FLAGS, "level"},
+    {"3.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_3_1}, 0, 0, FLAGS, "level"},
+    {"3.2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_3_2}, 0, 0, FLAGS, "level"},
+    {"4", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_4}, 0, 0, FLAGS, "level"},
+    {"4.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_4_1}, 0, 0, FLAGS, "level"},
+    {"4.2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_4_2}, 0, 0, FLAGS, "level"},
+    {"5", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_5}, 0, 0, FLAGS, "level"},
+    {"5.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_5_1}, 0, 0, FLAGS, "level"},
+    {"5.2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_5_2}, 0, 0, FLAGS, "level"},
+    {"6", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_6}, 0, 0, FLAGS, "level"},
+    {"6.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_6_1}, 0, 0, FLAGS, "level"},
+    {"6.2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_H264_LEVEL_6_2}, 0, 0, FLAGS, "level"},
+    {"enable_cabac",
+     "entropy coding mode, 0:CAVLC, 1:CABAC",
+     OFFSET(enable_cabac),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1,
+     FLAGS},
+    {NULL},
+};
+
+static const AVOption h265_es_options[] = {
+    // encoder common setting
+    ESENC_H26X_OPTS,
+    {"profile",
+     "Set encode profile.[0, 3]: 0-Main, 1-Main Still, 2-Main 10, 3-Mainrext",
+     OFFSET(profile),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     3,
+     FLAGS,
+     "profile"},
+    {"main", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_MAIN_PROFILE}, 0, 0, FLAGS, "profile"},
+    {"main_still", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_MAIN_STILL_PICTURE_PROFILE}, 0, 0, FLAGS, "profile"},
+    {"main10", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_MAIN_10_PROFILE}, 0, 0, FLAGS, "profile"},
+    {"main_rext", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_MAINREXT}, 0, 0, FLAGS, "profile"},
+    {"level", "Set encode level.[30, 186]", OFFSET(level), AV_OPT_TYPE_INT, {.i64 = 180}, 30, 186, FLAGS, "level"},
+    {"1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_1}, 0, 0, FLAGS, "level"},
+    {"2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_2}, 0, 0, FLAGS, "level"},
+    {"2.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_2_1}, 0, 0, FLAGS, "level"},
+    {"3", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_3}, 0, 0, FLAGS, "level"},
+    {"3.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_3_1}, 0, 0, FLAGS, "level"},
+    {"4", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_4}, 0, 0, FLAGS, "level"},
+    {"4.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_4_1}, 0, 0, FLAGS, "level"},
+    {"5", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_5}, 0, 0, FLAGS, "level"},
+    {"5.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_5_1}, 0, 0, FLAGS, "level"},
+    {"5.2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_5_2}, 0, 0, FLAGS, "level"},
+    {"6", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_6}, 0, 0, FLAGS, "level"},
+    {"6.1", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_6_1}, 0, 0, FLAGS, "level"},
+    {"6.2", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_LEVEL_6_2}, 0, 0, FLAGS, "level"},
+    {"tier",
+     "Set tier.[0, 1]: 0-Main tier, 1-High tier)",
+     OFFSET(tier),
+     AV_OPT_TYPE_INT,
+     {.i64 = 0},
+     0,
+     1,
+     FLAGS,
+     "tier"},
+    {"main", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_MAIN_TIER}, 0, 0, FLAGS, "tier"},
+    {"high", "", 0, AV_OPT_TYPE_CONST, {.i64 = VCENC_HEVC_HIGH_TIER}, 0, 0, FLAGS, "tier"},
+    {"enable_sao", "enable SAO. 0: disable, 1: enable.", OFFSET(enable_sao), AV_OPT_TYPE_INT, {.i64 = 1}, 0, 1, FLAGS},
+    {NULL},
+};
+
+static const AVCodecHWConfigInternal *esenc_h26x_hw_configs[] = {
+    &(const AVCodecHWConfigInternal){
+        .public =
+            {
+                .pix_fmt = AV_PIX_FMT_ES,
+                .methods = AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX | AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX
+                           | AV_CODEC_HW_CONFIG_METHOD_INTERNAL,
+                .device_type = AV_HWDEVICE_TYPE_ES,
+            },
+        .hwaccel = NULL,
+    },
+    NULL};
+
+static const enum AVPixelFormat esenc_h26x_support_pixfmts[] = {AV_PIX_FMT_ES,
+                                                                AV_PIX_FMT_YUV420P,
+                                                                AV_PIX_FMT_NV12,
+                                                                AV_PIX_FMT_NV21,
+                                                                AV_PIX_FMT_UYVY422,
+                                                                AV_PIX_FMT_YUYV422,
+                                                                AV_PIX_FMT_YUV420P10LE,
+                                                                AV_PIX_FMT_P010LE,
+                                                                AV_PIX_FMT_NONE};
+
+#define ESENC_H26X_ENCODER(codectype, CODECTYPE)                           \
+    static const AVClass codectype##_es_encoder_class = {                  \
+        .class_name = #codectype "_es_encoder",                            \
+        .item_name = av_default_item_name,                                 \
+        .option = codectype##_es_options,                                  \
+        .version = LIBAVUTIL_VERSION_INT,                                  \
+    };                                                                     \
+    FFCodec ff_##codectype##_es_encoder = {                                \
+        .p.name = #codectype "_es_encoder",                                  \
+        .p.long_name = NULL_IF_CONFIG_SMALL("ESWIN " #codectype " Encoder"), \
+        .p.type = AVMEDIA_TYPE_VIDEO,                                        \
+        .p.id = AV_CODEC_ID_##CODECTYPE,                                     \
+        .priv_data_size = sizeof(ESEncVidContext),                         \
+        .init = &ff_vsv_h26x_encode_init,                                  \
+        .close = &ff_vsv_h26x_encode_close,                                \
+        FF_CODEC_RECEIVE_PACKET_CB(ff_vsv_h26x_encode_receive_packet),    \
+        .p.priv_class = &codectype##_es_encoder_class,                       \
+        .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE,        \
+        .p.pix_fmts = esenc_h26x_support_pixfmts,                            \
+        .hw_configs = esenc_h26x_hw_configs,                               \
+        .p.wrapper_name = "es",                                              \
+    };
+
+ESENC_H26X_ENCODER(h264, H264)
+ESENC_H26X_ENCODER(h265, H265)
+
+#undef ESENC_H26X_ENCODER
diff --git a/libavcodec/esenc_vid.c b/libavcodec/esenc_vid.c
new file mode 100644
index 0000000000..6d649932dd
--- /dev/null
+++ b/libavcodec/esenc_vid.c
@@ -0,0 +1,4120 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <float.h>
+#include <limits.h>
+
+#include "libavutil/fifo.h"
+#include "libavutil/avassert.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/thread.h"
+#include "libavutil/eval.h"
+#include "libavutil/internal.h"
+#include "libavutil/opt.h"
+#include "libavutil/mem.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/stereo3d.h"
+#include "libavutil/intreadwrite.h"
+#include "avcodec.h"
+#include "hwconfig.h"
+#include "internal.h"
+#include "esenc_vid.h"
+#include "es_common.h"
+#include "hevcencapi_utils.h"
+#include "esenc_vid_internal.h"
+#include "esenc_vid_buffer.h"
+#include "encode.h"
+
+// config if encoding the cu info, only for testing.
+// now we don't have good way to pass the cu info data to user
+//#define DEBUG_CU_INFO
+
+extern uint32_t getEWLMallocInoutSize(uint32_t alignment, uint32_t in_size);
+
+int32_t vce_default_bitrate[] = {100000, 250000, 500000, 1000000, 3000000, 5000000, 10000000};
+
+static void venc_print_roi(RoiParas *roi_paras) {
+    if (!roi_paras) return;
+
+    av_log(NULL, AV_LOG_INFO, "roi config cnt: %d\n", roi_paras->num_of_roi);
+    for (int i = 0; i < roi_paras->num_of_roi; i++) {
+        av_log(NULL,
+               AV_LOG_INFO,
+               "roi index: %d, enable: %d, absQp: %d, qp: %d, (%4d, %4d, %4d, %4d)\n",
+               roi_paras->roi_attr[i].index,
+               roi_paras->roi_attr[i].enable,
+               roi_paras->roi_attr[i].is_absQp,
+               roi_paras->roi_attr[i].qp,
+               roi_paras->roi_attr[i].x,
+               roi_paras->roi_attr[i].y,
+               roi_paras->roi_attr[i].width,
+               roi_paras->roi_attr[i].height);
+    }
+}
+
+/* parse roi option*/
+// format: "r0:0:0:0:0:0:0:0;r1:0:0:0:0:0:0:0"
+static int venc_get_roi(char *str, RoiParas *roi_paras) {
+    char *p = str;
+    unsigned int cnt = 0;
+    RoiAttr *roi_attr = NULL;
+
+    if (!str || !roi_paras) return -1;
+
+    memset(roi_paras, 0x00, sizeof(RoiParas));
+
+    while ((p = strstr(p, "r")) != NULL) {
+        roi_attr = &roi_paras->roi_attr[cnt];
+        // index
+        roi_attr->index = atoi(p + 1);
+
+        // enable
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        roi_attr->enable = atoi(p);
+        // absQp
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        roi_attr->is_absQp = atoi(p);
+        // qp
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        roi_attr->qp = atoi(p);
+        // left
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        roi_attr->x = atoi(p);
+        // top
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        roi_attr->y = atoi(p);
+        // right
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        roi_attr->width = atoi(p);
+        // bottom
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        roi_attr->height = atoi(p);
+
+        // num
+        cnt++;
+        if (cnt >= MAX_ROI_NUM) break;
+    }
+
+    roi_paras->num_of_roi = cnt;
+    // venc_print_roi(roi_paras);
+
+    return 0;
+}
+
+static void venc_print_ipcm(IpcmParas *ipcm_paras) {
+    if (!ipcm_paras) return;
+
+    av_log(NULL, AV_LOG_INFO, "ipcm config cnt: %d\n", ipcm_paras->num_of_ipcm);
+    for (int i = 0; i < ipcm_paras->num_of_ipcm; i++) {
+        av_log(NULL,
+               AV_LOG_INFO,
+               "ipcm index: %d, enable: %d, (%d, %d, %d, %d)\n",
+               ipcm_paras->ipcm_attr[i].index,
+               ipcm_paras->ipcm_attr[i].enable,
+               ipcm_paras->ipcm_attr[i].x,
+               ipcm_paras->ipcm_attr[i].y,
+               ipcm_paras->ipcm_attr[i].width,
+               ipcm_paras->ipcm_attr[i].height);
+    }
+}
+
+/* parse ipcm option*/
+// format: "i0:0:0:0:0:0;i1:0:0:0:0:0"
+static int venc_get_ipcm(char *str, IpcmParas *ipcm_paras) {
+    char *p = str;
+    unsigned int cnt = 0;
+    IpcmAttr *ipcm_attr = NULL;
+
+    if (!str || !ipcm_paras) return -1;
+
+    memset(ipcm_paras, 0x00, sizeof(IpcmParas));
+
+    while ((p = strstr(p, "i")) != NULL) {
+        ipcm_attr = &ipcm_paras->ipcm_attr[cnt];
+        // index
+        ipcm_attr->index = atoi(p + 1);
+        // enable
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        ipcm_attr->enable = atoi(p);
+        // left
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        ipcm_attr->x = atoi(p);
+        // top
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        ipcm_attr->y = atoi(p);
+        // right
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        ipcm_attr->width = atoi(p);
+        // bottom
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        ipcm_attr->height = atoi(p);
+
+        // num
+        cnt++;
+        if (cnt >= MAX_IPCM_NUM) break;
+    }
+
+    ipcm_paras->num_of_ipcm = cnt;
+    // venc_print_ipcm(ipcm_paras);
+
+    return 0;
+}
+
+/* parse hdr10display option*/
+// format: "h0:0:0:0:0:0:0:0:0:0:0"
+static int venc_get_hdr10_display(char *str, Hdr10DisplayAttr *Hdr10DisplayAttr) {
+    char *pt = str;
+    if (!str || !Hdr10DisplayAttr) return -1;
+
+    while ((pt = strstr(pt, "h")) != NULL) {
+        // enable
+        Hdr10DisplayAttr->hdr10_display_enable = atoi(pt + 1);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // dx0
+        Hdr10DisplayAttr->hdr10_dx0 = atoi(pt);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // dy0
+        Hdr10DisplayAttr->hdr10_dy0 = atoi(pt);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // dx1
+        Hdr10DisplayAttr->hdr10_dx1 = atoi(pt);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // dy1
+        Hdr10DisplayAttr->hdr10_dy1 = atoi(pt);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // dx2
+        Hdr10DisplayAttr->hdr10_dx2 = atoi(pt);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // dy2
+        Hdr10DisplayAttr->hdr10_dy2 = atoi(pt);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // wx
+        Hdr10DisplayAttr->hdr10_wx = atoi(pt);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // wy
+        Hdr10DisplayAttr->hdr10_wy = atoi(pt);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // max
+        Hdr10DisplayAttr->hdr10_maxluma = atoi(pt);
+        if ((pt = strstr(pt, ":")) == NULL) return -1;
+        pt++;
+        // min
+        Hdr10DisplayAttr->hdr10_minluma = atoi(pt);
+    }
+
+    av_log(NULL,
+           AV_LOG_INFO,
+           "HDR10 Display: enable:%d, dx0=%d, dy0=%d, dx1=%d, dy1=%d, dx2=%d, dy2=%d, wx=%d, wy=%d, maxluma=%d, "
+           "minluma=%d .\n",
+           Hdr10DisplayAttr->hdr10_display_enable,
+           Hdr10DisplayAttr->hdr10_dx0,
+           Hdr10DisplayAttr->hdr10_dy0,
+           Hdr10DisplayAttr->hdr10_dx1,
+           Hdr10DisplayAttr->hdr10_dx1,
+           Hdr10DisplayAttr->hdr10_dx2,
+           Hdr10DisplayAttr->hdr10_dx2,
+           Hdr10DisplayAttr->hdr10_wx,
+           Hdr10DisplayAttr->hdr10_wy,
+           Hdr10DisplayAttr->hdr10_maxluma,
+           Hdr10DisplayAttr->hdr10_minluma);
+
+    return 0;
+}
+/* parse hdr10light option*/
+// format: "h0:0:0"
+static int venc_get_hdr10_light(char *str, Hdr10LightAttr *Hdr10LightAttr) {
+    char *p = str;
+    if (!str || !Hdr10LightAttr) return -1;
+
+    while ((p = strstr(p, "h")) != NULL) {
+        // enable
+        Hdr10LightAttr->hdr10_lightlevel_enable = atoi(p + 1);
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        // maxlevel
+        Hdr10LightAttr->hdr10_maxlight = atoi(p);
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        // avglevel
+        Hdr10LightAttr->hdr10_avglight = atoi(p);
+    }
+
+    av_log(NULL,
+           AV_LOG_INFO,
+           "HDR10 Light: enable:%d, maxlevel=%d, avglevel=%d. \n",
+           Hdr10LightAttr->hdr10_lightlevel_enable,
+           Hdr10LightAttr->hdr10_maxlight,
+           Hdr10LightAttr->hdr10_avglight);
+    return 0;
+}
+
+/* parse hdr10color option*/
+// format: "h0:9:9:0"
+static int venc_get_hdr10_color(char *str, Hdr10ColorAttr *Hdr10ColorAttr) {
+    char *p = str;
+    if (!str || !Hdr10ColorAttr) return -1;
+
+    while ((p = strstr(p, "h")) != NULL) {
+        // enable
+        Hdr10ColorAttr->hdr10_color_enable = atoi(p + 1);
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        // primary
+        Hdr10ColorAttr->hdr10_primary = atoi(p);
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        // matrix
+        Hdr10ColorAttr->hdr10_matrix = atoi(p);
+        if ((p = strstr(p, ":")) == NULL) return -1;
+        p++;
+        // transfer
+        Hdr10ColorAttr->hdr10_transfer = atoi(p);
+    }
+
+    av_log(NULL,
+           AV_LOG_INFO,
+           "HDR10 Color: enable:%d, primary=%d, matrix=%d, transfer:%d. \n",
+           Hdr10ColorAttr->hdr10_color_enable,
+           Hdr10ColorAttr->hdr10_primary,
+           Hdr10ColorAttr->hdr10_matrix,
+           Hdr10ColorAttr->hdr10_transfer);
+
+    return 0;
+}
+
+static int32_t vsv_check_area(VCEncPictureArea *area, ESEncVidContext *ctx) {
+    int32_t w = (ctx->width + ctx->max_cu_size - 1) / ctx->max_cu_size;
+    int32_t h = (ctx->height + ctx->max_cu_size - 1) / ctx->max_cu_size;
+
+    // av_log(NULL, AV_LOG_INFO, "vsv_check_area, w: %d, h: %d\n", w, h);
+    // av_log(NULL, AV_LOG_INFO, "vsv_check_area, %d-%d-%d-%d\n", area->left, area->top, area->right, area->bottom);
+
+    if ((area->left < (uint32_t)w) && (area->right < (uint32_t)w) && (area->top < (uint32_t)h)
+        && (area->bottom < (uint32_t)h))
+        return 1;
+
+    return 0;
+}
+
+static int vce_get_res_index(int w, int h) {
+    if (w * h >= 3840 * 2160) {
+        return 6;
+    } else if (w * h >= 1920 * 1080) {
+        return 5;
+    } else if (w * h >= 1280 * 720) {
+        return 4;
+    } else if (w * h >= 854 * 480) {
+        return 3;
+    } else if (w * h >= 640 * 360) {
+        return 2;
+    } else if (w * h >= 428 * 240) {
+        return 1;
+    }
+    return 0;
+}
+
+static int vsv_encode_set_vceparam(AVCodecContext *avctx) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidContext *options = ctx;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+    uint32_t width, height;
+
+    /* get default bitrate or limit bitrate */
+    width = options->width;
+    height = options->height;
+    av_log(NULL, AV_LOG_DEBUG, "check bitrate by width %d height %d\n", width, height);
+
+    if (options->bit_per_second == DEFAULT_VALUE) {
+        int res_index = vce_get_res_index(width, height);
+        options->bit_per_second = vce_default_bitrate[res_index];
+        av_log(NULL, AV_LOG_DEBUG, "get default bitrate %d\n", options->bit_per_second);
+    }
+    return 0;
+}
+
+static int vsv_preset_params_set(AVCodecContext *avctx) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidContext *options = ctx;
+    VSVPreset preset = 0;
+
+    av_log(avctx, AV_LOG_DEBUG, "+++ vcepreset %s\n", ctx->preset);
+
+    if (ctx->preset) {
+        if (strcmp(ctx->preset, "superfast") == 0) {
+            preset = VSV_PRESET_SUPERFAST;
+        } else if (strcmp(ctx->preset, "fast") == 0) {
+            preset = VSV_PRESET_FAST;
+        } else if (strcmp(ctx->preset, "medium") == 0) {
+            preset = VSV_PRESET_MEDIUM;
+        } else if (strcmp(ctx->preset, "slow") == 0) {
+            preset = VSV_PRESET_SLOW;
+        } else if (strcmp(ctx->preset, "superslow") == 0) {
+            preset = VSV_PRESET_SUPERSLOW;
+        } else {
+            av_log(avctx, AV_LOG_ERROR, "unknow vcepreset %s\n", ctx->preset);
+            return -1;
+        }
+
+        if (options->codec_format == VCENC_VIDEO_CODEC_HEVC) {
+            switch (preset) {
+                case VSV_PRESET_SUPERFAST:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 1;
+                    if (options->rdo_level == DEFAULT) options->rdo_level = 1;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 0;
+                    break;
+                case VSV_PRESET_FAST:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 4;
+                    if (options->rdo_level == DEFAULT) options->rdo_level = 1;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 0;
+                    break;
+                case VSV_PRESET_MEDIUM:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 4;
+                    if (options->rdo_level == DEFAULT) options->rdo_level = 1;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 20;
+                    break;
+                case VSV_PRESET_SLOW:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 0;
+                    if (options->rdo_level == DEFAULT) options->rdo_level = 2;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 30;
+                    break;
+                case VSV_PRESET_SUPERSLOW:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 0;
+                    if (options->rdo_level == DEFAULT) options->rdo_level = 3;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 40;
+                    break;
+                case VSV_PRESET_NONE:
+                    break;
+                default:
+                    av_log(avctx, AV_LOG_ERROR, "unknow preset %d\n", preset);
+                    return -1;
+            }
+
+        } else if (options->codec_format == VCENC_VIDEO_CODEC_H264) {
+            switch (preset) {
+                case VSV_PRESET_SUPERFAST:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 1;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 0;
+                    break;
+                case VSV_PRESET_FAST:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 4;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 0;
+                    break;
+                case VSV_PRESET_MEDIUM:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 4;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 20;
+                    break;
+                case VSV_PRESET_SLOW:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 0;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 30;
+                    break;
+                case VSV_PRESET_SUPERSLOW:
+                    if (options->intra_qp_delta == DEFAULT) options->intra_qp_delta = -2;
+                    if (options->qp_hdr == DEFAULT) options->qp_hdr = -1;
+                    if (options->pic_rc == DEFAULT) options->pic_rc = 1;
+                    if (options->ctb_rc == DEFAULT) options->ctb_rc = 0;
+                    if (options->gop_size == DEFAULT) options->gop_size = 0;
+                    if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 40;
+                    break;
+                case VSV_PRESET_NONE:
+                    break;
+                default:
+                    av_log(avctx, AV_LOG_ERROR, "unknow preset %d\n", preset);
+                    return -1;
+            }
+        }
+    } else {
+        if (options->rdo_level == DEFAULT) options->rdo_level = 1;
+        if (options->gop_size == DEFAULT) options->gop_size = 0;
+        if (options->lookahead_depth == DEFAULT) options->lookahead_depth = 0;
+    }
+
+    return 0;
+}
+
+static int esenc_vid_validate_options(ESEncVidContext *esenc_vide_ctx) {
+    if (!esenc_vide_ctx) {
+        av_log(NULL, AV_LOG_ERROR, "esenc_vid_check_resolution, esenc_vide_ctx is NULL\n");
+        return -1;
+    }
+
+    // check resolution
+    if (IS_H264(esenc_vide_ctx->codec_format)) {
+        if (esenc_vide_ctx->width < 136 || esenc_vide_ctx->width > 8192 || esenc_vide_ctx->height < 128
+            || esenc_vide_ctx->height > 8640) {
+            av_log(NULL, AV_LOG_ERROR, "unsupport resolution: %dx%d\n", esenc_vide_ctx->width, esenc_vide_ctx->height);
+            return -1;
+        }
+    } else {
+        if (esenc_vide_ctx->width < 144 || esenc_vide_ctx->width > 8192 || esenc_vide_ctx->height < 128
+            || esenc_vide_ctx->height > 8640) {
+            av_log(NULL, AV_LOG_ERROR, "unsupport resolution: %dx%d\n", esenc_vide_ctx->width, esenc_vide_ctx->height);
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int vsv_encode_set_default_opt(AVCodecContext *avctx) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidContext *options = ctx;
+    enum AVPixelFormat pix_fmt = avctx->pix_fmt;
+    int i;
+
+    /*stride*/
+    // hw request input frame alignment must >= 64
+    if (options->exp_of_input_alignment < 64 && options->exp_of_input_alignment % 16) {
+        av_log(NULL, AV_LOG_WARNING, "force stride from %d to 64\n", options->exp_of_input_alignment);
+        options->exp_of_input_alignment = 64;
+    }
+    options->exp_of_input_alignment = log2(options->exp_of_input_alignment);
+    // input raw pictrure W and H
+    options->lum_width_src = FFALIGN(avctx->width, 1 << options->exp_of_input_alignment);
+    options->lum_height_src = avctx->height;
+
+    // encoded streaming w and h
+    options->width = avctx->width;
+    options->height = avctx->height;
+
+    CropInfo crop_info;
+    // Parse crop string.
+    if (ff_codec_get_crop(options->crop_str, &crop_info)) {
+        av_log(NULL, AV_LOG_ERROR, "parser crop config error\n");
+        return -1;
+    }
+
+    av_log(NULL,
+           AV_LOG_DEBUG,
+           "crop info: w:%d, h:%d, x:%d, y:%d\n",
+           crop_info.crop_width,
+           crop_info.crop_height,
+           crop_info.crop_xoffset,
+           crop_info.crop_yoffset);
+
+    if (crop_info.crop_width > 0) options->width = crop_info.crop_width;
+    if (crop_info.crop_height > 0) options->height = crop_info.crop_height;
+
+    if (crop_info.crop_xoffset >= 0) options->hor_offset_src = crop_info.crop_xoffset;
+    if (crop_info.crop_yoffset >= 0) options->ver_offset_src = crop_info.crop_yoffset;
+
+    // framerate,ffmpeg video common option
+    options->output_rate_denom = avctx->framerate.den;
+    options->output_rate_numer = avctx->framerate.num;
+
+    if (pix_fmt == AV_PIX_FMT_ES) {
+        pix_fmt = avctx->sw_pix_fmt;
+    }
+
+    switch (pix_fmt) {
+        case AV_PIX_FMT_YUV420P:
+            options->input_format = VCENC_YUV420_PLANAR;
+            break;
+        case AV_PIX_FMT_NV12:
+            options->input_format = VCENC_YUV420_SEMIPLANAR;
+            break;
+        case AV_PIX_FMT_NV21:
+            options->input_format = VCENC_YUV420_SEMIPLANAR_VU;
+            break;
+        case AV_PIX_FMT_UYVY422:
+            options->input_format = VCENC_YUV422_INTERLEAVED_UYVY;
+            break;
+        case AV_PIX_FMT_YUYV422:
+            options->input_format = VCENC_YUV422_INTERLEAVED_YUYV;
+            break;
+        case AV_PIX_FMT_YUV420P10LE:
+            options->input_format = VCENC_YUV420_PLANAR_10BIT_I010;
+            break;
+        case AV_PIX_FMT_P010LE:
+            options->input_format = VCENC_YUV420_PLANAR_10BIT_P010;
+            break;
+        default:
+            av_log(NULL, AV_LOG_ERROR, "pix_fmt: %s not support\n", ff_vsv_encode_get_fmt_char(pix_fmt));
+            return -1;
+    }
+
+    options->format_customized_type = -1;
+
+    options->max_cu_size = 64;
+    options->min_cu_size = 8;
+    options->max_tr_size = 16;
+    options->min_tr_size = 4;
+    options->tr_depth_intra = 2;  // mfu =>0
+    options->tr_depth_inter = (options->max_cu_size == 64) ? 4 : 3;
+    // options->intra_pic_rate   = 0;  // only first is idr.
+    if (!strcmp(avctx->codec->name, "h265_es_encoder")) {
+        options->codec_format = VCENC_VIDEO_CODEC_HEVC;
+        options->roi_map_delta_qp_block_unit = 3;
+    } else if (!strcmp(avctx->codec->name, "h264_es_encoder")) {
+        options->codec_format = VCENC_VIDEO_CODEC_H264;
+        options->max_cu_size = 16;
+        options->min_cu_size = 8;
+        options->max_tr_size = 16;
+        options->min_tr_size = 4;
+        options->tr_depth_intra = 1;
+        options->tr_depth_inter = 2;
+        options->roi_map_delta_qp_block_unit = 2;
+    }
+
+    options->tol_moving_bit_rate = 2000;
+    options->monitor_frames = DEFAULT;
+    options->u32_static_scene_ibit_percent = 80;
+    // options->intra_qp_delta = DEFAULT;
+    // options->b_frame_qp_delta = -1;
+
+    options->tc_offset = 0;
+    options->beta_offset = 0;
+
+    options->smooth_psnr_in_gop = 0;
+
+    // options->byte_stream = 1;
+
+    // options->chroma_qp_offset = 0;
+
+    options->strong_intra_smoothing_enabled_flag = 0;
+
+    options->pcm_loop_filter_disabled_flag = 0;
+
+    options->intra_area_left = options->intra_area_right = options->intra_area_top = options->intra_area_bottom =
+        -1; /* disabled */
+    // options->ipcm1_area_left = options->ipcm1_area_right = options->ipcm1_area_top = options->ipcm1_area_bottom =
+    //     -1; /* disabled */
+    // options->ipcm2_area_left = options->ipcm2_area_right = options->ipcm2_area_top = options->ipcm2_area_bottom =
+    //     -1; /* disabled */
+    options->gdr_duration = 0;
+
+    options->cabac_init_flag = 0;
+    options->cir_start = 0;
+    options->cir_interval = 0;
+    options->enable_deblock_override = 0;
+    options->deblock_override = 0;
+
+    options->enable_scaling_list = 0;
+
+    options->compressor = 0;
+    options->block_rc_size = DEFAULT;
+    options->rc_qp_delta_range = DEFAULT;
+    options->rc_base_mb_complexity = DEFAULT;
+    // options->pic_qp_delta_min = DEFAULT;
+    options->pic_qp_delta_max = DEFAULT;
+    // options->ctb_rc_row_qp_step = DEFAULT;
+
+    // options->bitrate_window = DEFAULT;
+    options->gop_size = options->b_nums + 1;
+    options->num_refP = 1;
+    // options->gop_cfg = NULL;
+    // options->gop_lowdelay = 0;
+    options->long_term_gap = 0;
+    options->long_term_gap_offset = 0;
+    options->long_term_qp_delta = 0;
+    options->ltr_interval = DEFAULT;
+
+    options->out_recon_frame = 1;
+
+    // options->roi_map_delta_qp_block_unit = 3;
+    // options->roi_map_delta_qp_enable = 0;
+    options->roi_map_delta_qp_file = NULL;
+    options->roi_map_delta_qp_bin_file = NULL;
+    options->roi_map_info_bin_file = NULL;
+    options->roimap_cu_ctrl_info_bin_file = NULL;
+    options->roimap_cu_ctrl_index_bin_file = NULL;
+    options->roi_cu_ctrl_ver = 0;
+    options->roi_qp_delta_ver = 1;
+    // options->ipcm_map_enable = 0;
+    options->ipcm_map_file = NULL;
+
+    options->interlaced_frame = 0;
+
+    /* low latency */
+    // options->input_line_buf_mode = 0;
+    // options->input_line_buf_depth = DEFAULT;
+    // options->amount_per_loop_back = 0;
+    options->exp_of_ref_alignment = 6;
+    options->exp_of_ref_ch_alignment = 6;
+
+    options->multimode = 0;
+
+    for (i = 0; i < MAX_STREAMS; i++) options->streamcfg[i] = NULL;
+
+#ifdef DEBUG_CU_INFO
+    options->enable_output_cu_info = 1;
+#else
+    options->enable_output_cu_info = 0;
+#endif
+    options->p010_ref_enable = 0;
+
+    // options->rdo_level = 1;
+    options->hashtype = 0;
+    options->verbose = 0;
+
+    // /* constant chroma control */
+    // options->const_chroma_en = 0;
+    // options->const_cb = DEFAULT;
+    // options->const_cr = DEFAULT;
+
+    for (i = 0; i < MAX_SCENE_CHANGE; i++) options->scene_change[i] = 0;
+
+    options->tiles_enabled_flag = 0;
+    options->num_tile_columns = 1;
+    options->num_tile_rows = 1;
+    options->loop_filter_across_tiles_enabled_flag = 1;
+
+    options->skip_frame_enabled_flag = 0;
+    options->skip_frame_poc = 0;
+
+    options->pic_order_cnt_type = 0;
+    options->log2_max_pic_order_cnt_lsb = 16;
+    options->log2_max_frame_num = 12;
+
+    options->rps_in_slice_header = 0;
+    options->ssim = 1;
+    options->cutree_blkratio = 1;
+
+    /* skip mode */
+    // options->skip_map_enable = 0;
+    options->skip_map_file = NULL;
+    options->skip_map_block_unit = 0;
+
+    /* frame level core parallel option */
+    options->parallel_core_num = 1;
+
+    // add for transcode
+    options->internal_enc_index = 0;  //-1;
+
+    /* two stream buffer */
+    options->stream_buf_chain = 0;
+
+    /*multi-segment of stream buffer*/
+    options->stream_multi_segment_mode = 0;
+    options->stream_multi_segment_amount = 4;
+
+    /*dump register*/
+    options->dump_register = 0;
+
+    options->rasterscan = 0;
+
+    // rc setting, using ffmpeg common option
+    options->bit_per_second = avctx->bit_rate;
+    options->qp_min = avctx->qmin;
+    options->qp_max = avctx->qmax;
+
+    options->qp_hdr = DEFAULT;
+    options->u32_static_scene_ibit_percent = 80;
+
+    // roi
+    if (venc_get_roi(options->roi_str, &options->roi_tbl)) {
+        av_log(NULL, AV_LOG_ERROR, "parser roi config error\n");
+        return -1;
+    }
+
+    // ipcm
+    if (venc_get_ipcm(options->ipcm_str, &options->ipcm_tbl)) {
+        av_log(NULL, AV_LOG_ERROR, "parser ipcm config error\n");
+        return -1;
+    }
+
+    // hdr10
+    if (venc_get_hdr10_display(options->hdr_display_str, &options->hdr10_display)) {
+        av_log(NULL, AV_LOG_ERROR, "parser hdr10_display config error\n");
+        return -1;
+    }
+    if (venc_get_hdr10_light(options->hdr_light_str, &options->hdr10_light)) {
+        av_log(NULL, AV_LOG_ERROR, "parser hdr10_light config error\n");
+        return -1;
+    }
+    if (venc_get_hdr10_color(options->hdr_color_str, &options->hdr10_color)) {
+        av_log(NULL, AV_LOG_ERROR, "parser hdr10_color config error\n");
+        return -1;
+    }
+
+    // validate options
+    if (esenc_vid_validate_options(options)) {
+        av_log(NULL, AV_LOG_ERROR, "esenc_vid_validate_options error\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int vsv_encode_get_options(AVCodecContext *avctx) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidContext *options = ctx;
+
+    av_log(avctx, AV_LOG_DEBUG, "+++ vsv_encode_get_options\n");
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->lum_width_src = %d\n", options->lum_width_src);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->lum_height_src = %d\n", options->lum_height_src);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->width = %d\n", options->width);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->height = %d\n", options->height);
+    av_log(avctx,
+           AV_LOG_DEBUG,
+           "+++ options->input_format = %d, pix_fmt: %d, sw_pix_fmt: %d\n",
+           options->input_format,
+           avctx->pix_fmt,
+           avctx->sw_pix_fmt);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->rotation = %d\n", options->rotation);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->bitdepth = %d\n", options->bitdepth);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->max_TLayers = %d\n", options->max_TLayers);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->mirror = %d\n", options->mirror);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->hor_offset_src = %d\n", options->hor_offset_src);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->ver_offset_src = %d\n", options->ver_offset_src);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->bit_per_second = %d\n", options->bit_per_second);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->output_rate_numer = %d\n", options->output_rate_numer);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->output_rate_denom = %d\n", options->output_rate_denom);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->intra_pic_rate = %d\n", options->intra_pic_rate);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->bitrate_window = %d\n", options->bitrate_window);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->intra_qp_delta = %d\n", options->intra_qp_delta);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->qp_hdr = %d\n", options->qp_hdr);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->qp_min = %d\n", options->qp_min);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->qp_max = %d\n", options->qp_max);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->fixed_intra_qp = %d\n", options->fixed_qp_I);
+
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->pic_skip = %d\n", options->pic_skip);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->profile = %d\n", options->profile);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->level = %d\n", options->level);
+
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->tier = %d\n", options->tier);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->exp_of_input_alignment  = %d\n", options->exp_of_input_alignment);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->exp_of_ref_alignment    = %d\n", options->exp_of_ref_alignment);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->exp_of_ref_ch_alignment = %d\n", options->exp_of_ref_ch_alignment);
+
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->byte_stream = %d\n", options->byte_stream);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->video_range = %d\n", options->video_range);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->chroma_qp_offset = %d\n", options->chroma_qp_offset);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->gop_size = %d\n", options->gop_size);
+    av_log(avctx, AV_LOG_DEBUG, "+++ options->lookahead_depth = %d\n", options->lookahead_depth);
+
+    av_log(avctx,
+           AV_LOG_DEBUG,
+           "+++ dump_path:%s, frame en:%d, pkt en:%d, frame time:%d, pkt time:%d\n",
+           options->dump_path,
+           options->dump_frame_enable,
+           options->dump_pkt_enable,
+           options->dump_frame_time,
+           options->dump_pkt_time);
+
+    return 0;
+}
+
+static void getAlignedPicSizebyFormat(int32_t type,
+                                      uint32_t width,
+                                      uint32_t height,
+                                      uint32_t alignment,
+                                      uint32_t *para_luma_size,
+                                      uint32_t *para_chroma_size,
+                                      uint32_t *para_picture_size) {
+    uint32_t luma_stride = 0, chroma_stride = 0;
+    uint32_t luma_size = 0, chroma_size = 0, picture_size = 0;
+
+    VCEncGetAlignedStride(width, type, &luma_stride, &chroma_stride, alignment);
+    switch (type) {
+        case VCENC_YUV420_PLANAR:
+            luma_size = luma_stride * height;
+            chroma_size = chroma_stride * height / 2 * 2;
+            break;
+        case VCENC_YUV420_SEMIPLANAR:
+        case VCENC_YUV420_SEMIPLANAR_VU:
+            luma_size = luma_stride * height;
+            chroma_size = chroma_stride * height / 2;
+            break;
+        case VCENC_YUV422_INTERLEAVED_YUYV:
+        case VCENC_YUV422_INTERLEAVED_UYVY:
+        case VCENC_RGB565:
+        case VCENC_BGR565:
+        case VCENC_RGB555:
+        case VCENC_BGR555:
+        case VCENC_RGB444:
+        case VCENC_BGR444:
+        case VCENC_RGB888:
+        case VCENC_BGR888:
+        case VCENC_RGB101010:
+        case VCENC_BGR101010:
+            luma_size = luma_stride * height;
+            chroma_size = 0;
+            break;
+        case VCENC_YUV420_PLANAR_10BIT_I010:
+            luma_size = luma_stride * height;
+            chroma_size = chroma_stride * height / 2 * 2;
+            break;
+        case VCENC_YUV420_PLANAR_10BIT_P010:
+
+            luma_size = luma_stride * height;
+            chroma_size = chroma_stride * height / 2;
+            break;
+        case VCENC_YUV420_PLANAR_10BIT_PACKED_PLANAR:
+            luma_size = luma_stride * 10 / 8 * height;
+            chroma_size = chroma_stride * 10 / 8 * height / 2 * 2;
+            break;
+        case VCENC_YUV420_10BIT_PACKED_Y0L2:
+            luma_size = luma_stride * 2 * 2 * height / 2;
+            chroma_size = 0;
+            break;
+        case VCENC_YUV420_SEMIPLANAR_101010:
+            luma_size = luma_stride * height;
+            chroma_size = chroma_stride * height / 2;
+            break;
+        case VCENC_YUV420_8BIT_TILE_64_4:
+        case VCENC_YUV420_UV_8BIT_TILE_64_4:
+            luma_size = luma_stride * ((height + 3) / 4);
+            chroma_size = chroma_stride * (((height / 2) + 3) / 4);
+            break;
+        case VCENC_YUV420_10BIT_TILE_32_4:
+            luma_size = luma_stride * ((height + 3) / 4);
+            chroma_size = chroma_stride * (((height / 2) + 3) / 4);
+            break;
+        case VCENC_YUV420_10BIT_TILE_48_4:
+        case VCENC_YUV420_VU_10BIT_TILE_48_4:
+            luma_size = luma_stride * ((height + 3) / 4);
+            chroma_size = chroma_stride * (((height / 2) + 3) / 4);
+            break;
+        case VCENC_YUV420_8BIT_TILE_128_2:
+        case VCENC_YUV420_UV_8BIT_TILE_128_2:
+            luma_size = luma_stride * ((height + 1) / 2);
+            chroma_size = chroma_stride * (((height / 2) + 1) / 2);
+            break;
+        case VCENC_YUV420_10BIT_TILE_96_2:
+        case VCENC_YUV420_VU_10BIT_TILE_96_2:
+            luma_size = luma_stride * ((height + 1) / 2);
+            chroma_size = chroma_stride * (((height / 2) + 1) / 2);
+            break;
+#ifdef SUPPORT_TCACHE
+        case INPUT_FORMAT_YUV420_SEMIPLANAR_10BIT_P010BE:
+#endif
+            luma_stride = STRIDE(width * 2, alignment);
+            chroma_stride = STRIDE(width * 2, alignment);
+
+            luma_size = luma_stride * height;
+            chroma_size = chroma_stride * height / 2;
+            break;
+#ifdef SUPPORT_TCACHE
+        case INPUT_FORMAT_RFC_8BIT_COMPRESSED_FB:
+            luma_stride = STRIDE(width, DTRC_INPUT_WIDTH_ALIGNMENT);
+            luma_size = luma_stride * STRIDE(height, DTRC_INPUT_HEIGHT_ALIGNMENT);
+            // lumaSize = luma_stride * ((height+3)/4);
+            chroma_size = luma_size / 2;
+            break;
+        case INPUT_FORMAT_RFC_10BIT_COMPRESSED_FB:
+            luma_stride = STRIDE(width, DTRC_INPUT_WIDTH_ALIGNMENT);
+            luma_size = luma_stride * STRIDE(height, DTRC_INPUT_HEIGHT_ALIGNMENT) * 10 / 8;
+            chroma_size = luma_size / 2;
+            break;
+        case INPUT_FORMAT_YUV420_PLANAR_10BIT_P010LE:
+        case INPUT_FORMAT_YUV420_PLANAR_10BIT_P010BE:
+            luma_stride = STRIDE(width * 2, alignment);
+            chroma_stride = STRIDE((width / 2) * 2, alignment);
+            luma_size = luma_stride * height;
+            chroma_size = chroma_stride * (height / 2) * 2;
+            break;
+        case INPUT_FORMAT_ARGB_FB:
+        case INPUT_FORMAT_ABGR_FB:
+        case INPUT_FORMAT_RGBA_FB:
+        case INPUT_FORMAT_BGRA_FB:
+            luma_stride = STRIDE(width * 4, alignment);
+            luma_size = luma_stride * height;
+            chroma_size = 0;
+            break;
+        case INPUT_FORMAT_RGB24_FB:
+        case INPUT_FORMAT_BGR24_FB:
+            luma_stride = STRIDE(width * 3, alignment);
+            luma_size = luma_stride * height;
+            chroma_size = 0;
+            break;
+        case INPUT_FORMAT_YUV422P:
+            luma_stride = STRIDE(width, alignment);
+            chroma_stride = STRIDE(width / 2, alignment);
+            luma_size = luma_stride * height;
+            chroma_size = chroma_stride * height * 2;
+            break;
+        case INPUT_FORMAT_YUV422P10LE:
+        case INPUT_FORMAT_YUV422P10BE:
+            luma_stride = STRIDE(width * 2, alignment);
+            chroma_stride = STRIDE((width / 2) * 2, alignment);
+            luma_size = luma_stride * height;
+            chroma_size = chroma_stride * height * 2;
+            break;
+        case INPUT_FORMAT_YUV444P:
+            luma_stride = STRIDE(width * 2, alignment);
+            luma_size = luma_stride * height;
+            chroma_size = luma_size * 2;
+            break;
+#endif
+
+        default:
+            printf("not support this format\n");
+            chroma_size = luma_size = 0;
+            break;
+    }
+
+    picture_size = luma_size + chroma_size;
+    if (para_luma_size != NULL) *para_luma_size = luma_size;
+    if (para_chroma_size != NULL) *para_chroma_size = chroma_size;
+    if (para_picture_size != NULL) *para_picture_size = picture_size;
+}
+
+/*------------------------------------------------------------------------------
+Function name : vsv_init_pic_config
+Description   : initial pic reference configure
+Return type   : void
+Argument      : VCEncIn *enc_in
+------------------------------------------------------------------------------*/
+static void vsv_init_pic_config(VCEncIn *enc_in) {
+    int32_t i, j, k, i32_poc;
+    int32_t i32_maxpic_order_cnt_lsb = 1 << 16;
+
+    ASSERT(enc_in != NULL);
+
+    enc_in->gopCurrPicConfig.codingType = FRAME_TYPE_RESERVED;
+    enc_in->gopCurrPicConfig.numRefPics = NUMREFPICS_RESERVED;
+    enc_in->gopCurrPicConfig.poc = -1;
+    enc_in->gopCurrPicConfig.QpFactor = QPFACTOR_RESERVED;
+    enc_in->gopCurrPicConfig.QpOffset = QPOFFSET_RESERVED;
+    enc_in->gopCurrPicConfig.temporalId = TEMPORALID_RESERVED;
+    enc_in->i8SpecialRpsIdx = -1;
+    for (k = 0; k < VCENC_MAX_REF_FRAMES; k++) {
+        enc_in->gopCurrPicConfig.refPics[k].ref_pic = INVALITED_POC;
+        enc_in->gopCurrPicConfig.refPics[k].used_by_cur = 0;
+    }
+
+    for (k = 0; k < VCENC_MAX_LT_REF_FRAMES; k++) enc_in->long_term_ref_pic[k] = INVALITED_POC;
+
+    enc_in->bIsPeriodUsingLTR = 0;
+    enc_in->bIsPeriodUpdateLTR = 0;
+
+    for (i = 0; i < enc_in->gopConfig.special_size; i++) {
+        if (enc_in->gopConfig.pGopPicSpecialCfg[i].i32Interval <= 0) continue;
+
+        if (enc_in->gopConfig.pGopPicSpecialCfg[i].i32Ltr == 0)
+            enc_in->bIsPeriodUsingLTR = 1;
+        else {
+            enc_in->bIsPeriodUpdateLTR = 1;
+
+            for (k = 0; k < (int32_t)enc_in->gopConfig.pGopPicSpecialCfg[i].numRefPics; k++) {
+                int32_t i32LTRIdx = enc_in->gopConfig.pGopPicSpecialCfg[i].refPics[k].ref_pic;
+                if ((IS_LONG_TERM_REF_DELTAPOC(i32LTRIdx))
+                    && ((enc_in->gopConfig.pGopPicSpecialCfg[i].i32Ltr - 1) == LONG_TERM_REF_DELTAPOC2ID(i32LTRIdx))) {
+                    enc_in->bIsPeriodUsingLTR = 1;
+                }
+            }
+        }
+    }
+
+    memset(enc_in->bLTR_need_update, 0, sizeof(bool) * VCENC_MAX_LT_REF_FRAMES);
+    enc_in->bIsIDR = 1;  // for vs, it must be set one time for idr interval
+
+    i32_poc = 0;
+    /* check current picture encoded as LTR*/
+    enc_in->u8IdxEncodedAsLTR = 0;
+    for (j = 0; j < enc_in->gopConfig.special_size; j++) {
+        if (enc_in->bIsPeriodUsingLTR == 0) break;
+
+        if ((enc_in->gopConfig.pGopPicSpecialCfg[j].i32Interval <= 0)
+            || (enc_in->gopConfig.pGopPicSpecialCfg[j].i32Ltr == 0))
+            continue;
+
+        i32_poc = i32_poc - enc_in->gopConfig.pGopPicSpecialCfg[j].i32Offset;
+
+        if (i32_poc < 0) {
+            i32_poc += i32_maxpic_order_cnt_lsb;
+            if (i32_poc > (i32_maxpic_order_cnt_lsb >> 1)) i32_poc = -1;
+        }
+
+        if ((i32_poc >= 0) && (i32_poc % enc_in->gopConfig.pGopPicSpecialCfg[j].i32Interval == 0)) {
+            /* more than one LTR at the same frame position */
+            if (0 != enc_in->u8IdxEncodedAsLTR) {
+                // reuse the same POC LTR
+                enc_in->bLTR_need_update[enc_in->gopConfig.pGopPicSpecialCfg[j].i32Ltr - 1] = 1;
+                continue;
+            }
+
+            enc_in->gopCurrPicConfig.codingType =
+                ((int32_t)enc_in->gopConfig.pGopPicSpecialCfg[j].codingType == FRAME_TYPE_RESERVED)
+                    ? enc_in->gopCurrPicConfig.codingType
+                    : enc_in->gopConfig.pGopPicSpecialCfg[j].codingType;
+            enc_in->gopCurrPicConfig.numRefPics =
+                ((int32_t)enc_in->gopConfig.pGopPicSpecialCfg[j].numRefPics == NUMREFPICS_RESERVED)
+                    ? enc_in->gopCurrPicConfig.numRefPics
+                    : enc_in->gopConfig.pGopPicSpecialCfg[j].numRefPics;
+            enc_in->gopCurrPicConfig.QpFactor = (enc_in->gopConfig.pGopPicSpecialCfg[j].QpFactor == QPFACTOR_RESERVED)
+                                                    ? enc_in->gopCurrPicConfig.QpFactor
+                                                    : enc_in->gopConfig.pGopPicSpecialCfg[j].QpFactor;
+            enc_in->gopCurrPicConfig.QpOffset = (enc_in->gopConfig.pGopPicSpecialCfg[j].QpOffset == QPOFFSET_RESERVED)
+                                                    ? enc_in->gopCurrPicConfig.QpOffset
+                                                    : enc_in->gopConfig.pGopPicSpecialCfg[j].QpOffset;
+            enc_in->gopCurrPicConfig.temporalId =
+                (enc_in->gopConfig.pGopPicSpecialCfg[j].temporalId == TEMPORALID_RESERVED)
+                    ? enc_in->gopCurrPicConfig.temporalId
+                    : enc_in->gopConfig.pGopPicSpecialCfg[j].temporalId;
+
+            if (((int32_t)enc_in->gopConfig.pGopPicSpecialCfg[j].numRefPics != NUMREFPICS_RESERVED)) {
+                for (k = 0; k < (int32_t)enc_in->gopCurrPicConfig.numRefPics; k++) {
+                    enc_in->gopCurrPicConfig.refPics[k].ref_pic =
+                        enc_in->gopConfig.pGopPicSpecialCfg[j].refPics[k].ref_pic;
+                    enc_in->gopCurrPicConfig.refPics[k].used_by_cur =
+                        enc_in->gopConfig.pGopPicSpecialCfg[j].refPics[k].used_by_cur;
+                }
+            }
+
+            enc_in->u8IdxEncodedAsLTR = enc_in->gopConfig.pGopPicSpecialCfg[j].i32Ltr;
+            enc_in->bLTR_need_update[enc_in->u8IdxEncodedAsLTR - 1] = 1;
+        }
+    }
+}
+
+/* add for ssim statistic */
+static void vsv_encode_report(AVCodecContext *avctx) {
+#ifndef BUILD_CMODEL
+    // Transcoder_t * trans = (Transcoder_t *)trans_handle;
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+
+    if (ctx) {
+        struct statistic enc_statistic = {0};
+        int j = 0;
+        av_log(avctx,
+               AV_LOG_INFO,
+               ":::ENC[%d] : %d frames, SSIM %.4f, %d Cycles/MB, %d us/frame, %.2f fps, %u bps\n",
+               in_ctx->enc_index,
+               enc_statistic.frame_count,
+               enc_statistic.ssim_avg,
+               enc_statistic.cycle_mb_avg_total,
+               enc_statistic.hw_real_time_avg,
+               (enc_statistic.hw_real_time_avg == 0) ? 0.0 : 1000000.0 / ((double)enc_statistic.hw_real_time_avg),
+               enc_statistic.bitrate_avg);
+
+        if (enc_statistic.cycle_mb_avg_p1) {
+            av_log(avctx, AV_LOG_INFO, "\tPass 1 : %d Cycles/MB\n", enc_statistic.cycle_mb_avg_p1);
+            av_log(avctx, AV_LOG_INFO, "\tPass 2 : %d Cycles/MB\n", enc_statistic.cycle_mb_avg);
+        }
+
+        if (enc_statistic.hw_real_time_avg > enc_statistic.hw_real_time_avg_remove_overlap + 10) {
+            av_log(avctx,
+                   AV_LOG_INFO,
+                   "\tremove overlap : %d us/frame, %.2f fps\n",
+                   enc_statistic.hw_real_time_avg_remove_overlap,
+                   (enc_statistic.hw_real_time_avg_remove_overlap == 0)
+                       ? 0.0
+                       : 1000000.0 / ((double)enc_statistic.hw_real_time_avg_remove_overlap));
+        }
+
+        av_log(avctx, AV_LOG_INFO, ":::ENC[%d] Multi-core usage statistics:\n", in_ctx->enc_index);
+
+        if (enc_statistic.total_usage == 0) enc_statistic.total_usage = 1;
+
+        for (j = 0; j < 2; j++) {
+            if (enc_statistic.core_usage_counts[2] || enc_statistic.core_usage_counts[3])
+                av_log(avctx,
+                       AV_LOG_INFO,
+                       "\tPass 1 Slice[%d] used %6d times (%2d%%)\n",
+                       j,
+                       enc_statistic.core_usage_counts[2 + j],
+                       (enc_statistic.core_usage_counts[2 + j] * 100) / enc_statistic.total_usage);
+        }
+        for (j = 0; j < 2; j++) {
+            av_log(avctx,
+                   AV_LOG_INFO,
+                   "\tSlice[%d] used %6d times (%2d%%)\n",
+                   j,
+                   enc_statistic.core_usage_counts[j],
+                   (enc_statistic.core_usage_counts[j] * 100) / enc_statistic.total_usage);
+        }
+    }
+#endif
+}
+
+static int esenc_vid_alloc_output_buffer(ESEncVidInternalContext *in_ctx) {
+    if (!in_ctx) return -1;
+
+    int ret = 0;
+    int picture_size = in_ctx->picture_size;
+    int size = picture_size / in_ctx->compress_rate;
+    av_log(NULL,
+           AV_LOG_INFO,
+           "venc alloc outbuf size[%d] is 1/%d of YUV[%d] \n",
+           size,
+           in_ctx->compress_rate,
+           in_ctx->picture_size);
+
+    // adjust buffer size, vs required >= VCENC_STREAM_MIN_BUF0_SIZE
+    if (size < VCENC_STREAM_MIN_BUF0_SIZE) {
+        in_ctx->compress_rate = picture_size / (VCENC_STREAM_MIN_BUF0_SIZE);
+        if (picture_size % (VCENC_STREAM_MIN_BUF0_SIZE)) {
+            in_ctx->compress_rate--;
+            if (in_ctx->compress_rate < 2) in_ctx->compress_rate = 1;
+        }
+
+        size = picture_size / in_ctx->compress_rate;
+        av_log(NULL, AV_LOG_INFO, "venc realloc outbuf size: %d is 1/%d of YUV \n", size, in_ctx->compress_rate);
+    }
+
+    for (int core_idx = 0; core_idx < in_ctx->parallel_core_num; core_idx++) {
+        for (int i_buf = 0; i_buf < in_ctx->stream_buf_num; i_buf++) {
+            in_ctx->outbuf_mem_factory[core_idx][i_buf].mem_type = VPU_WR | CPU_WR | CPU_RD | EWL_MEM_TYPE_SLICE;
+            ret = EWLMallocLinear(
+                in_ctx->ewl, size, in_ctx->input_alignment, &in_ctx->outbuf_mem_factory[core_idx][i_buf]);
+            if (ret != EWL_OK) {
+                in_ctx->outbuf_mem_factory[core_idx][i_buf].virtualAddress = NULL;
+                av_log(NULL, AV_LOG_ERROR, "venc alloc outbuf size: %d fail\n", size);
+                return -1;
+            }
+
+            av_log(NULL, AV_LOG_INFO, "venc EWL outbuf size: %d\n", in_ctx->outbuf_mem_factory[core_idx][i_buf].size);
+        }
+    }
+
+    return 0;
+}
+
+static int esenc_vid_free_output_buffer(ESEncVidInternalContext *in_ctx) {
+    if (!in_ctx) return -1;
+
+    // release current buffer
+    for (int core_idx = 0; core_idx < in_ctx->parallel_core_num; core_idx++) {
+        for (int i_buf = 0; i_buf < in_ctx->stream_buf_num; i_buf++) {
+            if (in_ctx->outbuf_mem_factory[core_idx][i_buf].virtualAddress != NULL) {
+                EWLFreeLinear(in_ctx->ewl, &in_ctx->outbuf_mem_factory[core_idx][i_buf]);
+                in_ctx->outbuf_mem_factory[core_idx][i_buf].virtualAddress = NULL;
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int esenc_vid_realloc_output_buffer(ESEncVidInternalContext *in_ctx) {
+    if (!in_ctx) return -1;
+
+    if (esenc_vid_free_output_buffer(in_ctx)) {
+        av_log(NULL, AV_LOG_ERROR, "venc free out buf fail\n");
+        return -1;
+    }
+
+    // choose decompress rate
+    in_ctx->compress_rate--;
+    if (in_ctx->compress_rate < 2) in_ctx->compress_rate = 1;
+
+    if (esenc_vid_alloc_output_buffer(in_ctx)) {
+        av_log(NULL, AV_LOG_ERROR, "venc alloc out buf fail\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+static int esenc_vid_alloc_input_picture_buffers(ESEncVidInternalContext *in_ctx) {
+    int ret = 0;
+    if (!in_ctx) return -1;
+
+    for (int core_idx = 0; core_idx < in_ctx->buffer_cnt; core_idx++) {
+        in_ctx->picture_mem_factory[core_idx].mem_type = EXT_WR | VPU_RD | EWL_MEM_TYPE_DPB;
+        ret = EWLMallocLinear(
+            in_ctx->ewl, in_ctx->picture_size, in_ctx->input_alignment, &in_ctx->picture_mem_factory[core_idx]);
+        if (ret != EWL_OK) {
+            av_log(NULL, AV_LOG_ERROR, "EWLMallocLinear picture_mem_factory fail\n");
+            in_ctx->picture_mem_factory[core_idx].virtualAddress = NULL;
+            return -1;
+        }
+
+        // update picture_mem_status
+        in_ctx->picture_mem_status[core_idx] = 0;
+    }
+
+    return 0;
+}
+
+static int esenc_vid_free_input_picture_buffer(ESEncVidInternalContext *in_ctx) {
+    if (!in_ctx) return -1;
+
+    for (int core_idx = 0; core_idx < in_ctx->buffer_cnt; core_idx++) {
+        if (in_ctx->picture_mem_factory[core_idx].virtualAddress != NULL) {
+            EWLFreeLinear(in_ctx->ewl, &in_ctx->picture_mem_factory[core_idx]);
+        }
+    }
+
+    return 0;
+}
+
+static int esenc_vid_alloc_input_roi_qp_map_buffers(ESEncVidContext *enc_ctx,
+                                                    VCEncInst enc,
+                                                    ESEncVidInternalContext *in_ctx) {
+    uint32_t block_size;
+    int32_t total_size;
+    uint32_t roi_map_delta_qp_mem_size = 0;
+    uint32_t core_idx = 0;
+    int ret = 0;
+
+    if (!in_ctx || !enc || !enc_ctx) return -1;
+
+    // allocate delta qp map memory.
+    // 4 bits per block.
+    block_size = ((enc_ctx->width + enc_ctx->max_cu_size - 1) & (~(enc_ctx->max_cu_size - 1)))
+                 * ((enc_ctx->height + enc_ctx->max_cu_size - 1) & (~(enc_ctx->max_cu_size - 1))) / (8 * 8 * 2);
+    // 8 bits per block if ipcm map/absolute roi qp is supported
+    if (((struct vcenc_instance *)enc)->asic.regs.asicCfg.roiMapVersion >= 1) block_size *= 2;
+    block_size = ((block_size + 63) & (~63));
+
+    in_ctx->roi_map_delta_qp_mem_factory[0].mem_type = EXT_WR | VPU_RD | EWL_MEM_TYPE_VPU_WORKING;
+    roi_map_delta_qp_mem_size = block_size * in_ctx->buffer_cnt + ROIMAP_PREFETCH_EXT_SIZE;
+
+    if (EWLMallocLinear(in_ctx->ewl, roi_map_delta_qp_mem_size, 0, &in_ctx->roi_map_delta_qp_mem_factory[0])
+        != EWL_OK) {
+        in_ctx->roi_map_delta_qp_mem_factory[0].virtualAddress = NULL;
+        return -1;
+    }
+
+    total_size = in_ctx->roi_map_delta_qp_mem_factory[0].size;
+    for (core_idx = 0; core_idx < in_ctx->buffer_cnt; core_idx++) {
+        in_ctx->roi_map_delta_qp_mem_factory[core_idx].virtualAddress =
+            (uint32_t *)((ptr_t)in_ctx->roi_map_delta_qp_mem_factory[0].virtualAddress + core_idx * block_size);
+        in_ctx->roi_map_delta_qp_mem_factory[core_idx].busAddress =
+            in_ctx->roi_map_delta_qp_mem_factory[0].busAddress + core_idx * block_size;
+        in_ctx->roi_map_delta_qp_mem_factory[core_idx].size =
+            (core_idx < in_ctx->buffer_cnt - 1 ? block_size : total_size - (in_ctx->buffer_cnt - 1) * block_size);
+        memset(in_ctx->roi_map_delta_qp_mem_factory[core_idx].virtualAddress, 0, block_size);
+    }
+
+    for (int core_idx = 0; core_idx < in_ctx->buffer_cnt; core_idx++) {
+        in_ctx->picture_mem_factory[core_idx].mem_type = EXT_WR | VPU_RD | EWL_MEM_TYPE_DPB;
+        ret = EWLMallocLinear(
+            in_ctx->ewl, in_ctx->picture_size, in_ctx->input_alignment, &in_ctx->picture_mem_factory[core_idx]);
+        if (ret != EWL_OK) {
+            av_log(NULL, AV_LOG_ERROR, "EWLMallocLinear picture_mem_factory fail\n");
+            in_ctx->picture_mem_factory[core_idx].virtualAddress = NULL;
+            return -1;
+        }
+
+        // update picture_mem_status
+        in_ctx->picture_mem_status[core_idx] = 0;
+    }
+
+    return 0;
+}
+
+static int esenc_vid_free_input_roi_qp_map_buffer(ESEncVidInternalContext *in_ctx) {
+    if (!in_ctx) return -1;
+
+    if (in_ctx->roi_map_delta_qp_mem_factory[0].virtualAddress != NULL) {
+        EWLFreeLinear(in_ctx->ewl, &in_ctx->roi_map_delta_qp_mem_factory[0]);
+    }
+
+    return 0;
+}
+/*------------------------------------------------------------------------------
+
+    vsv_encode_alloc_res
+
+    Allocation of the physical memories used by both SW and HW:
+    the input pictures and the output stream buffer.
+
+    NOTE! The implementation uses the EWL instance from the encoder
+          for OS independence. This is not recommended in final environment
+          because the encoder will release the EWL instance in case of error.
+          Instead, the memories should be allocated from the OS the same way
+          as inside EWLMallocLinear().
+
+------------------------------------------------------------------------------*/
+static int vsv_encode_alloc_res(ESEncVidContext *enc_ctx, VCEncInst enc, ESEncVidInternalContext *in_ctx) {
+    uint32_t picture_size = 0;
+    uint32_t luma_size = 0, chroma_size = 0;
+    uint32_t alignment = 0;
+
+    alignment = in_ctx->input_alignment;
+    getAlignedPicSizebyFormat(enc_ctx->input_format,
+                              enc_ctx->lum_width_src,
+                              enc_ctx->lum_height_src,
+                              alignment,
+                              &luma_size,
+                              &chroma_size,
+                              &picture_size);
+    in_ctx->picture_size = picture_size;
+
+    av_log(enc_ctx, AV_LOG_INFO, "alloc res, picture_size: %d\n", picture_size);
+
+    if (esenc_vid_alloc_output_buffer(in_ctx)) {
+        return -1;
+    }
+
+    if (esenc_vid_alloc_input_roi_qp_map_buffers(enc_ctx, enc, in_ctx)) {
+        return -1;
+    }
+
+    return 0;
+}
+
+/*------------------------------------------------------------------------------
+
+    vsv_encode_free_res
+
+    Release all resources allcoated byt vsv_encode_alloc_res()
+
+------------------------------------------------------------------------------*/
+static void vsv_encode_free_res(ESEncVidInternalContext *in_ctx) {
+    esenc_vid_free_input_roi_qp_map_buffer(in_ctx);
+
+    if (in_ctx->picture_buffer_allocated) {
+        av_log(NULL, AV_LOG_INFO, "not hwaccel mode, free input picture buffers\n");
+        esenc_vid_free_input_picture_buffer(in_ctx);
+        in_ctx->picture_buffer_allocated = 0;
+    }
+    esenc_vid_free_output_buffer(in_ctx);
+}
+
+/*------------------------------------------------------------------------------
+
+    vsv_init_input_line_buffer
+    -get line buffer params for IRQ handle
+    -get address of input line buffer
+------------------------------------------------------------------------------*/
+static int32_t vsv_init_input_line_buffer(inputLineBufferCfg *line_buf_cfg,
+                                          ESEncVidContext *options,
+                                          VCEncIn *enc_in,
+                                          VCEncInst inst,
+                                          ESEncVidInternalContext *in_ctx) {
+    VCEncCodingCtrl coding_cfg;
+    uint32_t stride, chroma_stride, client_type;
+    VCEncGetAlignedStride(
+        options->lum_width_src, options->input_format, &stride, &chroma_stride, in_ctx->input_alignment);
+    VCEncGetCodingCtrl(inst, &coding_cfg);
+    client_type = IS_H264(options->codec_format) ? EWL_CLIENT_TYPE_H264_ENC : EWL_CLIENT_TYPE_HEVC_ENC;
+
+    memset(line_buf_cfg, 0, sizeof(inputLineBufferCfg));
+    line_buf_cfg->depth = coding_cfg.inputLineBufDepth;
+    line_buf_cfg->hwHandShake = coding_cfg.inputLineBufHwModeEn;
+    line_buf_cfg->loopBackEn = coding_cfg.inputLineBufLoopBackEn;
+    line_buf_cfg->amountPerLoopBack = coding_cfg.amountPerLoopBack;
+    line_buf_cfg->initSegNum = 0;
+    line_buf_cfg->inst = (void *)inst;
+    line_buf_cfg->wrCnt = 0;
+    line_buf_cfg->inputFormat = options->input_format;
+    line_buf_cfg->lumaStride = stride;
+    line_buf_cfg->chromaStride = chroma_stride;
+    line_buf_cfg->encWidth = options->width;
+    line_buf_cfg->encHeight = options->height;
+    line_buf_cfg->srcHeight = options->lum_height_src;
+    line_buf_cfg->srcVerOffset = options->ver_offset_src;
+    line_buf_cfg->getMbLines = &VCEncGetEncodedMbLines;
+    line_buf_cfg->setMbLines = &VCEncSetInputMBLines;
+    line_buf_cfg->ctbSize = IS_H264(options->codec_format) ? 16 : 64;
+    line_buf_cfg->lumSrc = in_ctx->lum;
+    line_buf_cfg->cbSrc = in_ctx->cb;
+    line_buf_cfg->crSrc = in_ctx->cr;
+    line_buf_cfg->client_type = client_type;
+
+    if (VCEncInitInputLineBuffer(line_buf_cfg)) {
+        av_log(NULL, AV_LOG_ERROR, "VCEncInitInputLineBuffer fail\n");
+        return -1;
+    }
+
+    /* loopback mode */
+    if (line_buf_cfg->loopBackEn && line_buf_cfg->lumBuf.buf) {
+        VCEncPreProcessingCfg preProcCfg;
+        enc_in->busLuma = line_buf_cfg->lumBuf.busAddress;
+        enc_in->busChromaU = line_buf_cfg->cbBuf.busAddress;
+        enc_in->busChromaV = line_buf_cfg->crBuf.busAddress;
+
+        /* In loop back mode, data in line buffer start from the line to be encoded*/
+        VCEncGetPreProcessing(inst, &preProcCfg);
+        preProcCfg.yOffset = 0;
+        VCEncSetPreProcessing(inst, &preProcCfg);
+    }
+
+    return 0;
+}
+
+/**
+ *  Callback function called by the encoder SW after "segment ready"
+ *  interrupt from HW. Note that this function is called after every segment is ready.
+ */
+static void EncStreamSegmentReady(void *cb_data) {
+    // uint8_t *stream_base;
+    SegmentCtl *ctl = (SegmentCtl *)cb_data;
+
+    if (ctl->stream_multi_seg_en) {
+        // stream_base = ctl->stream_base + (ctl->streamRDCounter % ctl->segment_amount) * ctl->segment_size;
+
+        if (ctl->output_byte_stream == 0 && ctl->start_code_done == 0) {
+            const uint8_t start_code_prefix[4] = {0x0, 0x0, 0x0, 0x1};
+            fwrite(start_code_prefix, 1, 4, ctl->out_stream_file);
+            ctl->start_code_done = 1;
+        }
+        printf("<----receive segment irq %d\n", ctl->stream_rd_counter);
+        //    WriteStrm(ctl->outStreamFile, (uint32_t *)stream_base, ctl->segment_size, 0); TODO
+
+        ctl->stream_rd_counter++;
+    }
+}
+
+static int vsv_process_frame(AVCodecContext *avctx, AVPacket *avpkt, int *stream_size) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidContext *options = ctx;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+    VCEncIn *enc_in = (VCEncIn *)&(in_ctx->enc_in);
+    VCEncOut *enc_out = (VCEncOut *)&ctx->encOut;
+    uint8_t *ptr;
+    int pkt_size = 0;
+
+    if (options->lookahead_depth && enc_out->codingType == VCENC_INTRA_FRAME) ctx->frame_cnt_output = 0;
+
+    VCEncGetRateCtrl(ctx->encoder, (VCEncRateCtrl *)&ctx->rc);
+
+    if (enc_out->streamSize != 0) {
+        // multi-core: output bitstream has (in_ctx->parallel_core_num-1) delay
+        int32_t core_idx = (in_ctx->picture_enc_cnt - 1 - (in_ctx->frame_delay - 1)) % in_ctx->parallel_core_num;
+        int32_t i_buf;
+        double ssim;
+        EWLLinearMem_t mem;
+        for (i_buf = 0; i_buf < in_ctx->stream_buf_num; i_buf++)
+            in_ctx->outbuf_mem[i_buf] = &(in_ctx->outbuf_mem_factory[core_idx][i_buf]);
+
+        mem = *in_ctx->outbuf_mem[0];
+        pkt_size = enc_out->streamSize;
+        if (ctx->encoder_is_start == 1) {
+            pkt_size += avctx->extradata_size;
+        }
+
+        if (av_new_packet(avpkt, pkt_size)) return -1;
+
+        ptr = avpkt->data;
+        if (ctx->encoder_is_start == 1) {
+            memcpy(ptr, avctx->extradata, avctx->extradata_size);
+            ptr += avctx->extradata_size;
+            ctx->encoder_is_start = 0;
+        }
+        memcpy(ptr, (uint8_t *)mem.virtualAddress, enc_out->streamSize);
+        // fill avpacket info
+        if (enc_out->codingType == VCENC_INTRA_FRAME) {
+            avpkt->flags = AV_PKT_FLAG_KEY;
+        }
+
+#if 0
+        avpkt->pts = av_rescale_q_rnd(
+            avpkt->pts, avctx->time_base, (AVRational){1, 90000}, (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));
+        avpkt->dts = av_rescale_q_rnd(
+            avpkt->dts, avctx->time_base, (AVRational){1, 90000}, (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));
+        avpkt->duration = av_rescale_q(avpkt->duration, avctx->time_base, (AVRational){1, 90000});
+#endif
+
+        av_log(NULL, AV_LOG_DEBUG, "avpkt timebase, pts: %" PRId64 ", dts: %" PRId64 "\n", avpkt->pts, avpkt->dts);
+
+        *stream_size = pkt_size;
+        enc_in->timeIncrement = in_ctx->output_rate_denom;
+
+        // dump packet
+        if (ctx->dump_pkt_enable) {
+            int ret = 0;
+            ret = ff_codec_dump_bytes_to_file(avpkt->data, pkt_size, ctx->dump_pkt_hnd);
+            if (ret == ERR_TIMEOUT) {
+                av_log(NULL, AV_LOG_INFO, "pkt dump timeout\n");
+                ff_codec_dump_file_close(&ctx->dump_pkt_hnd);
+                ctx->dump_pkt_enable = 0;
+                av_log(NULL, AV_LOG_INFO, "closed dump packet handle\n");
+            } else if (ret < 0) {
+                av_log(NULL, AV_LOG_ERROR, "write packet into file failed\n");
+            }
+        }
+
+#if 0
+        ctx->total_bits += enc_out->streamSize * 8;
+        in_ctx->valid_encoded_frame_number++;
+        ff_ma_add_frame(&ctx->ma, enc_out->streamSize * 8);
+        in_ctx->hwcycle_acc += VCEncGetPerformance(ctx->encoder);
+        av_log(
+            NULL,
+            AV_LOG_INFO,
+            "=== Encoded frame%i bits=%d TotalBits=%lu averagebitrate=%lu HWCycles=%d maxSliceBytes=%d codingType=%d\n",
+            in_ctx->picture_encoded_cnt,
+            enc_out->streamSize * 8,
+            ctx->total_bits,
+            (ctx->total_bits * in_ctx->output_rate_numer)
+                / ((in_ctx->picture_encoded_cnt + 1) * in_ctx->output_rate_denom),
+            VCEncGetPerformance(ctx->encoder),
+            enc_out->maxSliceStreamSize,
+            enc_out->codingType);
+
+        ssim = enc_out->ssim[0] * 0.8 + 0.1 * (enc_out->ssim[1] + enc_out->ssim[2]);
+        av_log(NULL,
+               AV_LOG_INFO,
+               "    SSIM %.4f SSIM Y %.4f U %.4f V %.4f\n",
+               ssim,
+               enc_out->ssim[0],
+               enc_out->ssim[1],
+               enc_out->ssim[2]);
+        in_ctx->ssim_acc += ssim;
+
+        if ((options->pic_rc == 1) && (in_ctx->valid_encoded_frame_number >= ctx->ma.length)) {
+            in_ctx->number_square_of_error++;
+            if (in_ctx->max_error_over_target < (ff_ma(&ctx->ma) - options->bit_per_second))
+                in_ctx->max_error_over_target = (ff_ma(&ctx->ma) - options->bit_per_second);
+            if (in_ctx->max_error_under_target < (options->bit_per_second - ff_ma(&ctx->ma)))
+                in_ctx->max_error_under_target = (options->bit_per_second - ff_ma(&ctx->ma));
+            in_ctx->sum_square_of_error +=
+                ((float)(ABS(ff_ma(&ctx->ma) - options->bit_per_second)) * 100 / options->bit_per_second);
+            in_ctx->average_square_of_error = (in_ctx->sum_square_of_error / in_ctx->number_square_of_error);
+            av_log(
+                NULL,
+                AV_LOG_INFO,
+                "    RateControl(movingBitrate=%d MaxOvertarget=%d%% MaxUndertarget=%d%% AveDeviationPerframe=%f%%)\n",
+                ff_ma(&ctx->ma),
+                in_ctx->max_error_over_target * 100 / options->bit_per_second,
+                in_ctx->max_error_under_target * 100 / options->bit_per_second,
+                in_ctx->average_square_of_error);
+        }
+#endif
+    }
+
+    return 0;
+}
+
+static inline void timestamp_queue_enqueue(AVFifoBuffer *queue, int64_t timestamp) {
+    av_fifo_generic_write(queue, &timestamp, sizeof(timestamp), NULL);
+}
+
+static inline int64_t timestamp_queue_dequeue(AVFifoBuffer *queue) {
+    int64_t timestamp = AV_NOPTS_VALUE;
+    if (av_fifo_size(queue) > 0) av_fifo_generic_read(queue, &timestamp, sizeof(timestamp), NULL);
+
+    return timestamp;
+}
+
+static int esenc_vid_fill_picture_buffer(AVCodecContext *avctx,
+                                         AVFrame *pict,
+                                         int8_t share_fd_buf,
+                                         unsigned long share_vpa) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    EWLLinearMem_t *yuv_frame_mem = ctx->in_ctx.picture_mem;
+    uint32_t alignment = 0, lumaSize = 0, chromaSize = 0, pictureSize = 0;
+    int ret = 0;
+    int i = 0;
+    u32 luma_stride = 0;
+    u32 chroma_stride = 0;
+    uint8_t *data[3];
+    int linesize[3];
+    VCEncIn *enc_in = (VCEncIn *)&(ctx->in_ctx.enc_in);
+
+    if (!pict || !enc_in) return -1;
+
+    alignment = ctx->in_ctx.input_alignment;
+    VCEncGetAlignedStride(ctx->lum_width_src, ctx->input_format, &luma_stride, &chroma_stride, alignment);
+
+    getAlignedPicSizebyFormat(
+        ctx->input_format, ctx->lum_width_src, ctx->lum_height_src, alignment, &lumaSize, &chromaSize, &pictureSize);
+
+    av_log(NULL,
+           AV_LOG_DEBUG,
+           "w: %d, h: %d, format: %d, linesize: %d, %d, %d, data: %p, %p, %p\n",
+           pict->width,
+           pict->height,
+           pict->format,
+           pict->linesize[0],
+           pict->linesize[1],
+           pict->linesize[2],
+           pict->data[0],
+           pict->data[1],
+           pict->data[2]);
+
+    av_log(NULL,
+           AV_LOG_DEBUG,
+           "luma_stride: %d, chroma_stride: %d, pictureSize: %d, lumaSize: %d, chromaSize: %d\n",
+           luma_stride,
+           chroma_stride,
+           pictureSize,
+           lumaSize,
+           chromaSize);
+
+    // 1. zero frame buffer
+    if (!share_fd_buf) memset(yuv_frame_mem->virtualAddress, 0, pictureSize);
+
+    // 2. fill data as components
+    switch (ctx->input_format) {
+        case VCENC_YUV420_PLANAR:
+        case VCENC_YUV420_PLANAR_10BIT_I010:
+            if (!share_fd_buf) {
+                data[0] = yuv_frame_mem->virtualAddress;
+                data[1] = data[0] + lumaSize;
+                data[2] = data[1] + chromaSize / 2;
+                linesize[0] = luma_stride;
+                linesize[1] = chroma_stride;
+                linesize[2] = chroma_stride;
+            }
+            enc_in->busLuma = share_fd_buf ? share_vpa : yuv_frame_mem->busAddress;
+            enc_in->busChromaU = enc_in->busLuma + lumaSize;
+            enc_in->busChromaV = enc_in->busChromaU + chromaSize / 2;
+            break;
+        case VCENC_YUV420_SEMIPLANAR:
+        case VCENC_YUV420_SEMIPLANAR_VU:
+        case VCENC_YUV420_PLANAR_10BIT_P010:
+            if (!share_fd_buf) {
+                data[0] = yuv_frame_mem->virtualAddress;
+                data[1] = data[0] + lumaSize;
+                data[2] = NULL;
+                linesize[0] = luma_stride;
+                linesize[1] = chroma_stride;
+                linesize[2] = 0;
+            }
+            enc_in->busLuma = share_fd_buf ? share_vpa : yuv_frame_mem->busAddress;
+            enc_in->busChromaU = enc_in->busLuma + lumaSize;
+            enc_in->busChromaV = 0;
+            break;
+
+        case VCENC_YUV422_INTERLEAVED_UYVY:
+        case VCENC_YUV422_INTERLEAVED_YUYV:
+            if (!share_fd_buf) {
+                data[0] = yuv_frame_mem->virtualAddress;
+                data[1] = NULL;
+                data[2] = NULL;
+                linesize[0] = luma_stride;
+                linesize[1] = 0;
+                linesize[2] = 0;
+            }
+            enc_in->busLuma = share_fd_buf ? share_vpa : yuv_frame_mem->busAddress;
+            enc_in->busChromaU = 0;
+            enc_in->busChromaV = 0;
+            break;
+        default:
+            av_log(NULL, AV_LOG_ERROR, "not support format: %d\n", ctx->input_format);
+            return -1;
+    }
+
+    if (share_fd_buf) {
+        // av_log(NULL, AV_LOG_WARNING, "share fd, enc_in->busLuma: 0x%lx, share_vpa: 0x%lx\n", enc_in->busLuma,
+        // share_vpa);
+        //  check stride
+        if (luma_stride != pict->linesize[0]) {
+            av_log(NULL,
+                   AV_LOG_ERROR,
+                   "for share buffer, venc alignment[%d] !=  linesize[%d] failed\n",
+                   luma_stride,
+                   pict->linesize[0]);
+            return -1;
+        }
+        return 0;
+    } else {
+        int height = 0;
+        for (i = 0; i < FF_ARRAY_ELEMS(data) && data[i]; i++) {
+            height = !i ? pict->height : pict->height >> 1;
+            if (linesize[i] == pict->linesize[i]) {
+                ff_es_codec_memcpy_block(pict->data[i], data[i], pict->linesize[i] * height);
+            } else {
+                ff_es_codec_memcpy_by_line(pict->data[i], data[i], pict->linesize[i], linesize[i], height);
+            }
+        }
+
+        if (EWLSyncMemData(yuv_frame_mem, 0, pictureSize, HOST_TO_DEVICE) != EWL_OK) {
+            av_log(NULL, AV_LOG_ERROR, "Sync pictureMem Data fail!\n");
+        }
+    }
+
+    // dump yuv
+    if (ctx->dump_frame_enable) {
+        int ret = 0;
+        if (ctx->dump_frame_hnd) {
+            ret = ff_codec_dump_bytes_to_file((void *)yuv_frame_mem->virtualAddress, pictureSize, ctx->dump_frame_hnd);
+            if (ret == ERR_TIMEOUT) {
+                av_log(NULL, AV_LOG_INFO, "frame dump timeout\n");
+                ff_codec_dump_file_close(&ctx->dump_frame_hnd);
+                ctx->dump_frame_enable = 0;
+            } else if (ret < 0) {
+                av_log(NULL, AV_LOG_ERROR, "write file error\n");
+            }
+        } else {
+            av_log(NULL, AV_LOG_ERROR, "fp is not inited\n");
+        }
+    }
+
+    return ret;
+}
+
+/*    Callback function called by the encoder SW after "slice ready"
+    interrupt from HW. Note that this function is not necessarily called
+    after every slice i.e. it is possible that two or more slices are
+    completed between callbacks.
+------------------------------------------------------------------------------*/
+static void vsv_slice_ready(VCEncSliceReady *slice) {
+    uint32_t i;
+    uint32_t stream_size;
+    uint32_t pos;
+    SliceCtl *ctl = (SliceCtl *)slice->pAppData;
+    AVPacket *out_pkt;
+    /* Here is possible to implement low-latency streaming by
+     * sending the complete slices before the whole frame is completed. */
+    if (ctl->multislice_encoding && (ENCH2_SLICE_READY_INTERRUPT)) {
+        pos = slice->slicesReadyPrev ? ctl->stream_pos : /* Here we store the slice pointer */
+                  0;                                     /* Pointer to beginning of frame */
+        stream_size = 0;
+        for (i = slice->nalUnitInfoNumPrev; i < slice->nalUnitInfoNum; i++) {
+            stream_size += *(slice->sliceSizes + i);
+        }
+
+        out_pkt = av_packet_alloc();
+        if (out_pkt == NULL) return;
+        av_init_packet(out_pkt);
+
+        if (av_packet_from_data(out_pkt, (uint8_t *)&slice->streamBufs, stream_size)) return;
+
+        pos += stream_size;
+        /* Store the slice pointer for next callback */
+        ctl->stream_pos = pos;
+    }
+}
+
+static int vsv_encode_send_fd_by_avpacket(AVPacket *pkt, int64_t mem_fd) {
+    if (!pkt) {
+        av_log(NULL, AV_LOG_ERROR, "vsv_encode_send_fd_by_avpacket, invalid pointers\n");
+        return -1;
+    }
+
+    // dma fd
+    uint8_t *buf = av_packet_new_side_data(pkt, SIDE_DATA_TYPE_MEM_FRAME_FD_RELEASE, sizeof(mem_fd));
+    int64_t *fd = (int64_t *)buf;
+    *fd = mem_fd;
+
+    av_log(NULL, AV_LOG_INFO, "encoded one frame, release pkt with dma fd[%lx]\n", mem_fd);
+
+    return 0;
+}
+
+static int vsv_encode_release_input_buffer(ESEncVidContext *enc_ctx, VCEncOut *enc_out, AVPacket *avpkt) {
+    if (!enc_ctx || !enc_out || !avpkt) return -1;
+
+    ESEncVidInternalContext *in_ctx = &enc_ctx->in_ctx;
+    unsigned long vir_addr = enc_out->consumedAddr.inputbufBusAddr;
+    MemInfo *mem_info = ff_get_mem_info_by_vpa(in_ctx, vir_addr);
+
+    if (in_ctx->share_fd_buf && mem_info) {
+        // compare vpa to find the fd
+        // av_log(NULL, AV_LOG_WARNING, "release share fd, enc_out->consumedAddr.inputbufBusAddr: 0x%lx\n",
+        // enc_out->consumedAddr.inputbufBusAddr);
+
+        // unref dma buf
+#ifdef SUPPORT_DMA_HEAP
+        EWLPutIovaByFd(in_ctx->ewl, mem_info->dma_fd);
+#endif
+        // fill fd to avpacket side data
+        vsv_encode_send_fd_by_avpacket(avpkt, mem_info->dma_fd);
+    } else {
+        ff_release_input_picture_buffer(in_ctx, vir_addr);
+    }
+
+    ff_release_input_roi_qp_map_buffer(in_ctx, enc_out->consumedAddr.roiMapDeltaQpBusAddr);
+
+    if (mem_info) {
+        // update avpkt pts & dts
+        avpkt->pts = mem_info->frame->pts;
+        avpkt->dts = ff_get_and_del_min_dts_from_queue(in_ctx);
+        // remove from queue
+        ff_remove_mem_info_from_queue(in_ctx, mem_info);
+    }
+
+    return 0;
+}
+
+static int vsv_encode_flush(AVCodecContext *avctx, AVPacket *avpkt, int *stream_size) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    int32_t ret = OK;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+    VCEncIn *enc_in = (VCEncIn *)&(in_ctx->enc_in);
+    VCEncOut *enc_out = (VCEncOut *)&ctx->encOut;
+    /* IO buffer */
+    ff_setup_slice_ctl(in_ctx);
+    ff_get_output_buffer(in_ctx, enc_in);
+    ret = VCEncFlush(ctx->encoder, enc_in, enc_out, &vsv_slice_ready, in_ctx->slice_ctl);
+    switch (ret) {
+        case VCENC_FRAME_READY:
+            if (enc_out->streamSize == 0) {
+                if (enc_out->codingType != VCENC_NOTCODED_FRAME) {
+                    in_ctx->picture_encoded_cnt++;
+                }
+                break;
+            }
+            vsv_process_frame(avctx, avpkt, stream_size);
+            break;
+        default:
+            break;
+    }
+
+    vsv_encode_release_input_buffer(ctx, enc_out, avpkt);
+
+    av_log(avctx,
+           AV_LOG_INFO,
+           "flush done, nal_type = %d, size = %d, ret =  %d, pts = %ld, dts = %ld\n",
+           enc_out->codingType,
+           enc_out->streamSize,
+           ret,
+           avpkt->pts,
+           avpkt->dts);
+
+    return ret;
+}
+
+static int vsv_encode_end(AVCodecContext *avctx, AVPacket *avpkt, int *stream_size, int bneed_end) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    int32_t ret = OK;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+    VCEncIn *enc_in = (VCEncIn *)&(in_ctx->enc_in);
+    VCEncOut *enc_out = (VCEncOut *)&ctx->encOut;
+
+    if (ctx->encoder_is_end) return 0;
+
+    ff_get_output_buffer(in_ctx, enc_in);
+
+    ret = VCEncStrmEnd(ctx->encoder, enc_in, enc_out);
+    av_log(NULL, AV_LOG_DEBUG, "VCEncStrmEnd, streamSize = %d, ret = %d\n", enc_out->streamSize, ret);
+    if (bneed_end == 1 && ret == VCENC_OK) {
+        int32_t core_idx = (in_ctx->picture_enc_cnt - 1 - (in_ctx->frame_delay - 1)) % in_ctx->parallel_core_num;
+        int32_t i_buf;
+        EWLLinearMem_t mem;
+        for (i_buf = 0; i_buf < in_ctx->stream_buf_num; i_buf++)
+            in_ctx->outbuf_mem[i_buf] = &(in_ctx->outbuf_mem_factory[core_idx][i_buf]);
+
+        mem = *in_ctx->outbuf_mem[0];
+
+        // av_log(NULL, AV_LOG_DEBUG, "%s %d encOut->streamSize = %d\n", __FILE__, __LINE__, encOut->streamSize);
+
+        if (av_new_packet(avpkt, enc_out->streamSize)) return -1;
+
+        memcpy(avpkt->data, (uint8_t *)mem.virtualAddress, enc_out->streamSize);
+
+        *stream_size = enc_out->streamSize;
+
+        vsv_encode_release_input_buffer(ctx, enc_out, avpkt);
+    }
+
+    return 0;
+}
+
+static int vsv_encode_config_roi_areas(ESEncVidContext *options, VCEncCodingCtrl *coding_cfg) {
+    if (!options || !coding_cfg) {
+        av_log(NULL, AV_LOG_ERROR, "vsv_encode_config_roi_areas, invalid pointer\n");
+        return -1;
+    }
+
+    venc_print_roi(&options->roi_tbl);
+
+    for (int index = 0; index < options->roi_tbl.num_of_roi; index++) {
+        RoiAttr *roi_attr = &options->roi_tbl.roi_attr[index];
+
+        if (!roi_attr->enable) continue;
+
+        switch (roi_attr->index) {
+            case 0:
+                coding_cfg->roi1Area.left = RESOLUTION_TO_CTB(roi_attr->x, options->max_cu_size);
+                coding_cfg->roi1Area.top = RESOLUTION_TO_CTB(roi_attr->y, options->max_cu_size);
+                coding_cfg->roi1Area.right = RESOLUTION_TO_CTB((roi_attr->x + roi_attr->width), options->max_cu_size);
+                coding_cfg->roi1Area.bottom = RESOLUTION_TO_CTB((roi_attr->y + roi_attr->height), options->max_cu_size);
+                if (roi_attr->is_absQp) {
+                    // absolute QP
+                    coding_cfg->roi1DeltaQp = 0;
+                    coding_cfg->roi1Qp = roi_attr->qp;
+                } else {
+                    // relative QP
+                    coding_cfg->roi1DeltaQp = roi_attr->qp;
+                    coding_cfg->roi1Qp = -1;
+                }
+
+                if (vsv_check_area(&coding_cfg->roi1Area, options)
+                    && (coding_cfg->roi1DeltaQp || (coding_cfg->roi1Qp >= 0)))
+                    coding_cfg->roi1Area.enable = 1;
+                else {
+                    coding_cfg->roi1Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "roi1 is illegal, force disable\n");
+                }
+                break;
+            case 1:
+                coding_cfg->roi2Area.left = RESOLUTION_TO_CTB(roi_attr->x, options->max_cu_size);
+                coding_cfg->roi2Area.top = RESOLUTION_TO_CTB(roi_attr->y, options->max_cu_size);
+                coding_cfg->roi2Area.right = RESOLUTION_TO_CTB((roi_attr->x + roi_attr->width), options->max_cu_size);
+                coding_cfg->roi2Area.bottom = RESOLUTION_TO_CTB((roi_attr->y + roi_attr->height), options->max_cu_size);
+                if (roi_attr->is_absQp) {
+                    // absolute QP
+                    coding_cfg->roi2DeltaQp = 0;
+                    coding_cfg->roi2Qp = roi_attr->qp;
+                } else {
+                    // relative QP
+                    coding_cfg->roi2DeltaQp = roi_attr->qp;
+                    coding_cfg->roi2Qp = -1;
+                }
+
+                if (vsv_check_area(&coding_cfg->roi2Area, options)
+                    && (coding_cfg->roi2DeltaQp || (coding_cfg->roi2Qp >= 0)))
+                    coding_cfg->roi2Area.enable = 1;
+                else {
+                    coding_cfg->roi2Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "roi2 is illegal, force disable\n");
+                }
+                break;
+            case 2:
+                coding_cfg->roi3Area.left = RESOLUTION_TO_CTB(roi_attr->x, options->max_cu_size);
+                coding_cfg->roi3Area.top = RESOLUTION_TO_CTB(roi_attr->y, options->max_cu_size);
+                coding_cfg->roi3Area.right = RESOLUTION_TO_CTB((roi_attr->x + roi_attr->width), options->max_cu_size);
+                coding_cfg->roi3Area.bottom = RESOLUTION_TO_CTB((roi_attr->y + roi_attr->height), options->max_cu_size);
+                if (roi_attr->is_absQp) {
+                    // absolute QP
+                    coding_cfg->roi3DeltaQp = 0;
+                    coding_cfg->roi3Qp = roi_attr->qp;
+                } else {
+                    // relative QP
+                    coding_cfg->roi3DeltaQp = roi_attr->qp;
+                    coding_cfg->roi3Qp = -1;
+                }
+
+                if (vsv_check_area(&coding_cfg->roi3Area, options)
+                    && (coding_cfg->roi3DeltaQp || (coding_cfg->roi3Qp >= 0)))
+                    coding_cfg->roi3Area.enable = 1;
+                else {
+                    coding_cfg->roi3Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "roi3 is illegal, force disable\n");
+                }
+                break;
+            case 3:
+                coding_cfg->roi4Area.left = RESOLUTION_TO_CTB(roi_attr->x, options->max_cu_size);
+                coding_cfg->roi4Area.top = RESOLUTION_TO_CTB(roi_attr->y, options->max_cu_size);
+                coding_cfg->roi4Area.right = RESOLUTION_TO_CTB((roi_attr->x + roi_attr->width), options->max_cu_size);
+                coding_cfg->roi4Area.bottom = RESOLUTION_TO_CTB((roi_attr->y + roi_attr->height), options->max_cu_size);
+                if (roi_attr->is_absQp) {
+                    // absolute QP
+                    coding_cfg->roi4DeltaQp = 0;
+                    coding_cfg->roi4Qp = roi_attr->qp;
+                } else {
+                    // relative QP
+                    coding_cfg->roi4DeltaQp = roi_attr->qp;
+                    coding_cfg->roi4Qp = -1;
+                }
+
+                if (vsv_check_area(&coding_cfg->roi4Area, options)
+                    && (coding_cfg->roi4DeltaQp || (coding_cfg->roi4Qp >= 0)))
+                    coding_cfg->roi4Area.enable = 1;
+                else {
+                    coding_cfg->roi4Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "roi4 is illegal, force disable\n");
+                }
+                break;
+            case 4:
+                coding_cfg->roi5Area.left = RESOLUTION_TO_CTB(roi_attr->x, options->max_cu_size);
+                coding_cfg->roi5Area.top = RESOLUTION_TO_CTB(roi_attr->y, options->max_cu_size);
+                coding_cfg->roi5Area.right = RESOLUTION_TO_CTB((roi_attr->x + roi_attr->width), options->max_cu_size);
+                coding_cfg->roi5Area.bottom = RESOLUTION_TO_CTB((roi_attr->y + roi_attr->height), options->max_cu_size);
+                if (roi_attr->is_absQp) {
+                    // absolute QP
+                    coding_cfg->roi5DeltaQp = 0;
+                    coding_cfg->roi5Qp = roi_attr->qp;
+                } else {
+                    // relative QP
+                    coding_cfg->roi5DeltaQp = roi_attr->qp;
+                    coding_cfg->roi5Qp = -1;
+                }
+
+                if (vsv_check_area(&coding_cfg->roi5Area, options)
+                    && (coding_cfg->roi5DeltaQp || (coding_cfg->roi5Qp >= 0)))
+                    coding_cfg->roi5Area.enable = 1;
+                else {
+                    coding_cfg->roi5Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "roi5 is illegal, force disable\n");
+                }
+                break;
+            case 5:
+                coding_cfg->roi6Area.left = RESOLUTION_TO_CTB(roi_attr->x, options->max_cu_size);
+                coding_cfg->roi6Area.top = RESOLUTION_TO_CTB(roi_attr->y, options->max_cu_size);
+                coding_cfg->roi6Area.right = RESOLUTION_TO_CTB((roi_attr->x + roi_attr->width), options->max_cu_size);
+                coding_cfg->roi6Area.bottom = RESOLUTION_TO_CTB((roi_attr->y + roi_attr->height), options->max_cu_size);
+                if (roi_attr->is_absQp) {
+                    // absolute QP
+                    coding_cfg->roi6DeltaQp = 0;
+                    coding_cfg->roi6Qp = roi_attr->qp;
+                } else {
+                    // relative QP
+                    coding_cfg->roi6DeltaQp = roi_attr->qp;
+                    coding_cfg->roi6Qp = -1;
+                }
+
+                if (vsv_check_area(&coding_cfg->roi6Area, options)
+                    && (coding_cfg->roi6DeltaQp || (coding_cfg->roi6Qp >= 0)))
+                    coding_cfg->roi6Area.enable = 1;
+                else {
+                    coding_cfg->roi6Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "roi6 is illegal, force disable\n");
+                }
+                break;
+            case 6:
+                coding_cfg->roi7Area.left = RESOLUTION_TO_CTB(roi_attr->x, options->max_cu_size);
+                coding_cfg->roi7Area.top = RESOLUTION_TO_CTB(roi_attr->y, options->max_cu_size);
+                coding_cfg->roi7Area.right = RESOLUTION_TO_CTB((roi_attr->x + roi_attr->width), options->max_cu_size);
+                coding_cfg->roi7Area.bottom = RESOLUTION_TO_CTB((roi_attr->y + roi_attr->height), options->max_cu_size);
+                if (roi_attr->is_absQp) {
+                    // absolute QP
+                    coding_cfg->roi7DeltaQp = 0;
+                    coding_cfg->roi7Qp = roi_attr->qp;
+                } else {
+                    // relative QP
+                    coding_cfg->roi7DeltaQp = roi_attr->qp;
+                    coding_cfg->roi7Qp = -1;
+                }
+
+                if (vsv_check_area(&coding_cfg->roi7Area, options)
+                    && (coding_cfg->roi7DeltaQp || (coding_cfg->roi7Qp >= 0)))
+                    coding_cfg->roi7Area.enable = 1;
+                else {
+                    coding_cfg->roi7Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "roi7 is illegal, force disable\n");
+                }
+                break;
+            case 7:
+                coding_cfg->roi8Area.left = RESOLUTION_TO_CTB(roi_attr->x, options->max_cu_size);
+                coding_cfg->roi8Area.top = RESOLUTION_TO_CTB(roi_attr->y, options->max_cu_size);
+                coding_cfg->roi8Area.right = RESOLUTION_TO_CTB((roi_attr->x + roi_attr->width), options->max_cu_size);
+                coding_cfg->roi8Area.bottom = RESOLUTION_TO_CTB((roi_attr->y + roi_attr->height), options->max_cu_size);
+                if (roi_attr->is_absQp) {
+                    // absolute QP
+                    coding_cfg->roi8DeltaQp = 0;
+                    coding_cfg->roi8Qp = roi_attr->qp;
+                } else {
+                    // relative QP
+                    coding_cfg->roi8DeltaQp = roi_attr->qp;
+                    coding_cfg->roi8Qp = -1;
+                }
+
+                if (vsv_check_area(&coding_cfg->roi8Area, options)
+                    && (coding_cfg->roi8DeltaQp || (coding_cfg->roi8Qp >= 0)))
+                    coding_cfg->roi8Area.enable = 1;
+                else {
+                    coding_cfg->roi8Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "roi8 is illegal, force disable\n");
+                }
+                break;
+            default:
+                av_log(NULL, AV_LOG_ERROR, "roi index = %d is overflow\n", roi_attr->index);
+                break;
+        }
+    }
+    return 0;
+}
+
+static int vsv_encode_config_ipcm_areas(ESEncVidContext *options, VCEncCodingCtrl *coding_cfg) {
+    if (!options || !coding_cfg) {
+        av_log(NULL, AV_LOG_ERROR, "vsv_encode_config_ipcm_areas, invalid pointer\n");
+        return -1;
+    }
+
+    venc_print_ipcm(&options->ipcm_tbl);
+
+    for (int index = 0; index < options->ipcm_tbl.num_of_ipcm; index++) {
+        IpcmAttr *ipcm_attr = &options->ipcm_tbl.ipcm_attr[index];
+
+        if (!ipcm_attr->enable) continue;
+
+        switch (ipcm_attr->index) {
+            case 0:
+                coding_cfg->ipcm1Area.left = RESOLUTION_TO_CTB(ipcm_attr->x, options->max_cu_size);
+                coding_cfg->ipcm1Area.top = RESOLUTION_TO_CTB(ipcm_attr->y, options->max_cu_size);
+                coding_cfg->ipcm1Area.right =
+                    RESOLUTION_TO_CTB((ipcm_attr->x + ipcm_attr->width), options->max_cu_size);
+                coding_cfg->ipcm1Area.bottom =
+                    RESOLUTION_TO_CTB((ipcm_attr->y + ipcm_attr->height), options->max_cu_size);
+
+                if (vsv_check_area(&coding_cfg->ipcm1Area, options))
+                    coding_cfg->ipcm1Area.enable = 1;
+                else {
+                    coding_cfg->ipcm1Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "ipcm1 is illegal, force disable\n");
+                }
+                break;
+            case 1:
+                coding_cfg->ipcm2Area.left = RESOLUTION_TO_CTB(ipcm_attr->x, options->max_cu_size);
+                coding_cfg->ipcm2Area.top = RESOLUTION_TO_CTB(ipcm_attr->y, options->max_cu_size);
+                coding_cfg->ipcm2Area.right =
+                    RESOLUTION_TO_CTB((ipcm_attr->x + ipcm_attr->width), options->max_cu_size);
+                coding_cfg->ipcm2Area.bottom =
+                    RESOLUTION_TO_CTB((ipcm_attr->y + ipcm_attr->height), options->max_cu_size);
+
+                if (vsv_check_area(&coding_cfg->ipcm2Area, options))
+                    coding_cfg->ipcm2Area.enable = 1;
+                else {
+                    coding_cfg->ipcm2Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "ipcm2 is illegal, force disable\n");
+                }
+                break;
+            case 2:
+                coding_cfg->ipcm3Area.left = RESOLUTION_TO_CTB(ipcm_attr->x, options->max_cu_size);
+                coding_cfg->ipcm3Area.top = RESOLUTION_TO_CTB(ipcm_attr->y, options->max_cu_size);
+                coding_cfg->ipcm3Area.right =
+                    RESOLUTION_TO_CTB((ipcm_attr->x + ipcm_attr->width), options->max_cu_size);
+                coding_cfg->ipcm3Area.bottom =
+                    RESOLUTION_TO_CTB((ipcm_attr->y + ipcm_attr->height), options->max_cu_size);
+
+                if (vsv_check_area(&coding_cfg->ipcm3Area, options))
+                    coding_cfg->ipcm3Area.enable = 1;
+                else {
+                    coding_cfg->ipcm3Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "ipcm3 is illegal, force disable\n");
+                }
+                break;
+            case 3:
+                coding_cfg->ipcm4Area.left = RESOLUTION_TO_CTB(ipcm_attr->x, options->max_cu_size);
+                coding_cfg->ipcm4Area.top = RESOLUTION_TO_CTB(ipcm_attr->y, options->max_cu_size);
+                coding_cfg->ipcm4Area.right =
+                    RESOLUTION_TO_CTB((ipcm_attr->x + ipcm_attr->width), options->max_cu_size);
+                coding_cfg->ipcm4Area.bottom =
+                    RESOLUTION_TO_CTB((ipcm_attr->y + ipcm_attr->height), options->max_cu_size);
+
+                if (vsv_check_area(&coding_cfg->ipcm4Area, options))
+                    coding_cfg->ipcm4Area.enable = 1;
+                else {
+                    coding_cfg->ipcm4Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "ipcm4 is illegal, force disable\n");
+                }
+                break;
+            case 4:
+                coding_cfg->ipcm5Area.left = RESOLUTION_TO_CTB(ipcm_attr->x, options->max_cu_size);
+                coding_cfg->ipcm5Area.top = RESOLUTION_TO_CTB(ipcm_attr->y, options->max_cu_size);
+                coding_cfg->ipcm5Area.right =
+                    RESOLUTION_TO_CTB((ipcm_attr->x + ipcm_attr->width), options->max_cu_size);
+                coding_cfg->ipcm5Area.bottom =
+                    RESOLUTION_TO_CTB((ipcm_attr->y + ipcm_attr->height), options->max_cu_size);
+
+                if (vsv_check_area(&coding_cfg->ipcm5Area, options))
+                    coding_cfg->ipcm5Area.enable = 1;
+                else {
+                    coding_cfg->ipcm5Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "ipcm5 is illegal, force disable\n");
+                }
+                break;
+            case 5:
+                coding_cfg->ipcm6Area.left = RESOLUTION_TO_CTB(ipcm_attr->x, options->max_cu_size);
+                coding_cfg->ipcm6Area.top = RESOLUTION_TO_CTB(ipcm_attr->y, options->max_cu_size);
+                coding_cfg->ipcm6Area.right =
+                    RESOLUTION_TO_CTB((ipcm_attr->x + ipcm_attr->width), options->max_cu_size);
+                coding_cfg->ipcm6Area.bottom =
+                    RESOLUTION_TO_CTB((ipcm_attr->y + ipcm_attr->height), options->max_cu_size);
+
+                if (vsv_check_area(&coding_cfg->ipcm6Area, options))
+                    coding_cfg->ipcm6Area.enable = 1;
+                else {
+                    coding_cfg->ipcm6Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "ipcm6 is illegal, force disable\n");
+                }
+                break;
+            case 6:
+                coding_cfg->ipcm7Area.left = RESOLUTION_TO_CTB(ipcm_attr->x, options->max_cu_size);
+                coding_cfg->ipcm7Area.top = RESOLUTION_TO_CTB(ipcm_attr->y, options->max_cu_size);
+                coding_cfg->ipcm7Area.right =
+                    RESOLUTION_TO_CTB((ipcm_attr->x + ipcm_attr->width), options->max_cu_size);
+                coding_cfg->ipcm7Area.bottom =
+                    RESOLUTION_TO_CTB((ipcm_attr->y + ipcm_attr->height), options->max_cu_size);
+
+                if (vsv_check_area(&coding_cfg->ipcm7Area, options))
+                    coding_cfg->ipcm7Area.enable = 1;
+                else {
+                    coding_cfg->ipcm7Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "ipcm7 is illegal, force disable\n");
+                }
+                break;
+            case 7:
+                coding_cfg->ipcm8Area.left = RESOLUTION_TO_CTB(ipcm_attr->x, options->max_cu_size);
+                coding_cfg->ipcm8Area.top = RESOLUTION_TO_CTB(ipcm_attr->y, options->max_cu_size);
+                coding_cfg->ipcm8Area.right =
+                    RESOLUTION_TO_CTB((ipcm_attr->x + ipcm_attr->width), options->max_cu_size);
+                coding_cfg->ipcm8Area.bottom =
+                    RESOLUTION_TO_CTB((ipcm_attr->y + ipcm_attr->height), options->max_cu_size);
+
+                if (vsv_check_area(&coding_cfg->ipcm8Area, options))
+                    coding_cfg->ipcm8Area.enable = 1;
+                else {
+                    coding_cfg->ipcm8Area.enable = 0;
+                    av_log(NULL, AV_LOG_WARNING, "ipcm8 is illegal, force disable\n");
+                }
+                break;
+            default:
+                av_log(NULL, AV_LOG_ERROR, "ipcm index = %d is overflow\n", ipcm_attr->index);
+                break;
+        }
+    }
+    coding_cfg->pcm_enabled_flag =
+        (coding_cfg->ipcm1Area.enable || coding_cfg->ipcm2Area.enable
+         || coding_cfg->ipcm3Area.enable | coding_cfg->ipcm4Area.enable || coding_cfg->ipcm5Area.enable
+         || coding_cfg->ipcm6Area.enable || coding_cfg->ipcm7Area.enable | coding_cfg->ipcm8Area.enable);
+    return 0;
+}
+
+static int esenc_vid_init_ewl_inst(ESEncVidInternalContext *in_ctx) {
+    EWLInitParam_t param;
+    void *ewl_inst = NULL;
+
+    param.context = NULL;
+    param.clientType = EWL_CLIENT_TYPE_MEM;  // buffer operation
+    param.slice_idx = 0;
+    if ((in_ctx->ewl = EWLInit(&param)) == NULL) {
+        av_log(NULL, AV_LOG_ERROR, "EWLInit failed.\n");
+        return -1;
+    }
+
+    return 0;
+}
+
+/*------------------------------------------------------------------------------
+
+    OpenEncoder
+        Create and configure an encoder instance.
+
+    Params:
+        options     - processed comand line options
+        pEnc    - place where to save the new encoder instance
+    Return:
+        0   - for success
+        -1  - error
+
+------------------------------------------------------------------------------*/
+static int vsv_encode_open_encoder(ESEncVidContext *options, VCEncInst *enc, ESEncVidInternalContext *in_ctx) {
+    VCEncRet ret = -1;
+    VCEncConfig cfg;
+    VCEncCodingCtrl coding_cfg;
+    VCEncRateCtrl rc_cfg;
+    VCEncPreProcessingCfg pre_proc_cfg;
+    VCEncInst encoder = NULL;
+    int32_t i;
+    // EWLInitParam_t param;
+
+    // init parameters.
+    memset(&cfg, 0, sizeof(VCEncConfig));
+    memset(&coding_cfg, 0, sizeof(VCEncCodingCtrl));
+    memset(&rc_cfg, 0, sizeof(VCEncRateCtrl));
+    memset(&pre_proc_cfg, 0, sizeof(VCEncPreProcessingCfg));
+
+    ff_change_cml_customized_format(options);
+
+    /*cfg.ctb_size = options->max_cu_size;*/
+    if (options->rotation && options->rotation != 3) {
+        cfg.width = options->height;
+        cfg.height = options->width;
+    } else {
+        cfg.width = options->width;
+        cfg.height = options->height;
+    }
+
+    cfg.frameRateDenom = options->output_rate_denom;
+    cfg.frameRateNum = options->output_rate_numer;
+
+    /* intra tools in sps and pps */
+    cfg.strongIntraSmoothing = options->strong_intra_smoothing_enabled_flag;
+
+    cfg.streamType = (options->byte_stream) ? VCENC_BYTE_STREAM : VCENC_NAL_UNIT_STREAM;
+
+    cfg.profile = options->profile;
+    cfg.level = (VCEncLevel)options->level;
+    cfg.tier = (VCEncTier)options->tier;
+
+    cfg.codecFormat = options->codec_format;
+    cfg.gopSize = options->gop_size;
+
+    cfg.bitDepthLuma = cfg.bitDepthChroma = options->bitdepth;
+    // just support 8bit/10bit, luma and chroma must have same bit depth
+    if ((cfg.bitDepthLuma != 8 && cfg.bitDepthLuma != 10) || (cfg.bitDepthChroma != 8 && cfg.bitDepthChroma != 10)
+        || cfg.bitDepthLuma != cfg.bitDepthChroma) {
+        goto error_exit;
+    }
+
+    if ((options->interlaced_frame && options->gop_size != 1) || IS_H264(options->codec_format)) {
+        options->interlaced_frame = 0;
+    }
+
+    // DEFAULT maxTLayer
+    if (options->max_TLayers > options->gop_size) {
+        av_log(NULL,
+               AV_LOG_WARNING,
+               "max_TLayers: %d is overflow, force to %d\n",
+               options->max_TLayers,
+               options->gop_size);
+        cfg.maxTLayers = options->gop_size;
+    } else {
+        cfg.maxTLayers = options->max_TLayers;
+    }
+
+    /* Find the max number of reference frame */
+    if (options->intra_pic_rate == 1) {
+        cfg.refFrameAmount = 0;
+    } else {
+        uint32_t maxRefPics = 0;
+        uint32_t maxTemporalId = 0;
+        int idx;
+        for (idx = 0; idx < in_ctx->enc_in.gopConfig.size; idx++) {
+            VCEncGopPicConfig *gop_cfg = &(in_ctx->enc_in.gopConfig.pGopPicCfg[idx]);
+            if (gop_cfg->codingType != VCENC_INTRA_FRAME) {
+                if (maxRefPics < gop_cfg->numRefPics) maxRefPics = gop_cfg->numRefPics;
+                // config TID according maxTLayers
+                gop_cfg->temporalId = idx % cfg.maxTLayers;
+                // if (maxTemporalId < gop_cfg->temporalId) maxTemporalId = gop_cfg>temporalId;
+            }
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "gop size: %d, maxTLayers: %d, codingType: %d, temporalId: %d\n",
+                   in_ctx->enc_in.gopConfig.size,
+                   cfg.maxTLayers,
+                   gop_cfg->codingType,
+                   gop_cfg->temporalId);
+        }
+        cfg.refFrameAmount = maxRefPics + options->interlaced_frame + in_ctx->enc_in.gopConfig.ltrcnt;
+        // cfg.maxTLayers = maxTemporalId + 1;
+    }
+
+    cfg.compressor = options->compressor;
+    av_log(NULL, AV_LOG_DEBUG, "%s cfg.compressor = %d\n", __FUNCTION__, cfg.compressor);
+
+    cfg.interlacedFrame = options->interlaced_frame;
+    cfg.enableOutputCuInfo = (options->enable_output_cu_info > 0) ? 1 : 0;
+    cfg.rdoLevel = CLIP3(1, 3, options->rdo_level) - 1;
+    cfg.verbose = options->verbose;
+    cfg.exp_of_input_alignment = options->exp_of_input_alignment;
+    cfg.exp_of_ref_alignment = options->exp_of_ref_alignment;
+    cfg.exp_of_ref_ch_alignment = options->exp_of_ref_ch_alignment;
+    cfg.exp_of_aqinfo_alignment = cfg.exp_of_ref_ch_alignment;
+    cfg.exteralReconAlloc = 0;
+    cfg.P010RefEnable = options->p010_ref_enable;
+    cfg.enableSsim = options->ssim;
+    cfg.ctbRcMode = (options->ctb_rc != DEFAULT) ? options->ctb_rc : 0;
+    cfg.parallelCoreNum = options->parallel_core_num;
+    cfg.pass = (options->lookahead_depth ? 2 : 0);
+    cfg.bPass1AdaptiveGop = (options->gop_size == 0);
+    cfg.picOrderCntType = options->pic_order_cnt_type;
+    cfg.dumpRegister = options->dump_register;
+    cfg.rasterscan = options->rasterscan;
+    cfg.log2MaxPicOrderCntLsb = options->log2_max_pic_order_cnt_lsb;
+    cfg.log2MaxFrameNum = options->log2_max_frame_num;
+    cfg.lookaheadDepth = options->lookahead_depth;
+    cfg.extDSRatio = (options->lookahead_depth ? 1 : 0);
+    if (options->parallel_core_num > 1 && cfg.width * cfg.height < 256 * 256) {
+        cfg.parallelCoreNum = options->parallel_core_num = 1;
+    }
+    cfg.codedChromaIdc = VCENC_CHROMA_IDC_420;
+    cfg.tune = VCENC_TUNE_PSNR;
+    cfg.cuInfoVersion = -1;
+#if 0
+    cfg.extSramLumHeightBwd = IS_H264(options->codec_format) ? 12 : (IS_HEVC(options->codec_format) ? 16 : 0);
+    cfg.extSramChrHeightBwd = IS_H264(options->codec_format) ? 6 : (IS_HEVC(options->codec_format) ? 8 : 0);
+    cfg.extSramLumHeightFwd = IS_H264(options->codec_format) ? 12 : (IS_HEVC(options->codec_format) ? 16 : 0);
+    cfg.extSramChrHeightFwd = IS_H264(options->codec_format) ? 6 : (IS_HEVC(options->codec_format) ? 8 : 0);
+
+    cfg.AXIAlignment = 0;
+    cfg.irqTypeMask = 0x01f0;
+    cfg.irqTypeCutreeMask = 0x01f0;
+
+    cfg.TxTypeSearchEnable = 0;
+    cfg.av1InterFiltSwitch = 1;
+    cfg.burstMaxLength = ENCH2_DEFAULT_BURST_LENGTH;
+    cfg.enableTMVP = 0;
+    cfg.bIOBufferBinding = 0;
+#endif
+    cfg.writeReconToDDR = 1;
+    cfg.enablePsnr = 1;
+
+    if ((ret = VCEncInit(&cfg, enc, NULL)) != VCENC_OK) {
+        av_log(NULL, AV_LOG_ERROR, "VCEncInit fail\n");
+        //        encoder = *enc;
+        goto error_exit;
+    }
+    encoder = *enc;
+
+    av_log(NULL, AV_LOG_DEBUG, "VCEncInit OK\n");
+
+    if (esenc_vid_init_ewl_inst(&options->in_ctx)) {
+        return -1;
+    }
+
+    /* Encoder setup: coding control */
+    if ((ret = VCEncGetCodingCtrl(encoder, &coding_cfg)) != VCENC_OK) {
+        av_log(NULL, AV_LOG_ERROR, "VCEncGetCodingCtrl failed\n");
+        goto error_exit;
+    } else {
+        av_log(NULL,
+               AV_LOG_INFO,
+               "GetCodingCtrl, sliceSize %2d,sei %2d,disable-deblocking %2d,enableCabac %2d,enableSao "
+               "%2d\n",
+               coding_cfg.sliceSize,
+               coding_cfg.seiMessages,
+               coding_cfg.disableDeblockingFilter,
+               coding_cfg.enableCabac,
+               coding_cfg.enableSao);
+
+        if (options->slice_size != DEFAULT) coding_cfg.sliceSize = options->slice_size;
+        if (IS_H264(options->codec_format)) {
+            coding_cfg.enableCabac = options->enable_cabac;
+        }
+
+        coding_cfg.disableDeblockingFilter = !options->enable_deblocking;
+        coding_cfg.tc_Offset = options->tc_offset;
+        coding_cfg.beta_Offset = options->beta_offset;
+        if (IS_HEVC(options->codec_format)) {
+            coding_cfg.enableSao = options->enable_sao;
+        }
+        coding_cfg.enableDeblockOverride = options->enable_deblock_override;
+        coding_cfg.deblockOverride = options->deblock_override;
+
+        coding_cfg.seiMessages = options->enable_sei;
+
+        coding_cfg.gdrDuration = options->gdr_duration;
+        coding_cfg.fieldOrder = options->field_order;
+
+        coding_cfg.cirStart = options->cir_start;
+        coding_cfg.cirInterval = options->cir_interval;
+
+        if (coding_cfg.gdrDuration == 0) {
+            coding_cfg.intraArea.top = options->intra_area_top;
+            coding_cfg.intraArea.left = options->intra_area_left;
+            coding_cfg.intraArea.bottom = options->intra_area_bottom;
+            coding_cfg.intraArea.right = options->intra_area_right;
+            coding_cfg.intraArea.enable = vsv_check_area(&coding_cfg.intraArea, options);
+        } else {
+            // intraArea will be used by GDR, customer can not use intraArea when GDR is enabled.
+            coding_cfg.intraArea.enable = 0;
+        }
+
+        coding_cfg.pcm_loop_filter_disabled_flag = options->pcm_loop_filter_disabled_flag;
+
+        vsv_encode_config_ipcm_areas(options, &coding_cfg);
+
+        // roi cfg
+        vsv_encode_config_roi_areas(options, &coding_cfg);
+
+        if (coding_cfg.cirInterval)
+            av_log(NULL, AV_LOG_INFO, "  CIR: %d %d\n", coding_cfg.cirStart, coding_cfg.cirInterval);
+
+        if (coding_cfg.intraArea.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  IntraArea: %dx%d-%dx%d\n",
+                   coding_cfg.intraArea.left,
+                   coding_cfg.intraArea.top,
+                   coding_cfg.intraArea.right,
+                   coding_cfg.intraArea.bottom);
+
+        if (coding_cfg.ipcm1Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  IPCM1Area: %dx%d-%dx%d\n",
+                   coding_cfg.ipcm1Area.left,
+                   coding_cfg.ipcm1Area.top,
+                   coding_cfg.ipcm1Area.right,
+                   coding_cfg.ipcm1Area.bottom);
+
+        if (coding_cfg.ipcm2Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  IPCM2Area: %dx%d-%dx%d\n",
+                   coding_cfg.ipcm2Area.left,
+                   coding_cfg.ipcm2Area.top,
+                   coding_cfg.ipcm2Area.right,
+                   coding_cfg.ipcm2Area.bottom);
+
+        if (coding_cfg.ipcm3Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  IPCM3Area: %dx%d-%dx%d\n",
+                   coding_cfg.ipcm3Area.left,
+                   coding_cfg.ipcm3Area.top,
+                   coding_cfg.ipcm3Area.right,
+                   coding_cfg.ipcm3Area.bottom);
+
+        if (coding_cfg.ipcm4Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  IPCM4Area: %dx%d-%dx%d\n",
+                   coding_cfg.ipcm4Area.left,
+                   coding_cfg.ipcm4Area.top,
+                   coding_cfg.ipcm4Area.right,
+                   coding_cfg.ipcm4Area.bottom);
+
+        if (coding_cfg.ipcm5Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  IPCM5Area: %dx%d-%dx%d\n",
+                   coding_cfg.ipcm5Area.left,
+                   coding_cfg.ipcm5Area.top,
+                   coding_cfg.ipcm5Area.right,
+                   coding_cfg.ipcm5Area.bottom);
+
+        if (coding_cfg.ipcm6Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  IPCM6Area: %dx%d-%dx%d\n",
+                   coding_cfg.ipcm6Area.left,
+                   coding_cfg.ipcm6Area.top,
+                   coding_cfg.ipcm6Area.right,
+                   coding_cfg.ipcm6Area.bottom);
+
+        if (coding_cfg.ipcm7Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  IPCM7Area: %dx%d-%dx%d\n",
+                   coding_cfg.ipcm7Area.left,
+                   coding_cfg.ipcm7Area.top,
+                   coding_cfg.ipcm7Area.right,
+                   coding_cfg.ipcm7Area.bottom);
+
+        if (coding_cfg.ipcm8Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  IPCM8Area: %dx%d-%dx%d\n",
+                   coding_cfg.ipcm8Area.left,
+                   coding_cfg.ipcm8Area.top,
+                   coding_cfg.ipcm8Area.right,
+                   coding_cfg.ipcm8Area.bottom);
+
+        if (coding_cfg.roi1Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  ROI 1: %s %d  %dx%d-%dx%d\n",
+                   coding_cfg.roi1Qp >= 0 ? "QP" : "QP Delta",
+                   coding_cfg.roi1Qp >= 0 ? coding_cfg.roi1Qp : coding_cfg.roi1DeltaQp,
+                   coding_cfg.roi1Area.left,
+                   coding_cfg.roi1Area.top,
+                   coding_cfg.roi1Area.right,
+                   coding_cfg.roi1Area.bottom);
+
+        if (coding_cfg.roi2Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  ROI 2: %s %d  %dx%d-%dx%d\n",
+                   coding_cfg.roi2Qp >= 0 ? "QP" : "QP Delta",
+                   coding_cfg.roi2Qp >= 0 ? coding_cfg.roi2Qp : coding_cfg.roi2DeltaQp,
+                   coding_cfg.roi2Area.left,
+                   coding_cfg.roi2Area.top,
+                   coding_cfg.roi2Area.right,
+                   coding_cfg.roi2Area.bottom);
+
+        if (coding_cfg.roi3Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  ROI 3: %s %d  %dx%d-%dx%d\n",
+                   coding_cfg.roi3Qp >= 0 ? "QP" : "QP Delta",
+                   coding_cfg.roi3Qp >= 0 ? coding_cfg.roi3Qp : coding_cfg.roi3DeltaQp,
+                   coding_cfg.roi3Area.left,
+                   coding_cfg.roi3Area.top,
+                   coding_cfg.roi3Area.right,
+                   coding_cfg.roi3Area.bottom);
+
+        if (coding_cfg.roi4Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  ROI 4: %s %d  %dx%d-%dx%d\n",
+                   coding_cfg.roi4Qp >= 0 ? "QP" : "QP Delta",
+                   coding_cfg.roi4Qp >= 0 ? coding_cfg.roi4Qp : coding_cfg.roi4DeltaQp,
+                   coding_cfg.roi4Area.left,
+                   coding_cfg.roi4Area.top,
+                   coding_cfg.roi4Area.right,
+                   coding_cfg.roi4Area.bottom);
+
+        if (coding_cfg.roi5Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  ROI 5: %s %d  %dx%d-%dx%d\n",
+                   coding_cfg.roi5Qp >= 0 ? "QP" : "QP Delta",
+                   coding_cfg.roi5Qp >= 0 ? coding_cfg.roi5Qp : coding_cfg.roi5DeltaQp,
+                   coding_cfg.roi5Area.left,
+                   coding_cfg.roi5Area.top,
+                   coding_cfg.roi5Area.right,
+                   coding_cfg.roi5Area.bottom);
+
+        if (coding_cfg.roi6Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  ROI 6: %s %d  %dx%d-%dx%d\n",
+                   coding_cfg.roi6Qp >= 0 ? "QP" : "QP Delta",
+                   coding_cfg.roi6Qp >= 0 ? coding_cfg.roi6Qp : coding_cfg.roi6DeltaQp,
+                   coding_cfg.roi6Area.left,
+                   coding_cfg.roi6Area.top,
+                   coding_cfg.roi6Area.right,
+                   coding_cfg.roi6Area.bottom);
+
+        if (coding_cfg.roi7Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  ROI 7: %s %d  %dx%d-%dx%d\n",
+                   coding_cfg.roi7Qp >= 0 ? "QP" : "QP Delta",
+                   coding_cfg.roi7Qp >= 0 ? coding_cfg.roi7Qp : coding_cfg.roi7DeltaQp,
+                   coding_cfg.roi7Area.left,
+                   coding_cfg.roi7Area.top,
+                   coding_cfg.roi7Area.right,
+                   coding_cfg.roi7Area.bottom);
+
+        if (coding_cfg.roi8Area.enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "  ROI 8: %s %d  %dx%d-%dx%d\n",
+                   coding_cfg.roi8Qp >= 0 ? "QP" : "QP Delta",
+                   coding_cfg.roi8Qp >= 0 ? coding_cfg.roi8Qp : coding_cfg.roi8DeltaQp,
+                   coding_cfg.roi8Area.left,
+                   coding_cfg.roi8Area.top,
+                   coding_cfg.roi8Area.right,
+                   coding_cfg.roi8Area.bottom);
+
+        coding_cfg.roiMapDeltaQpEnable = options->roi_map_delta_qp_enable;
+        coding_cfg.roiMapDeltaQpBlockUnit = options->roi_map_delta_qp_block_unit;
+
+        coding_cfg.RoimapCuCtrl_index_enable = (options->roimap_cu_ctrl_index_bin_file != NULL);
+        coding_cfg.RoimapCuCtrl_enable = (options->roimap_cu_ctrl_info_bin_file != NULL);
+        // coding_cfg.roiMapDeltaQpEnable = (options->roi_map_info_bin_file != NULL);
+        coding_cfg.RoimapCuCtrl_ver = options->roi_cu_ctrl_ver;
+        coding_cfg.RoiQpDelta_ver = options->roi_qp_delta_ver;
+
+        /* SKIP map */
+        coding_cfg.skipMapEnable = options->skip_map_enable;
+
+        coding_cfg.enableScalingList = options->enable_scaling_list;
+        coding_cfg.chroma_qp_offset = options->chroma_qp_offset;
+
+        /* low latency */
+        coding_cfg.inputLineBufEn = (options->input_line_buf_mode > 0) ? 1 : 0;
+        coding_cfg.inputLineBufLoopBackEn =
+            (options->input_line_buf_mode == 1 || options->input_line_buf_mode == 2) ? 1 : 0;
+        if (options->input_line_buf_depth != DEFAULT) coding_cfg.inputLineBufDepth = options->input_line_buf_depth;
+        coding_cfg.amountPerLoopBack = options->amount_per_loop_back;
+        coding_cfg.inputLineBufHwModeEn =
+            (options->input_line_buf_mode == 2 || options->input_line_buf_mode == 4) ? 1 : 0;
+        coding_cfg.inputLineBufCbFunc = VCEncInputLineBufDone;
+        coding_cfg.inputLineBufCbData = &(in_ctx->input_ctb_line_buf);
+
+        /*stream multi-segment*/
+        coding_cfg.streamMultiSegmentMode = options->stream_multi_segment_mode;
+        coding_cfg.streamMultiSegmentAmount = options->stream_multi_segment_amount;
+        coding_cfg.streamMultiSegCbFunc = &EncStreamSegmentReady;
+        coding_cfg.streamMultiSegCbData = &(in_ctx->stream_seg_ctl);
+
+        /* tile */
+        coding_cfg.tiles_enabled_flag = options->tiles_enabled_flag && !IS_H264(options->codec_format);
+        coding_cfg.num_tile_columns = options->num_tile_columns;
+        coding_cfg.num_tile_rows = options->num_tile_rows;
+        coding_cfg.loop_filter_across_tiles_enabled_flag = options->loop_filter_across_tiles_enabled_flag;
+
+        /* HDR10 */
+        coding_cfg.Hdr10Display.hdr10_display_enable = options->hdr10_display.hdr10_display_enable;
+        if (options->hdr10_display.hdr10_display_enable) {
+            coding_cfg.Hdr10Display.hdr10_dx0 = options->hdr10_display.hdr10_dx0;
+            coding_cfg.Hdr10Display.hdr10_dy0 = options->hdr10_display.hdr10_dy0;
+            coding_cfg.Hdr10Display.hdr10_dx1 = options->hdr10_display.hdr10_dx1;
+            coding_cfg.Hdr10Display.hdr10_dy1 = options->hdr10_display.hdr10_dy1;
+            coding_cfg.Hdr10Display.hdr10_dx2 = options->hdr10_display.hdr10_dx2;
+            coding_cfg.Hdr10Display.hdr10_dy2 = options->hdr10_display.hdr10_dy2;
+            coding_cfg.Hdr10Display.hdr10_wx = options->hdr10_display.hdr10_wx;
+            coding_cfg.Hdr10Display.hdr10_wy = options->hdr10_display.hdr10_wy;
+            coding_cfg.Hdr10Display.hdr10_maxluma = options->hdr10_display.hdr10_maxluma;
+            coding_cfg.Hdr10Display.hdr10_minluma = options->hdr10_display.hdr10_minluma;
+        }
+
+        coding_cfg.Hdr10LightLevel.hdr10_lightlevel_enable = options->hdr10_light.hdr10_lightlevel_enable;
+        if (options->hdr10_light.hdr10_lightlevel_enable) {
+            coding_cfg.Hdr10LightLevel.hdr10_maxlight = options->hdr10_light.hdr10_maxlight;
+            coding_cfg.Hdr10LightLevel.hdr10_avglight = options->hdr10_light.hdr10_avglight;
+        }
+
+        if (coding_cfg.Hdr10Display.hdr10_display_enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "HDR10 Display: dx0=%d, dy0=%d, dx1=%d, dy1=%d, dx2=%d, dy2=%d, wx=%d, wy=%d, maxluma=%d, "
+                   "minluma=%d .\n",
+                   coding_cfg.Hdr10Display.hdr10_dx0,
+                   coding_cfg.Hdr10Display.hdr10_dy0,
+                   coding_cfg.Hdr10Display.hdr10_dx1,
+                   coding_cfg.Hdr10Display.hdr10_dy1,
+                   coding_cfg.Hdr10Display.hdr10_dx2,
+                   coding_cfg.Hdr10Display.hdr10_dy2,
+                   coding_cfg.Hdr10Display.hdr10_wx,
+                   coding_cfg.Hdr10Display.hdr10_wy,
+                   coding_cfg.Hdr10Display.hdr10_maxluma,
+                   coding_cfg.Hdr10Display.hdr10_minluma);
+
+        if (coding_cfg.Hdr10LightLevel.hdr10_lightlevel_enable)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "HDR10 Light: maxlight=%d, avglight=%d .\n",
+                   coding_cfg.Hdr10LightLevel.hdr10_maxlight,
+                   coding_cfg.Hdr10LightLevel.hdr10_avglight);
+
+        coding_cfg.vuiColorDescription.vuiColorDescripPresentFlag = options->hdr10_color.hdr10_color_enable;
+        coding_cfg.vuiVideoSignalTypePresentFlag = coding_cfg.vuiColorDescription.vuiColorDescripPresentFlag;
+        if (options->hdr10_color.hdr10_color_enable) {
+            coding_cfg.vuiColorDescription.vuiMatrixCoefficients = options->hdr10_color.hdr10_matrix;
+            coding_cfg.vuiColorDescription.vuiColorPrimaries = options->hdr10_color.hdr10_primary;
+
+            if (options->hdr10_color.hdr10_transfer == 1)
+                coding_cfg.vuiColorDescription.vuiTransferCharacteristics = VCENC_HDR10_ST2084;
+            else if (options->hdr10_color.hdr10_transfer == 2)
+                coding_cfg.vuiColorDescription.vuiTransferCharacteristics = VCENC_HDR10_STDB67;
+            else
+                coding_cfg.vuiColorDescription.vuiTransferCharacteristics = VCENC_HDR10_BT2020;
+        }
+
+        if (coding_cfg.vuiColorDescription.vuiColorDescripPresentFlag)
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "HDR10 Color: primary=%d, transfer=%d, matrix=%d .\n",
+                   coding_cfg.vuiColorDescription.vuiColorPrimaries,
+                   coding_cfg.vuiColorDescription.vuiMatrixCoefficients,
+                   coding_cfg.vuiColorDescription.vuiTransferCharacteristics);
+
+        coding_cfg.RpsInSliceHeader = options->rps_in_slice_header;
+
+        av_log(NULL,
+               AV_LOG_INFO,
+               "SetCodingCtrl, sliceSize %2d,sei %2d,disable-deblocking %2d,enableCabac %2d,enableSao "
+               "%2d roiMapDeltaQpEnable %2d roiMapDeltaQpBlockUnit %2d\n",
+               coding_cfg.sliceSize,
+               coding_cfg.seiMessages,
+               coding_cfg.disableDeblockingFilter,
+               coding_cfg.enableCabac,
+               coding_cfg.enableSao,
+               coding_cfg.roiMapDeltaQpEnable,
+               coding_cfg.roiMapDeltaQpBlockUnit);
+
+        if ((ret = VCEncSetCodingCtrl(encoder, &coding_cfg)) != VCENC_OK) {
+            av_log(NULL, AV_LOG_ERROR, "VCEncSetCodingCtrl failed\n");
+            goto error_exit;
+        }
+    }
+
+    /* Encoder setup: rate control */
+    if ((ret = VCEncGetRateCtrl(encoder, &rc_cfg)) != VCENC_OK) {
+        av_log(NULL, AV_LOG_ERROR, "VCEncGetRateCtrl failed\n");
+        goto error_exit;
+    } else {
+        av_log(NULL,
+               AV_LOG_INFO,
+               "Get rate control: qp %2d qpRange I[%2d, %2d] PB[%2d, %2d] %8d bps  "
+               "pic %d skip %d  hrd %d  cpbSize %d bitrateWindow %d "
+               "intraQpDelta %2d rcMode %2d\n",
+               rc_cfg.qpHdr,
+               rc_cfg.qpMinI,
+               rc_cfg.qpMaxI,
+               rc_cfg.qpMinPB,
+               rc_cfg.qpMaxPB,
+               rc_cfg.bitPerSecond,
+               rc_cfg.pictureRc,
+               rc_cfg.pictureSkip,
+               rc_cfg.hrd,
+               rc_cfg.hrdCpbSize,
+               rc_cfg.bitrateWindow,
+               rc_cfg.intraQpDelta,
+               rc_cfg.rcMode);
+
+        // do not modify qpHdr
+        if (options->qp_hdr != DEFAULT)
+            rc_cfg.qpHdr = options->qp_hdr;
+        else
+            rc_cfg.qpHdr = -1;
+        rc_cfg.blockRCSize = 0;
+        rc_cfg.rcQpDeltaRange = 10;
+        rc_cfg.rcBaseMBComplexity = 15;
+        rc_cfg.monitorFrames =
+            (options->output_rate_numer + options->output_rate_denom - 1) / options->output_rate_denom;
+        options->monitor_frames =
+            (options->output_rate_numer + options->output_rate_denom - 1) / options->output_rate_denom;
+
+        rc_cfg.u32StaticSceneIbitPercent = options->u32_static_scene_ibit_percent;
+
+        // RC setting
+        rc_cfg.rcMode = options->rc_mode;
+        switch (rc_cfg.rcMode) {
+            case VCE_RC_CVBR:
+                rc_cfg.bitrateWindow = options->bitrate_window;
+                rc_cfg.qpMinI = rc_cfg.qpMinPB = options->qp_min;
+                rc_cfg.qpMaxI = rc_cfg.qpMaxPB = options->qp_max;
+                if (options->bit_per_second != DEFAULT) {
+                    rc_cfg.bitPerSecond = options->bit_per_second;
+                }
+                break;
+            case VCE_RC_CBR:
+                rc_cfg.bitrateWindow = options->bitrate_window;
+                if (options->bit_per_second != DEFAULT) {
+                    rc_cfg.bitPerSecond = options->bit_per_second;
+                }
+                rc_cfg.hrdCpbSize = 2 * rc_cfg.bitPerSecond;
+                break;
+            case VCE_RC_VBR:
+                rc_cfg.bitrateWindow = options->bitrate_window;
+                rc_cfg.qpMinI = rc_cfg.qpMinPB = options->qp_min;
+                if (options->bit_per_second != DEFAULT) {
+                    rc_cfg.bitPerSecond = options->bit_per_second;
+                }
+                break;
+            case VCE_RC_ABR:
+                if (options->bit_per_second != DEFAULT) {
+                    rc_cfg.bitPerSecond = options->bit_per_second;
+                }
+                break;
+            case VCE_RC_CQP:
+                rc_cfg.fixedIntraQp = options->fixed_qp_I;
+                // fixing, how to set B/P
+                // rc_cfg.fixedIntraQp = options->fixed_qp_P;
+                // rc_cfg.fixedIntraQp = options->fixed_qp_B;
+                break;
+            default:
+                av_log(NULL, AV_LOG_ERROR, "This version is not support CRF\n");
+                ret = -1;
+                goto error_exit;
+                break;
+        }
+
+        av_log(NULL,
+               AV_LOG_INFO,
+               "Set rate control: qp %2d qpRange I[%2d, %2d] PB[%2d, %2d] %9d bps  "
+               "pic %d skip %d  hrd %d"
+               "  cpbSize %d bitrateWindow %d intraQpDelta %2d "
+               "fixedIntraQp %2d rcMode %2d\n",
+               rc_cfg.qpHdr,
+               rc_cfg.qpMinI,
+               rc_cfg.qpMaxI,
+               rc_cfg.qpMinPB,
+               rc_cfg.qpMaxPB,
+               rc_cfg.bitPerSecond,
+               rc_cfg.pictureRc,
+               rc_cfg.pictureSkip,
+               rc_cfg.hrd,
+               rc_cfg.hrdCpbSize,
+               rc_cfg.bitrateWindow,
+               rc_cfg.intraQpDelta,
+               rc_cfg.fixedIntraQp,
+               rc_cfg.rcMode);
+
+        if ((ret = VCEncSetRateCtrl(encoder, &rc_cfg)) != VCENC_OK) {
+            av_log(NULL, AV_LOG_ERROR, "VCEncSetRateCtrl failed\n");
+            goto error_exit;
+        }
+    }
+    /* PreP setup */
+    if ((ret = VCEncGetPreProcessing(encoder, &pre_proc_cfg)) != VCENC_OK) {
+        av_log(NULL, AV_LOG_ERROR, "VCEncGetPreProcessing failed\n");
+        goto error_exit;
+    }
+
+    av_log(NULL,
+           AV_LOG_INFO,
+           "Get PreP: input %4dx%d : offset %4dx%d : format %d : rotation %d"
+           " : mirror %d : cc %d : scaling %d\n",
+           pre_proc_cfg.origWidth,
+           pre_proc_cfg.origHeight,
+           pre_proc_cfg.xOffset,
+           pre_proc_cfg.yOffset,
+           pre_proc_cfg.inputType,
+           pre_proc_cfg.rotation,
+           pre_proc_cfg.mirror,
+           pre_proc_cfg.colorConversion.type,
+           pre_proc_cfg.scaledOutput);
+
+    pre_proc_cfg.inputType = (VCEncPictureType)options->input_format;
+    pre_proc_cfg.rotation = (VCEncPictureRotation)options->rotation;
+    pre_proc_cfg.mirror = (VCEncPictureMirror)options->mirror;
+
+    pre_proc_cfg.origWidth = options->lum_width_src;
+    pre_proc_cfg.origHeight = options->lum_height_src;
+    if (options->interlaced_frame) pre_proc_cfg.origHeight /= 2;
+    pre_proc_cfg.xOffset = options->hor_offset_src;
+    pre_proc_cfg.yOffset = options->ver_offset_src;
+    if (options->color_conversion != DEFAULT)
+        pre_proc_cfg.colorConversion.type = (VCEncColorConversionType)options->color_conversion;
+    if (pre_proc_cfg.colorConversion.type == VCENC_RGBTOYUV_USER_DEFINED) {
+        pre_proc_cfg.colorConversion.coeffA = 20000;
+        pre_proc_cfg.colorConversion.coeffB = 44000;
+        pre_proc_cfg.colorConversion.coeffC = 5000;
+        pre_proc_cfg.colorConversion.coeffE = 35000;
+        pre_proc_cfg.colorConversion.coeffF = 38000;
+        pre_proc_cfg.colorConversion.coeffG = 35000;
+        pre_proc_cfg.colorConversion.coeffH = 38000;
+        pre_proc_cfg.colorConversion.LumaOffset = 0;
+    }
+
+#ifdef USE_OLD_DRV
+    pre_proc_cfg.virtualAddressScaledBuff = in_ctx->scaled_picture_mem.virtualAddress;
+#endif
+    pre_proc_cfg.input_alignment = 1 << options->exp_of_input_alignment;
+
+    av_log(NULL,
+           AV_LOG_INFO,
+           "Set PreP: input %4dx%d : offset %4dx%d : format %d : rotation %d"
+           " : mirror %d : cc %d \n",
+           pre_proc_cfg.origWidth,
+           pre_proc_cfg.origHeight,
+           pre_proc_cfg.xOffset,
+           pre_proc_cfg.yOffset,
+           pre_proc_cfg.inputType,
+           pre_proc_cfg.rotation,
+           pre_proc_cfg.mirror,
+           pre_proc_cfg.colorConversion.type);
+
+    /* constant chroma control */
+    pre_proc_cfg.constChromaEn = options->const_chroma_en;
+    if (options->const_cb != DEFAULT) pre_proc_cfg.constCb = options->const_cb;
+    if (options->const_cr != DEFAULT) pre_proc_cfg.constCr = options->const_cr;
+
+    ff_change_to_customized_format(options, &pre_proc_cfg);
+
+    ff_change_format_for_fb(in_ctx, options, &pre_proc_cfg);
+
+    if ((ret = VCEncSetPreProcessing(encoder, &pre_proc_cfg)) != VCENC_OK) {
+        av_log(NULL, AV_LOG_ERROR, "VCEncSetPreProcessing failed\n");
+        goto error_exit;
+    }
+    ret = 0;
+
+error_exit:
+    return ret;
+}
+
+/*------------------------------------------------------------------------------
+
+    close_encoder
+       Release an encoder insatnce.
+
+   Params:
+        encoder - the instance to be released
+------------------------------------------------------------------------------*/
+static void vsv_encode_close_encoder(VCEncInst encoder, ESEncVidInternalContext *in_ctx) {
+    if (in_ctx->ewl) {
+        EWLRelease(in_ctx->ewl);
+        in_ctx->ewl = NULL;
+    }
+
+    if (encoder) {
+        if (VCEncRelease(encoder) != VCENC_OK) {
+            av_log(NULL, AV_LOG_ERROR, "VCEncRelease failed\n");
+        }
+    }
+
+    if (in_ctx->two_pass_ewl) {
+        EWLRelease(in_ctx->two_pass_ewl);
+        in_ctx->two_pass_ewl = NULL;
+    }
+}
+
+static int venc_get_extradata(AVCodecContext *avctx) {
+    if (!avctx) return -1;
+
+    ESEncVidContext *h26xCtx = (ESEncVidContext *)avctx->priv_data;
+    uint32_t stream_size = h26xCtx->encOut.streamSize;
+
+    av_log(NULL, AV_LOG_INFO, "venc_get_extradata, steam_size: %d\n", stream_size);
+    /* send start data */
+    if (stream_size) {
+        ESEncVidInternalContext *in_ctx = &h26xCtx->in_ctx;
+        // multi-core: output bitstream has (in_ctx->parallel_core_num-1) delay
+        int32_t core_idx = (in_ctx->picture_enc_cnt - 1 - (in_ctx->frame_delay - 1)) % in_ctx->parallel_core_num;
+        int32_t i_buf;
+        EWLLinearMem_t mem;
+        for (i_buf = 0; i_buf < in_ctx->stream_buf_num; i_buf++)
+            in_ctx->outbuf_mem[i_buf] = &(in_ctx->outbuf_mem_factory[core_idx][i_buf]);
+
+        mem = *in_ctx->outbuf_mem[0];
+
+        if ((avctx->extradata = av_realloc(avctx->extradata, stream_size)) == NULL) return AVERROR(ENOMEM);
+
+        memcpy(avctx->extradata, (uint8_t *)mem.virtualAddress, stream_size);
+        avctx->extradata_size = stream_size;
+        h26xCtx->encoder_is_start = 1;
+    }
+
+    return 0;
+}
+
+static int vsv_encode_start(AVCodecContext *avctx) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidContext *options = ctx;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+    VCEncIn *enc_in = (VCEncIn *)&(in_ctx->enc_in);
+    VCEncOut *enc_out = (VCEncOut *)&ctx->encOut;
+    int stream_size = 0;
+
+    int32_t p = 0;
+    int cnt = 1;
+
+    uint32_t gop_size = options->gop_size;
+    ctx->adaptive_gop = (gop_size == 0);
+
+    memset(&ctx->agop, 0, sizeof(ctx->agop));
+    ctx->agop.last_gop_size = MAX_ADAPTIVE_GOP_SIZE;
+
+    // enc_in->gopSize = gop_size;
+
+    ctx->ma.pos = ctx->ma.count = 0;
+    ctx->ma.frame_rate_numer = options->output_rate_numer;
+    ctx->ma.frame_rate_denom = options->output_rate_denom;
+    if (options->output_rate_denom)
+        ctx->ma.length = MAX(LEAST_MONITOR_FRAME, MIN(options->monitor_frames, MOVING_AVERAGE_FRAMES));
+    else
+        ctx->ma.length = MOVING_AVERAGE_FRAMES;
+
+    enc_in->timeIncrement = 0;
+    enc_in->vui_timing_info_enable = options->enable_vui;
+
+    ff_get_output_buffer(in_ctx, enc_in);
+
+    enc_in->hashType = options->hashtype;
+    ff_init_slice_ctl(in_ctx, options);
+    ff_init_stream_segment_ctl(in_ctx, options);
+
+    if (options->input_line_buf_mode) {
+        if (vsv_init_input_line_buffer(&(in_ctx->input_ctb_line_buf), options, enc_in, ctx->encoder, in_ctx)) {
+            av_log(NULL,
+                   AV_LOG_ERROR,
+                   "Fail to Init Input Line Buffer: virt_addr=%p, bus_addr=%08x\n",
+                   in_ctx->input_ctb_line_buf.sram,
+                   (uint32_t)(in_ctx->input_ctb_line_buf.sramBusAddr));
+            goto error;
+        }
+    }
+
+    /* before VCEncStrmStart called */
+    vsv_init_pic_config(enc_in);
+    /* Video, sequence and picture parameter sets */
+    for (p = 0; p < cnt; p++) {
+        if (VCEncStrmStart(ctx->encoder, enc_in, enc_out)) {
+            av_log(NULL, AV_LOG_ERROR, "VCEncStrmStart failed\n");
+            goto error;
+        }
+
+        ctx->total_bits += enc_out->streamSize * 8;
+        stream_size += enc_out->streamSize;
+    }
+
+    venc_get_extradata(avctx);
+
+    enc_in->poc = 0;
+
+    // default gop size as IPPP
+    // enc_in->gopSize = ctx->next_gop_size = (ctx->adaptive_gop ? (options->lookahead_depth ? 4 : 1) : gop_size);
+    av_log(NULL, AV_LOG_DEBUG, "%s %d pEncIn->gopSize = %d\n", __FILE__, __LINE__, enc_in->gopSize);
+
+    VCEncGetRateCtrl(ctx->encoder, (VCEncRateCtrl *)&ctx->rc);
+
+    /* Allocate a buffer for user data and read data from file */
+    ctx->p_user_data = ff_read_user_data(ctx->encoder, options->user_data);
+
+    in_ctx->valid_encoded_frame_number = 0;
+
+    return 0;
+
+error:
+    av_log(NULL, AV_LOG_ERROR, "%s error\n", __FUNCTION__);
+    return -1;
+}
+
+static int vsv_encode_got_mem_fd(const AVFrame *frame, int64_t *mem_fd) {
+    if (!frame) return -1;
+    if (!frame->nb_side_data) return -1;
+
+    AVFrameSideData *sd = NULL;
+    // mem fd
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_MEM_FRAME_FD);
+    if (sd) {
+        *mem_fd = *((int64_t *)sd->data);
+        av_log(NULL, AV_LOG_INFO, "got mem_fd: %lx\n", *mem_fd);
+        return 0;
+    }
+
+    return -1;
+}
+
+static int vsv_encode_encode(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *pict, int *stream_size) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidContext *options = ctx;
+    int32_t ret = OK;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+    VCEncIn *enc_in = (VCEncIn *)&(in_ctx->enc_in);
+    VCEncOut *enc_out = (VCEncOut *)&ctx->encOut;
+    uint32_t i, tmp;
+    int64_t mem_fd = 0;
+    unsigned long vir_addr = NULL;
+    int8_t share_fd_buf = 0;
+
+    av_log(avctx, AV_LOG_DEBUG, "%s in\n", __FUNCTION__);
+
+    if (!vsv_encode_got_mem_fd(pict, &mem_fd)) {
+        // get dma buffer virtual addr
+#ifdef SUPPORT_DMA_HEAP
+        EWLGetIovaByFd(in_ctx->ewl, mem_fd, &vir_addr);
+#else
+        vir_addr = mem_fd;
+#endif
+        // av_log(NULL, AV_LOG_WARNING, "dma_buf,mem_fd = 0x%lx, vir_addr = 0x%lx\n", mem_fd, vir_addr);
+        // set flag
+        share_fd_buf = 1;
+        in_ctx->share_fd_buf = share_fd_buf;
+    } else {
+        if (!in_ctx->picture_buffer_allocated) {
+            av_log(avctx, AV_LOG_INFO, "not hwaccel mode, alloc input picture buffers\n");
+            if (esenc_vid_alloc_input_picture_buffers(in_ctx)) {
+                return -1;
+            }
+            in_ctx->picture_buffer_allocated = 1;
+        }
+        /* input picture buffer */
+        ff_get_input_picture_buffer(in_ctx);
+        vir_addr = (unsigned long)in_ctx->picture_mem->busAddress;
+    }
+
+    // roi_qp_map buffer
+    ff_get_input_roi_qp_map_buffer(in_ctx);
+
+    // av_log(NULL, AV_LOG_WARNING, "vir_addr = 0x%lx, pict: %p\n", vir_addr, pict);
+    //  add mem_fd into fd-vpa list
+    av_log(avctx, AV_LOG_INFO, "received avframe, pts = %ld, pkt_dts = %ld\n", pict->pts, pict->pkt_dts);
+
+    MemInfo *mem_info = ff_alloc_and_fill_mem_info(mem_fd, vir_addr, pict);
+    ff_push_mem_info_into_queue(in_ctx, mem_info);
+
+    DtsInfo *dts_info = ff_alloc_and_fill_dts_info(pict->pkt_dts);
+    ff_push_dts_info_into_queue(in_ctx, dts_info);
+
+    ff_setup_slice_ctl(in_ctx);
+    ff_get_output_buffer(in_ctx, enc_in);
+
+    if (esenc_vid_fill_picture_buffer(avctx, pict, share_fd_buf, vir_addr) < 0) {
+        av_log(NULL, AV_LOG_ERROR, "esenc_vid_fill_picture_buffer fail\n");
+        return -1;
+    }
+
+    ctx->frame_cnt_total++;
+    enc_in->bIsIDR = options->force_IDR;
+    enc_in->sendAUD = options->insert_AUD;
+
+    if (in_ctx->picture_enc_cnt && options->insert_SPS_PPS) {
+        enc_in->resendSPS = enc_in->resendPPS = 0;
+        if (enc_in->bIsIDR) {
+            enc_in->resendSPS = enc_in->resendPPS = options->insert_SPS_PPS;
+            in_ctx->last_idr_picture_cnt = in_ctx->picture_enc_cnt;
+        } else if (in_ctx->idr_interval) {
+            u8 resend = ((in_ctx->picture_enc_cnt - in_ctx->last_idr_picture_cnt) % in_ctx->idr_interval) == 0;
+            enc_in->resendSPS = enc_in->resendPPS = resend;
+        }
+    }
+
+    // av_log(NULL, AV_LOG_INFO, "=== Encoding frame%i...\n", in_ctx->picture_enc_cnt);
+
+    /* 4. SetupROI-Map */
+    ff_fill_roi_qp_map_buffer(in_ctx, options, enc_in, ctx->encoder);
+
+    /* 5. encoding specific frame from user: all CU/MB are SKIP*/
+    enc_in->bSkipFrame = options->skip_frame_enabled_flag && (enc_in->poc == options->skip_frame_poc);
+
+    /* 6. low latency */
+    if (options->input_line_buf_mode) {
+        enc_in->lineBufWrCnt = VCEncStartInputLineBuffer(&(in_ctx->input_ctb_line_buf), 1);
+
+        if (in_ctx->input_ctb_line_buf.loopBackEn && in_ctx->input_ctb_line_buf.lumBuf.buf) {
+            VCEncPreProcessingCfg preProcCfg;
+//[fpga] when loop-back enable, inputCtbLineBuf is used by api, orignal frame buffer is not used inside api.
+#if 0
+            i32 inputPicBufIndex = FindInputPicBufIdByBusAddr(tb, enc_in->busLuma, options->formatCustomizedType!=-1);
+            if (NOK == ReturnBufferById(tb->inputMemFlags, tb->buffer_cnt, inputPicBufIndex) )
+            return NOK;
+#endif
+            enc_in->busLuma = in_ctx->input_ctb_line_buf.lumBuf.busAddress;
+            enc_in->busChromaU = in_ctx->input_ctb_line_buf.cbBuf.busAddress;
+            enc_in->busChromaV = in_ctx->input_ctb_line_buf.crBuf.busAddress;
+
+            /* In loop back mode, data in line buffer start from the line to be encoded*/
+            VCEncGetPreProcessing(ctx->encoder, &preProcCfg);
+            preProcCfg.yOffset = 0;
+            VCEncSetPreProcessing(ctx->encoder, &preProcCfg);
+        }
+
+        in_ctx->input_ctb_line_buf.lumSrc = in_ctx->lum;
+        in_ctx->input_ctb_line_buf.cbSrc = in_ctx->cb;
+        in_ctx->input_ctb_line_buf.crSrc = in_ctx->cr;
+        in_ctx->input_ctb_line_buf.wrCnt = 0;
+        enc_in->lineBufWrCnt = VCEncStartInputLineBuffer(&(in_ctx->input_ctb_line_buf), HANTRO_TRUE);
+        enc_in->initSegNum = in_ctx->input_ctb_line_buf.initSegNum;
+    }
+
+reenc:
+    ret = VCEncStrmEncode(ctx->encoder, enc_in, enc_out, &vsv_slice_ready, in_ctx->slice_ctl);
+    switch (ret) {
+        case VCENC_FRAME_ENQUEUE:
+            in_ctx->picture_enc_cnt++;
+            enc_in->picture_cnt++;
+            enc_in->timeIncrement = in_ctx->output_rate_denom;
+            break;
+        case VCENC_FRAME_READY:
+            if (enc_out->codingType != VCENC_NOTCODED_FRAME) {
+                in_ctx->picture_enc_cnt++;
+                if (enc_out->streamSize == 0) {
+                    in_ctx->picture_encoded_cnt++;
+                }
+            }
+
+            if (enc_out->streamSize == 0) {
+                enc_in->picture_cnt++;
+                break;
+            }
+
+            if (options->input_line_buf_mode) VCEncUpdateInitSegNum(&(in_ctx->input_ctb_line_buf));
+
+            vsv_process_frame(avctx, avpkt, stream_size);
+            enc_in->picture_cnt++;
+            if (enc_out->codingType != VCENC_NOTCODED_FRAME) {
+                in_ctx->picture_encoded_cnt++;
+            }
+
+            if (ctx->p_user_data) {
+                /* We want the user data to be written only once so
+                 * we disable the user data and free the memory after
+                 * first frame has been encoded. */
+                VCEncSetSeiUserData(ctx->encoder, NULL, 0);
+                free(ctx->p_user_data);
+                ctx->p_user_data = NULL;
+            }
+
+#ifdef DEBUG_CU_INFO
+            VCEncCuInfo cu_info;
+            if (VCEncGetCuInfo(ctx->encoder, &enc_out->cuOutData, 0, 0, &cu_info) != VCENC_OK) {
+                av_log(NULL, AV_LOG_ERROR, "VCEncGetCuInfo fail\n");
+            } else {
+                av_log(NULL,
+                       AV_LOG_INFO,
+                       "cuinfo, X=%d, Y=%d, cuSize=%d, cuMode=%d, qp=%d\n",
+                       cu_info.cuLocationX,
+                       cu_info.cuLocationY,
+                       cu_info.cuSize,
+                       cu_info.cuMode,
+                       cu_info.qp);
+            }
+#endif
+            break;
+        case VCENC_OUTPUT_BUFFER_OVERFLOW:
+            av_log(NULL, AV_LOG_WARNING, "VCEncStrmEncode ret = VCENC_OUTPUT_BUFFER_OVERFLOW\n");
+            enc_in->picture_cnt++;
+            esenc_vid_realloc_output_buffer(in_ctx);
+            ff_get_output_buffer(in_ctx, enc_in);
+            goto reenc;
+            break;
+        default:
+            av_log(NULL, AV_LOG_ERROR, "VCEncStrmEncode ret is %d\n", ret);
+            goto error;
+            break;
+    }
+
+    vsv_encode_release_input_buffer(ctx, enc_out, avpkt);
+
+    if (options->force_IDR) options->force_IDR = 0;
+
+    av_log(avctx,
+           AV_LOG_INFO,
+           "encoded done, nal_type = %d, size = %d, ret =  %d, pts = %ld, dts = %ld\n",
+           enc_out->codingType,
+           enc_out->streamSize,
+           ret,
+           avpkt->pts,
+           avpkt->dts);
+
+    return ret;
+error:
+    return -1;
+}
+
+static av_cold int vsv_encode_open(AVCodecContext *avctx) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidContext *options = ctx;
+    int32_t ret = OK;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+
+    if (ctx->encoder_is_open) return 0;
+
+    /* we set vce param according first decoded pic */
+    ret = vsv_encode_set_vceparam(avctx);
+    if (ret != 0) {
+        av_log(NULL, AV_LOG_ERROR, "vsv_encode_set_vceparam error.\n");
+        goto error_exit;
+    }
+
+    // av_log(avctx, AV_LOG_DEBUG, "+++ [ %s ]vsv_encode_get_options\n", __FUNCTION__);
+    // vsv_encode_get_options(avctx);
+    if ((ret = vsv_encode_open_encoder(options, (VCEncInst *)&ctx->encoder, in_ctx)) != 0) {
+        av_log(NULL, AV_LOG_ERROR, "OpenEncoder failed. ret is %d\n", ret);
+        goto error_exit;
+    }
+
+    ctx->picture_cnt_bk = 0;
+    in_ctx->output_rate_numer = options->output_rate_numer;
+    in_ctx->output_rate_denom = options->output_rate_denom;
+    in_ctx->width = options->width;
+    in_ctx->height = options->height;
+    in_ctx->input_alignment = (options->exp_of_input_alignment == 0 ? 0 : (1 << options->exp_of_input_alignment));
+    in_ctx->ref_alignment = (options->exp_of_ref_alignment == 0 ? 0 : (1 << options->exp_of_ref_alignment));
+    in_ctx->ref_ch_alignment = (options->exp_of_ref_ch_alignment == 0 ? 0 : (1 << options->exp_of_ref_ch_alignment));
+    in_ctx->format_customized_type = options->format_customized_type;
+    in_ctx->idr_interval = options->intra_pic_rate;
+    in_ctx->byte_stream = options->byte_stream;
+    in_ctx->interlaced_frame = options->interlaced_frame;
+    in_ctx->parallel_core_num = options->parallel_core_num;
+    in_ctx->buffer_cnt = VCEncGetEncodeMaxDelay(ctx->encoder) + 1;
+    in_ctx->frame_delay = in_ctx->parallel_core_num;
+    if (options->lookahead_depth) {
+        int32_t delay = CUTREE_BUFFER_CNT(options->lookahead_depth, MAX_GOP_SIZE) - 1;
+        in_ctx->frame_delay += MIN(delay, (int64_t)in_ctx->last_pic - in_ctx->first_pic + 1); /* lookahead depth */
+        /* consider gop8->gop4 reorder: 8 4 2 1 3 6 5 7 -> 4 2 1 3 8 6 5 7
+         * at least 4 more buffers are needed to avoid buffer overwrite in pass1 before consumed in pass2*/
+        in_ctx->buffer_cnt = in_ctx->frame_delay + 4;
+    }
+    av_log(NULL, AV_LOG_DEBUG, "alloc in_ctx->buffer_cnt: %d\n", in_ctx->buffer_cnt);
+    in_ctx->enc_in.gopConfig.idr_interval = in_ctx->idr_interval;
+    in_ctx->enc_in.gopConfig.firstPic = in_ctx->first_pic;
+    in_ctx->enc_in.gopConfig.lastPic = INT_MAX;
+    in_ctx->enc_in.gopConfig.outputRateNumer = in_ctx->output_rate_numer; /* Output frame rate numerator */
+    in_ctx->enc_in.gopConfig.outputRateDenom = in_ctx->output_rate_denom; /* Output frame rate denominator */
+    in_ctx->enc_in.gopConfig.inputRateNumer = in_ctx->enc_in.gopConfig.outputRateNumer; /* Input frame rate numerator */
+    in_ctx->enc_in.gopConfig.inputRateDenom =
+        in_ctx->enc_in.gopConfig.outputRateDenom; /* Input frame rate denominator */
+    in_ctx->enc_in.gopConfig.gopLowdelay = options->gop_lowdelay;
+    in_ctx->enc_in.gopConfig.interlacedFrame = in_ctx->interlaced_frame;
+
+    /* Set the test ID for internal testing,
+     * the SW must be compiled with testing flags */
+    VCEncSetTestId(ctx->encoder, options->test_id);
+
+    /* Allocate input and output buffers */
+    if ((ret = vsv_encode_alloc_res(options, ctx->encoder, in_ctx)) != 0) {
+        av_log(NULL, AV_LOG_ERROR, "vsv_encode_alloc_res failed.\n");
+        goto error_exit;
+    }
+
+    /* start the encoding thread */
+
+    ctx->encoder_is_open = 1;
+    return 0;
+
+error_exit:
+    if (ret != 0) {
+        av_log(NULL, AV_LOG_ERROR, "encode init fails, ret is %d\n", ret);
+    }
+
+    // Transcode_consume_flush(options->trans_handle, options->internal_enc_index);
+
+    if (ctx->encoder) {
+        vsv_encode_free_res(in_ctx);
+        vsv_encode_close_encoder(ctx->encoder, in_ctx);
+    }
+
+    return ret;
+}
+
+static int vsv_init_hwcontext(AVCodecContext *avctx) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    int nb_frames;
+
+    /* hw device & frame init */
+    if (avctx->hw_frames_ctx) {
+        AVHWFramesContext *hwframe;
+
+        hwframe = (AVHWFramesContext *)avctx->hw_frames_ctx->data;
+        ctx->hwdevice = (AVVSVDeviceContext *)((AVHWDeviceContext *)hwframe->device_ref->data)->hwctx;
+        if (!ctx->hwdevice) {
+            return AVERROR(ENOMEM);
+        }
+    } else if (avctx->hw_device_ctx) {
+        av_log(avctx, AV_LOG_TRACE, "%s(%d) avctx->hw_device_ctx = %p\n", __FUNCTION__, __LINE__, avctx->hw_device_ctx);
+        ctx->hwdevice = (AVVSVDeviceContext *)((AVHWDeviceContext *)avctx->hw_device_ctx->data)->hwctx;
+        av_log(avctx, AV_LOG_TRACE, "%s(%d) ctx->hwdevice = %p\n", __FUNCTION__, __LINE__, ctx->hwdevice);
+        if (!ctx->hwdevice) {
+            return AVERROR(ENOMEM);
+        }
+    } else {
+        return AVERROR(EINVAL);
+    }
+
+    if (ctx->lookahead_depth) {
+        ctx->hwdevice->lookahead = 1;
+        nb_frames = 17 + ctx->lookahead_depth;
+    } else {
+        nb_frames = 8 + 2;
+    }
+
+    if (ctx->hwdevice->nb_frames < nb_frames) {
+        ctx->hwdevice->nb_frames = nb_frames;
+    }
+
+    return 0;
+}
+
+av_cold int ff_vsv_h26x_encode_init(AVCodecContext *avctx) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidContext *options = ctx;
+    int32_t ret = OK;
+    VCEncApiVersion api_ver;
+    VCEncBuild encBuild;
+    int32_t useVcmd = -1;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+    uint32_t client_type;
+
+    av_log(avctx, AV_LOG_DEBUG, "%s in\n", __FUNCTION__);
+
+    /* If you add something that can fail above this av_frame_alloc(),
+     * modify ff_vsv_h26x_encode_close() accordingly. */
+    options->frame = av_frame_alloc();
+    if (!options->frame) {
+        return AVERROR(ENOMEM);
+    }
+
+    // api version
+    api_ver = VCEncGetApiVersion();
+    av_log(avctx, AV_LOG_INFO, "VC9000 Encoder API version %d.%d.%d\n", api_ver.major, api_ver.minor, api_ver.clnum);
+
+    // setting log output of SDK
+    log_env_setting env_log = {LOG_STDOUT, VCENC_LOG_WARN, 0x003F, 0x0001};
+    VCEncLogInit(env_log.out_dir, env_log.out_level, env_log.k_trace_map, env_log.k_check_map);
+
+    if (options->input_line_buf_mode) {
+        useVcmd = 0;
+    }
+
+    EWLAttach(NULL, 0, useVcmd);
+    ret = esenc_init(&ctx->tc, avctx, &ff_vsv_h26x_encode_encode2);
+    if (ret < 0) {
+        goto error_exit;
+    }
+
+    ret = vsv_encode_set_default_opt(avctx);
+    if (ret < 0) {
+        goto error_exit;
+    }
+
+    /* preset params set */
+    ret = vsv_preset_params_set(avctx);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "vsv_preset_params_set error, please check your cmd !\n");
+    }
+
+    vsv_encode_get_options(avctx);
+
+    // init packet dump handle
+    if (options->dump_pkt_enable && !options->dump_pkt_hnd) {
+        DumpParas paras;
+        paras.width = options->lum_width_src;
+        paras.height = options->lum_height_src;
+        paras.pic_stride = 0;
+        paras.pic_stride_ch = 0;
+        paras.prefix_name = "venc";
+        if (IS_H264(options->codec_format))
+            paras.suffix_name = "h264";
+        else
+            paras.suffix_name = "h265";
+        paras.fmt = NULL;
+        options->dump_pkt_hnd = ff_codec_dump_file_open(options->dump_path, options->dump_pkt_time, &paras);
+    }
+
+    if (options->dump_frame_enable && !options->dump_frame_hnd) {
+        DumpParas paras;
+        paras.width = options->width;
+        paras.height = options->height;
+        paras.pic_stride = 0;
+        paras.pic_stride_ch = 0;
+        paras.prefix_name = "venc";
+        paras.suffix_name = "yuv";
+        paras.fmt = ff_vsv_encode_get_fmt_char(avctx->pix_fmt);
+        options->dump_frame_hnd = ff_codec_dump_file_open(options->dump_path, options->dump_frame_time, &paras);
+    }
+
+#ifndef ESW_FF_ENHANCEMENT
+    ret = vsv_init_hwcontext(avctx);
+    if (ret < 0) {
+        av_log(NULL, AV_LOG_ERROR, "vsv_init_hwcontext failed.\n");
+        goto error_exit;
+    }
+
+#ifdef DRV_NEW_ARCH
+    options->priority = ctx->hwdevice->priority;
+    options->device = ctx->hwdevice->device;
+    options->mem_id = ctx->hwdevice->task_id;
+#endif
+#endif
+    memset(in_ctx, 0, sizeof(ESEncVidInternalContext));
+
+    // get roi map version
+    in_ctx->roi_map_version = VCEncGetRoiMapVersion(0, NULL);
+    av_log(NULL, AV_LOG_INFO, "roi map version: %d\n", in_ctx->roi_map_version);
+
+    client_type = IS_H264(options->codec_format) ? EWL_CLIENT_TYPE_H264_ENC : EWL_CLIENT_TYPE_HEVC_ENC;
+    encBuild = VCEncGetBuild(client_type);
+    av_log(avctx,
+           AV_LOG_INFO,
+           "HW ID:  0x%08x\t SW Build: %u.%u.%u\n",
+           encBuild.hwBuild,
+           encBuild.swBuild / 1000000,
+           (encBuild.swBuild / 1000) % 1000,
+           encBuild.swBuild % 1000);
+
+    // mem_fd_vpa queue
+    in_ctx->in_mem_queue = es_queue_create();
+    pthread_mutex_init(&in_ctx->in_mem_queue_mutex, NULL);
+
+    // dts queue
+    in_ctx->dts_queue = es_queue_create();
+    pthread_mutex_init(&in_ctx->dts_queue_mutex, NULL);
+
+#ifdef FB_SYSLOG_ENABLE
+    if (avctx->codec->id == AV_CODEC_ID_HEVC) {
+        sprintf(&ctx->module_name[0], "%s", "HEVCENC");
+    } else if (avctx->codec->id == AV_CODEC_ID_H264) {
+        sprintf(&ctx->module_name[0], "%s", "H264ENC");
+    }
+    in_ctx->log_header.module_name = &ctx->module_name[0];
+#ifdef DRV_NEW_ARCH
+    in_ctx->log_header.device_id = get_deviceId(options->device);
+#else
+    in_ctx->log_header.device_id = 0;
+#endif
+#endif
+
+    /* the number of output stream buffers */
+    in_ctx->stream_buf_num = options->stream_buf_chain ? 2 : 1;
+    in_ctx->compress_rate = 10;
+
+    /* get GOP configuration */
+    in_ctx->gop_size = MIN(options->gop_size, MAX_GOP_SIZE);
+    if (in_ctx->gop_size == 0 && options->gop_lowdelay) {
+        in_ctx->gop_size = 4;
+    }
+    memset(ctx->gop_pic_cfg, 0, sizeof(ctx->gop_pic_cfg));
+    in_ctx->enc_in.gopConfig.pGopPicCfg = ctx->gop_pic_cfg;
+    memset(ctx->gop_pic_special_cfg, 0, sizeof(ctx->gop_pic_special_cfg));
+    in_ctx->enc_in.gopConfig.pGopPicSpecialCfg = ctx->gop_pic_special_cfg;
+    if ((ret = ff_init_gop_configs(
+             in_ctx->gop_size, options, &(in_ctx->enc_in.gopConfig), in_ctx->enc_in.gopConfig.gopCfgOffset, 0, 0))
+        != 0) {
+        av_log(NULL, AV_LOG_ERROR, "init_gop_configs failed.\n");
+        goto error_exit;
+    }
+    if (options->lookahead_depth) {
+        memset(ctx->gop_pic_cfg_pass2, 0, sizeof(ctx->gop_pic_cfg_pass2));
+        in_ctx->enc_in.gopConfig.pGopPicCfg = ctx->gop_pic_cfg_pass2;
+        in_ctx->enc_in.gopConfig.size = 0;
+        memset(ctx->gop_pic_special_cfg, 0, sizeof(ctx->gop_pic_special_cfg));
+        in_ctx->enc_in.gopConfig.pGopPicSpecialCfg = ctx->gop_pic_special_cfg;
+        if ((ret = ff_init_gop_configs(
+                 in_ctx->gop_size, options, &(in_ctx->enc_in.gopConfig), in_ctx->enc_in.gopConfig.gopCfgOffset, 1, 0))
+            != 0) {
+            av_log(NULL, AV_LOG_ERROR, "init_gop_configs 2pass failed.\n");
+            goto error_exit;
+        }
+        in_ctx->enc_in.gopConfig.pGopPicCfgPass1 = ctx->gop_pic_cfg;
+        in_ctx->enc_in.gopConfig.pGopPicCfg = in_ctx->enc_in.gopConfig.pGopPicCfgPass2 = ctx->gop_pic_cfg_pass2;
+    }
+
+    ctx->output_pkt_queue = av_fifo_alloc(MAX_FIFO_DEPTH * sizeof(AVPacket));
+    if (!ctx->output_pkt_queue) return AVERROR(ENOMEM);
+
+    ctx->encoder_is_open = 0;
+    ctx->encoder_is_start = 0;
+    ctx->encoder_is_end = 0;
+
+    ret = vsv_encode_open(avctx);
+    if (ret != 0) {
+        av_log(NULL, AV_LOG_ERROR, "vsv_encode_open error. ret = %d\n", ret);
+        goto error_exit;
+    }
+
+    ret = vsv_encode_start(avctx);
+    if (ret != 0) {
+        av_log(NULL, AV_LOG_ERROR, "ff_vsv_encode_start error. ret = %d\n", ret);
+        goto error_exit;
+    }
+    ctx->encoder_is_start = 1;
+    av_log(avctx, AV_LOG_DEBUG, "%s, ret = 0, out\n", __FUNCTION__);
+    return 0;
+
+error_exit:
+    ff_vsv_h26x_encode_close(avctx);
+    av_log(avctx, AV_LOG_DEBUG, "%s, ret = %d, out\n", __FUNCTION__, ret);
+    return ret;
+}
+
+av_cold int ff_vsv_h26x_encode_close(AVCodecContext *avctx) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    ESEncVidInternalContext *in_ctx = (ESEncVidInternalContext *)&ctx->in_ctx;
+
+    av_log(avctx, AV_LOG_DEBUG, "%s in\n", __FUNCTION__);
+
+    /* We check ctx->frame to know whether encode_init()
+     * has been called and va_config/va_context initialized. */
+    if (!ctx->frame) return 0;
+
+    if (ctx->dump_frame_hnd) ff_codec_dump_file_close(&ctx->dump_frame_hnd);
+    if (ctx->dump_pkt_hnd) ff_codec_dump_file_close(&ctx->dump_pkt_hnd);
+
+    esenc_close(ctx->tc);
+
+    vsv_encode_report(avctx);
+
+    if (ctx->encoder && in_ctx->ewl) {
+        vsv_encode_free_res(in_ctx);
+        vsv_encode_close_encoder(ctx->encoder, in_ctx);
+    }
+
+    if (in_ctx->cu_map_buf) {
+        free(in_ctx->cu_map_buf);
+        in_ctx->cu_map_buf = NULL;
+        in_ctx->cu_map_buf_len = 0;
+    }
+
+    av_fifo_freep(&ctx->output_pkt_queue);
+
+    av_frame_free(&ctx->frame);
+
+    // clean mem_info and dts queue
+    ff_clean_mem_info_queue(in_ctx);
+    ff_clean_dts_queue(in_ctx);
+    es_queue_destroy(in_ctx->in_mem_queue);
+    es_queue_destroy(in_ctx->dts_queue);
+    pthread_mutex_destroy(&in_ctx->dts_queue_mutex);
+    pthread_mutex_destroy(&in_ctx->dts_queue_mutex);
+
+    if (avctx->extradata) av_freep(&avctx->extradata);
+    av_log(avctx, AV_LOG_DEBUG, "%s out\n", __FUNCTION__);
+    return 0;
+}
+
+int ff_vsv_h26x_encode_send_frame(AVCodecContext *avctx, const AVFrame *frame) {
+    int ret = 0;
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    av_log(avctx, AV_LOG_DEBUG, "%s,frame = %p in\n", __FUNCTION__, frame);
+    ret = esenc_send_frame(ctx->tc, frame);
+    av_log(avctx, AV_LOG_DEBUG, "%s out\n", __FUNCTION__);
+    return ret;
+}
+
+int ff_vsv_h26x_encode_receive_packet(AVCodecContext *avctx, AVPacket *avpkt) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+    AVFrame *frame = ctx->frame;
+    int err;
+
+    err = ff_encode_get_frame(avctx, frame);
+    if (err < 0 && err != AVERROR_EOF) {
+        return err;
+    }
+
+    if (err == AVERROR_EOF) {
+        av_log(avctx, AV_LOG_INFO, "send NULL frame ,eos frame\n", err);
+        frame = NULL;
+    }
+
+    err = esenc_send_frame(ctx->tc, frame);
+    if (err != 0) {
+        av_log(avctx, AV_LOG_ERROR, "esenc_send_frame failed res=:%d\n", err);
+        return err;
+    }
+    return esenc_receive_packet(ctx->tc, avpkt);
+}
+
+// convert cu map to ctu table
+// for example, sdk just receive 8x8 block
+// if block unit = 64x64, we need convert every 64x64 to 8*(sdk 8x8 block),
+// every (sdk 8x8 block) has the same value
+static int vsv_h26x_encode_convert_cu_map_to_ctu_table(
+    ESEncVidContext *option, char *buf, int src_qp_delta, int src_seq, int blk_row, int blk_colum) {
+    if (!option || !buf) return -1;
+
+    int w = STRIDE_BY_ALIGN(option->width, option->max_cu_size) / 8;
+    int h = STRIDE_BY_ALIGN(option->height, option->max_cu_size) / 8;
+    int iw = 0, ih = 0;
+    int start_x = 0, start_y = 0;
+    int end_x = 0, end_y = 0;
+    int x = 0, y = 0;
+    int w_stride = w % blk_row + w;
+
+    start_x = src_seq * blk_row % w_stride;
+    start_y = src_seq * blk_row / w_stride * blk_colum;
+
+    for (ih = 0; ih < blk_colum; ih++) {
+        for (iw = 0; iw < blk_colum; iw++) {
+            x = start_x + iw;
+            y = start_y + ih;
+
+            if (x < w && y < h) {
+                buf[y * w + x] = src_qp_delta;
+                // av_log(NULL, AV_LOG_DEBUG, "array[%d][%d]= %d, 0x%x\n", y, x, src_qp_delta, src_qp_delta);
+            }
+        }
+    }
+
+    return 0;
+}
+
+static void vsv_h26x_encode_print_ctu(int w, int h, char *buf) {
+    for (int x = 0; x < h * w; x++) {
+        printf("%3d", buf[x]);
+        if ((x + 1) % w == 0) printf("\n");
+    }
+}
+
+static int vsv_h26x_encode_control_dynamic(AVCodecContext *avctx, const AVFrame *frame) {
+    if (!avctx) return -1;
+    if (!frame) return 0;
+    if (!frame->nb_side_data) return 0;
+
+    ESEncVidContext *option = (ESEncVidContext *)avctx->priv_data;
+    if (!option) return -1;
+
+    AVFrameSideData *sd = NULL;
+    SideDataSliceSize *sd_slice_size = NULL;
+    SideDataForeceIdr *sd_force_idr = NULL;
+    SideDataInsertSpsPps *sd_insert_sps_pps = NULL;
+    SideDataRc *sd_rc = NULL;
+    int call_coding_ctl = 0;
+    VCEncCodingCtrl coding_cfg;
+
+    // roi area
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_ROI_AREA);
+    if (sd) {
+        int roi_size = sizeof(RoiAttr);
+        RoiAttr *roi = NULL;
+        int nb_rois = sd->size / roi_size;
+
+        av_log(NULL, AV_LOG_INFO, "received sd, nb_rois: %d\n", nb_rois);
+
+        if (nb_rois) {
+            memset(&option->roi_tbl, 0x00, sizeof(option->roi_tbl));
+        }
+
+        for (int i = 0; i < nb_rois; i++) {
+            roi = (RoiAttr *)(sd->data + roi_size * i);
+            memcpy(&option->roi_tbl.roi_attr[i], roi, roi_size);
+            option->roi_tbl.num_of_roi++;
+        }
+        call_coding_ctl = 1;
+    }
+
+    // cu map
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_CU_MAP);
+    if (sd) {
+        int cu_size = sizeof(SideDataCuMap);
+        int nb_cu = sd->size / cu_size;
+        SideDataCuMap *cu_map = NULL;
+        int buf_allocated = 0;
+        int blk_row_num = 0;
+        int blk_colum_num = 0;
+        int32_t blk_size_w = 0;
+        int32_t blk_size_h = 0;
+        int32_t insert_blk_cnt = 0;
+        int32_t w_align_ctu = STRIDE_BY_ALIGN(option->width, option->max_cu_size);
+        int32_t h_align_ctu = STRIDE_BY_ALIGN(option->height, option->max_cu_size);
+
+        av_log(NULL, AV_LOG_INFO, "received sd, cu count: %d\n", nb_cu);
+
+        for (int i = 0; i < nb_cu; i++) {
+            int qp_delta = 0;
+            cu_map = (SideDataCuMap *)(sd->data + cu_size * i);
+            qp_delta = cu_map->qp_value;
+            if (cu_map->skip) qp_delta |= 0x80;
+            if (!cu_map->is_abs_qp) qp_delta |= 0x40;
+
+            if (!buf_allocated) {
+                // caculate size
+                if (cu_map->blk_unit == CU_BLK_64x64) {
+                    blk_size_w = 64;
+                    blk_size_h = 64;
+                } else if (cu_map->blk_unit == CU_BLK_32x32) {
+                    blk_size_w = 32;
+                    blk_size_h = 32;
+                } else if (cu_map->blk_unit == CU_BLK_16x16) {
+                    blk_size_w = 16;
+                    blk_size_h = 16;
+                } else if (cu_map->blk_unit == CU_BLK_8x8) {
+                    blk_size_w = 8;
+                    blk_size_h = 8;
+                } else {
+                    av_log(NULL, AV_LOG_ERROR, "not support cu map blk_unit: %d\n", cu_map->blk_unit);
+                }
+
+                blk_row_num = blk_size_w / 8;
+                blk_colum_num = blk_size_h / 8;
+
+                option->in_ctx.cu_map_buf_len = w_align_ctu * h_align_ctu / 64;  // 64 = 8*8
+                option->in_ctx.cu_map_buf = calloc(1, option->in_ctx.cu_map_buf_len);
+                buf_allocated = 1;
+                av_log(NULL, AV_LOG_DEBUG, "cu_map_buf_len %d\n", option->in_ctx.cu_map_buf_len);
+            }
+
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "cu[%d]: blk_unit=%d, skip=%d, is_abs=%d, qp=%d\n",
+                   i,
+                   cu_map->blk_unit,
+                   cu_map->skip,
+                   cu_map->is_abs_qp,
+                   cu_map->qp_value);
+            // av_log(NULL, AV_LOG_DEBUG, "cu[%d]: %x, %d\n", i, qp_delta, qp_delta);
+
+            vsv_h26x_encode_convert_cu_map_to_ctu_table(
+                option, option->in_ctx.cu_map_buf, qp_delta, i + insert_blk_cnt, blk_row_num, blk_colum_num);
+
+            // where to insert the last cu
+            int32_t user_w = STRIDE_BY_ALIGN(option->width, blk_size_w);
+            int32_t user_h = STRIDE_BY_ALIGN(option->height, blk_size_h);
+            int32_t insert_start = user_w / blk_size_w;
+            int32_t insert_cnt = (w_align_ctu - user_w) / blk_size_w;
+
+            for (int id = 0; id < insert_cnt; id++) {
+                insert_blk_cnt++;
+                vsv_h26x_encode_convert_cu_map_to_ctu_table(
+                    option, option->in_ctx.cu_map_buf, qp_delta, i + insert_blk_cnt, blk_row_num, blk_colum_num);
+            }
+        }
+
+        // vsv_h26x_encode_print_ctu(w_align_ctu / 8,
+        //                           h_align_ctu / 8,
+        //                           option->in_ctx.cu_map_buf);
+    }
+
+    // got slice size from side data
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_SLICE_SIZE);
+    if (sd) {
+        sd_slice_size = (SideDataSliceSize *)sd->data;
+        av_log(NULL, AV_LOG_INFO, "received sd, slice_size = %d\n", sd_slice_size->slice_size);
+    }
+
+    // got force idr from side data
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_FORCE_IDR);
+    if (sd) {
+        sd_force_idr = (SideDataForeceIdr *)sd->data;
+        av_log(NULL, AV_LOG_INFO, "received sd, force_idr = %d\n", sd_force_idr->force_idr);
+    }
+
+    // got slice size from side data
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_INSERT_SPS_PPS);
+    if (sd) {
+        sd_insert_sps_pps = (SideDataInsertSpsPps *)sd->data;
+        av_log(NULL, AV_LOG_INFO, "received sd, insert_sps_pps = %d\n", sd_insert_sps_pps->insert_sps_pps);
+    }
+
+    // got slice size from side data
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_RC);
+    if (sd) {
+        sd_rc = (SideDataRc *)sd->data;
+        av_log(NULL,
+               AV_LOG_INFO,
+               "received sd, rc_mode=%d, rc_window=%d, bitrate=%d, min_qp=%d, max_qp=%d, "
+               "fixed_qp_i=%d,fixed_qp_p=%d, fixed_qp_b=%d\n",
+               sd_rc->rc_mode,
+               sd_rc->rc_window,
+               sd_rc->bitrate,
+               sd_rc->min_qp,
+               sd_rc->max_qp,
+               sd_rc->fixed_qp_i,
+               sd_rc->fixed_qp_p,
+               sd_rc->fixed_qp_b);
+    }
+
+    if (sd_force_idr) {
+        option->force_IDR = sd_force_idr->force_idr;
+    }
+
+    if (sd_insert_sps_pps) {
+        option->insert_SPS_PPS = sd_insert_sps_pps->insert_sps_pps;
+    }
+
+    if (sd_slice_size) {
+        option->slice_size = sd_slice_size->slice_size;
+        call_coding_ctl = 1;
+    }
+
+    // call VCEncSetCodingCtrl once to set all relative parameters
+    if (call_coding_ctl) {
+        if (VCEncGetCodingCtrl(option->encoder, &coding_cfg) != VCENC_OK) {
+            av_log(NULL, AV_LOG_ERROR, "set slice_size, VCEncGetCodingCtrl fail\n");
+            return -1;
+        } else {
+            // slice size changed
+            if (coding_cfg.sliceSize != option->slice_size) {
+                av_log(NULL, AV_LOG_INFO, "slice_size, %d---->%d\n", coding_cfg.sliceSize, option->slice_size);
+                // slice size
+                coding_cfg.sliceSize = option->slice_size;
+            }
+            // roi
+            vsv_encode_config_roi_areas(option, &coding_cfg);
+
+            VCEncStrmEnd(option->encoder, &option->in_ctx.enc_in, &option->encOut);
+            if (VCEncSetCodingCtrl(option->encoder, &coding_cfg) != VCENC_OK) {
+                av_log(NULL, AV_LOG_ERROR, "dynamic control, VCEncSetCodingCtrl fail\n");
+                return -1;
+            }
+
+            struct VSVInternalContext *in_ctx = (struct VSVInternalContext *)&option->in_ctx;
+            ff_get_output_buffer(in_ctx, &option->in_ctx.enc_in);
+            VCEncStrmStart(option->encoder, &option->in_ctx.enc_in, &option->encOut);
+
+            venc_get_extradata(avctx);
+
+            call_coding_ctl = 0;
+        }
+
+        av_log(NULL, AV_LOG_INFO, "call VCEncSetCodingCtrl OK\n");
+    }
+
+    if (sd_rc) {
+        option->rc_mode = sd_rc->rc_mode;
+        option->bitrate_window = sd_rc->rc_window;
+        option->bit_per_second = sd_rc->bitrate;
+        option->qp_min = sd_rc->min_qp;
+        option->qp_max = sd_rc->max_qp;
+        option->fixed_qp_I = sd_rc->fixed_qp_i;
+        option->fixed_qp_P = sd_rc->fixed_qp_p;
+        option->fixed_qp_B = sd_rc->fixed_qp_b;
+
+        VCEncRateCtrl rc_cfg;
+        if (VCEncGetRateCtrl(option->encoder, &rc_cfg) != VCENC_OK) {
+            av_log(NULL, AV_LOG_ERROR, "set rc, VCEncGetRateCtrl fail\n");
+            return -1;
+        } else {
+            av_log(NULL, AV_LOG_INFO, "rc mode, %d---->%d\n", rc_cfg.rcMode, option->rc_mode);
+            // RC setting
+            rc_cfg.rcMode = option->rc_mode;
+            switch (rc_cfg.rcMode) {
+                case VCE_RC_CVBR:
+                    rc_cfg.bitrateWindow = option->bitrate_window;
+                    rc_cfg.qpMinI = rc_cfg.qpMinPB = option->qp_min;
+                    rc_cfg.qpMaxI = rc_cfg.qpMaxPB = option->qp_max;
+                    if (option->bit_per_second != DEFAULT) {
+                        rc_cfg.bitPerSecond = option->bit_per_second;
+                    }
+                    break;
+                case VCE_RC_CBR:
+                    rc_cfg.bitrateWindow = option->bitrate_window;
+                    if (option->bit_per_second != DEFAULT) {
+                        rc_cfg.bitPerSecond = option->bit_per_second;
+                    }
+                    rc_cfg.hrdCpbSize = 2 * rc_cfg.bitPerSecond;
+                    break;
+                case VCE_RC_VBR:
+                    rc_cfg.bitrateWindow = option->bitrate_window;
+                    rc_cfg.qpMinI = rc_cfg.qpMinPB = option->qp_min;
+                    if (option->bit_per_second != DEFAULT) {
+                        rc_cfg.bitPerSecond = option->bit_per_second;
+                    }
+                    break;
+                case VCE_RC_ABR:
+                    if (option->bit_per_second != DEFAULT) {
+                        rc_cfg.bitPerSecond = option->bit_per_second;
+                    }
+                    break;
+                case VCE_RC_CQP:
+                    rc_cfg.fixedIntraQp = option->fixed_qp_I;
+                    // fixing, how to set B/P
+                    // rc_cfg.fixedIntraQp = option->fixed_qp_P;
+                    // rc_cfg.fixedIntraQp = option->fixed_qp_B;
+                    break;
+                default:
+                    av_log(NULL, AV_LOG_WARNING, "This version is not support CRF\n");
+                    return -1;
+            }
+
+            // VCEncStrmEnd(option->encoder, &option->in_ctx.enc_in, &option->encOut);
+            if (VCEncSetRateCtrl(option->encoder, &rc_cfg) != VCENC_OK) {
+                av_log(NULL, AV_LOG_ERROR, "set slice_size, VCEncSetRateCtrl fail\n");
+                return -1;
+            }
+            // VCEncStrmStart(option->encoder, &option->in_ctx.enc_in, &option->encOut);
+
+            av_log(NULL, AV_LOG_INFO, "set rc, VCEncGetRateCtrl OK\n");
+        }
+    }
+
+    return 0;
+}
+
+int ff_vsv_h26x_encode_encode2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet) {
+    ESEncVidContext *ctx = (ESEncVidContext *)avctx->priv_data;
+
+    int ret = 0;
+    int flush_ret = 0;
+    int stream_size = 0;
+
+    *got_packet = 0;
+
+    if (frame == NULL) {
+        ret = vsv_encode_flush(avctx, avpkt, &stream_size);
+        // for encoding error or flush end, end encoder
+        if (ret <= 0) {
+            ret = vsv_encode_end(avctx, avpkt, &stream_size, 0);
+            ctx->encoder_is_end = 1;
+            ret = AVERROR_EOF;
+        } else {
+            // send a NULL frame to myself for continuing call flush to get cache data with encoder
+            ff_vsv_h26x_encode_send_frame(avctx, NULL);
+        }
+    } else {
+        vsv_h26x_encode_control_dynamic(avctx, frame);
+        if ((ctx->profile == VCENC_HEVC_MAIN_STILL_PICTURE_PROFILE) && (ctx->in_ctx.picture_enc_cnt >= 1)) {
+            return AVERROR_EOF;
+        }
+
+        ret = vsv_encode_encode(avctx, avpkt, frame, &stream_size);
+    }
+
+    if (stream_size) *got_packet = 1;
+
+    return ret;
+}
diff --git a/libavcodec/esenc_vid.h b/libavcodec/esenc_vid.h
new file mode 100644
index 0000000000..c3e9f304e8
--- /dev/null
+++ b/libavcodec/esenc_vid.h
@@ -0,0 +1,688 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ESENC_VIDEO_H
+#define AVCODEC_ESENC_VIDEO_H
+
+#include <stdio.h>
+
+#ifndef ESW_FF_ENHANCEMENT
+#include "dectypes.h"
+#endif
+
+#include "instance.h"
+#include "hevcencapi.h"
+#include "enccommon.h"
+#include "es_common.h"
+#ifdef SUPPORT_TCACHE
+#include "dtrc_api.h"
+#endif
+#include "libavutil/fifo.h"
+#include "libavutil/timestamp.h"
+#include "hevcencapi.h"
+#include "enccommon.h"
+#include "ewl.h"
+#include "encinputlinebuffer.h"
+#include "esqueue.h"
+#include "esenc_common.h"
+
+#ifndef NEXT_MULTIPLE
+#define NEXT_MULTIPLE(value, n) (((value) + (n)-1) & ~((n)-1))
+#endif
+
+#define DEFAULT -255
+#define MAX_BPS_ADJUST 20
+#define MAX_STREAMS 16
+#define MAX_SCENE_CHANGE 20
+
+#define DEFAULT_VALUE -255
+
+#define MAX_FIFO_DEPTH 16
+#define MAX_WAIT_DEPTH 78  // 34
+#define MAX_ENC_NUM 4
+#define MAX_GOP_LEN 300
+
+#define DEFAULT_VALUE -255
+
+// roi region number
+#define MAX_ROI_NUM (8)
+
+// ipcm number
+#define MAX_IPCM_NUM (2)
+
+#define RESOLUTION_TO_CTB(var, ctu) ((var) / (ctu))
+
+#define STRIDE_BY_ALIGN(var, ctu) (((var) + (ctu)-1) & ~((ctu)-1))
+
+#ifndef MAX_GOP_SIZE
+#define MAX_GOP_SIZE 8
+#endif
+#ifndef MAX_DELAY_NUM
+#define MAX_DELAY_NUM (MAX_CORE_NUM + MAX_GOP_SIZE)
+#endif
+
+#ifndef MOVING_AVERAGE_FRAMES
+#define MOVING_AVERAGE_FRAMES 120
+#endif
+
+typedef struct {
+    uint32_t stream_pos;
+    uint32_t multislice_encoding;
+    uint32_t output_byte_stream;
+    FILE *out_stream_file;
+} SliceCtl;
+
+typedef struct {
+    uint32_t stream_rd_counter;
+    uint32_t stream_multi_seg_en;
+    uint8_t *stream_base;
+    uint32_t segment_size;
+    uint32_t segment_amount;
+    FILE *out_stream_file;
+    uint8_t start_code_done;
+    int32_t output_byte_stream;
+} SegmentCtl;
+
+typedef struct {
+    int32_t frame[MOVING_AVERAGE_FRAMES];
+    int32_t length;
+    int32_t count;
+    int32_t pos;
+    int32_t frame_rate_numer;
+    int32_t frame_rate_denom;
+} Ma;
+
+typedef struct {
+    int gop_frm_num;
+    double sum_intra_vs_interskip;
+    double sum_skip_vs_interskip;
+    double sum_intra_vs_interskipP;
+    double sum_intra_vs_interskipB;
+    int sum_costP;
+    int sum_costB;
+    int last_gop_size;
+} AdapGopCtr;
+
+typedef struct {
+#ifdef FB_SYSLOG_ENABLE
+    LOG_INFO_HEADER log_header;
+#endif
+    FILE *out;
+    int32_t width;
+    int32_t height;
+    int32_t output_rate_numer; /* Output frame rate numerator */
+    int32_t output_rate_denom; /* Output frame rate denominator */
+    int32_t first_pic;
+    int32_t last_pic;
+    int32_t input_pic_cnt;
+    int32_t picture_enc_cnt;      // count that had send to encoder api
+    int32_t picture_encoded_cnt;  // count that encoder had encoded frame
+    int32_t idr_interval;
+    int32_t last_idr_picture_cnt;
+    int32_t byte_stream;
+    uint8_t *lum;
+    uint8_t *cb;
+    uint8_t *cr;
+    uint32_t src_img_size_ds;
+    int32_t interlaced_frame;
+    uint32_t valid_encoded_frame_number;
+    uint32_t input_alignment;
+    uint32_t ref_alignment;
+    uint32_t ref_ch_alignment;
+    int32_t format_customized_type;
+    uint32_t transformed_size;
+    uint32_t luma_size_lookahead;
+    uint32_t chroma_size_lookahead;
+
+    /* SW/HW shared memories for input/output buffers */
+    EWLLinearMem_t *picture_mem;
+    EWLLinearMem_t *outbuf_mem[MAX_STRM_BUF_NUM];
+    EWLLinearMem_t *roi_map_delta_qp_mem;
+
+    EWLLinearMem_t picture_mem_factory[MAX_DELAY_NUM];
+    uint8_t picture_mem_status[MAX_DELAY_NUM];  // maintain the status of picture_mem_factory buffer list, 0: can reuse,
+                                                // 1: using by encoder
+    EWLLinearMem_t outbuf_mem_factory[MAX_CORE_NUM][MAX_STRM_BUF_NUM]; /* [coreIdx][bufIdx] */
+    EWLLinearMem_t roi_map_delta_qp_mem_factory[MAX_DELAY_NUM];
+    uint8_t roi_qp_map_mem_status[MAX_DELAY_NUM];
+
+    float sum_square_of_error;
+    float average_square_of_error;
+    int32_t max_error_over_target;
+    int32_t max_error_under_target;
+    long number_square_of_error;
+
+    uint32_t gop_size;
+    int32_t next_gop_size;
+    VCEncIn enc_in;
+
+    inputLineBufferCfg input_ctb_line_buf;
+
+    uint32_t parallel_core_num;
+    SliceCtl slice_ctl_factory[MAX_DELAY_NUM];
+    SliceCtl *slice_ctl;
+    SliceCtl *slice_ctl_out;
+
+    const void *ewl;
+    const void *two_pass_ewl;
+
+    int enc_index;
+    double ssim_acc;
+    long long hwcycle_acc;
+
+#if defined(SUPPORT_DEC400) || defined(SUPPORT_TCACHE)
+    uint32_t tbl_luma_size;
+    uint32_t tbl_chroma_size;
+#endif
+#ifdef DRV_NEW_ARCH
+    int priority;
+    char *device;
+    int mem_id;
+#endif
+    int32_t stream_buf_num;
+    uint32_t frame_delay;
+    uint32_t buffer_cnt;
+    SegmentCtl stream_seg_ctl;
+    uint32_t roi_map_version;
+    char *cu_map_buf;
+    u_int32_t cu_map_buf_len;
+    ESQueue *in_mem_queue;
+    pthread_mutex_t in_mem_queue_mutex;
+    int8_t share_fd_buf;
+    ESQueue *dts_queue;
+    pthread_mutex_t dts_queue_mutex;
+    int compress_rate;  // for allocate output buffer as compress rate
+    int picture_size;
+    int picture_buffer_allocated;  // a flag presents if the piture buffer had alloced
+} ESEncVidInternalContext;
+
+typedef struct {
+    unsigned int slice_size;
+} SideDataSliceSize;
+
+typedef struct {
+    unsigned int force_idr;
+} SideDataForeceIdr;
+
+typedef struct {
+    unsigned int insert_sps_pps;
+} SideDataInsertSpsPps;
+
+typedef struct {
+    unsigned int rc_mode;
+    unsigned int rc_window;
+    unsigned int bitrate;
+    unsigned int min_qp;
+    unsigned int max_qp;
+    unsigned int fixed_qp_i;
+    unsigned int fixed_qp_p;
+    unsigned int fixed_qp_b;
+} SideDataRc;
+
+typedef enum {
+    CU_BLK_64x64,
+    CU_BLK_32x32,
+    CU_BLK_16x16,
+    CU_BLK_8x8,  // H264 not support
+} CuBlockUint;
+
+typedef struct {
+    CuBlockUint blk_unit;  // block unit
+    char skip;             // 1: skip cu
+    char is_abs_qp;        // is absolute qp value
+    char qp_value;         // qp value. is_abs=1: [-51, 51], is_abs=0: [-30, 0]
+} SideDataCuMap;
+
+typedef enum {
+    VSV_PRESET_NONE,
+    VSV_PRESET_SUPERFAST,
+    VSV_PRESET_FAST,
+    VSV_PRESET_MEDIUM,
+    VSV_PRESET_SLOW,
+    VSV_PRESET_SUPERSLOW,
+    VSV_PRESET_NUM
+} VSVPreset;
+
+struct statistic {
+    uint32_t frame_count;
+    uint32_t cycle_mb_avg;
+    uint32_t cycle_mb_avg_p1;
+    uint32_t cycle_mb_avg_total;
+    double ssim_avg;
+    uint32_t bitrate_avg;
+    uint32_t hw_real_time_avg;
+    uint32_t hw_real_time_avg_remove_overlap;
+    int32_t total_usage;
+    int32_t core_usage_counts[4];
+    struct timeval last_frame_encoded_timestamp;
+};
+
+typedef struct {
+    unsigned char index;     // index, coresponding with 0 ~ (MAX_ROI_NUM-1)/roi1~roi8 area
+    unsigned char enable;    // 1: enable, 0: disable
+    unsigned char is_absQp;  // 1: absolute QP, 0: relative QP
+    int qp;                  // QP value, if is_absQp == 1, [0, 51]; else [-30, 0]
+    unsigned int x;          // x
+    unsigned int y;          // y
+    unsigned int width;      // width
+    unsigned int height;     // height
+} RoiAttr;
+
+typedef struct {
+    unsigned int num_of_roi;
+    RoiAttr roi_attr[MAX_ROI_NUM];
+} RoiParas;
+
+typedef struct {
+    unsigned char hdr10_display_enable;  // 1: enable, 0: disable
+    unsigned int hdr10_dx0;      // Component 0 normalized x chromaticity coordinates range:[0, 50000]; Default:0
+    unsigned int hdr10_dy0;      // Component 0 normalized y chromaticity coordinates range:[0, 50000]; Default:0
+    unsigned int hdr10_dx1;      // Component 1 normalized x chromaticity coordinates range:[0, 50000]; Default:0
+    unsigned int hdr10_dy1;      // Component 1 normalized y chromaticity coordinates range:[0, 50000]; Default:0
+    unsigned int hdr10_dx2;      // Component 2 normalized x chromaticity coordinates range:[0, 50000]; Default:0
+    unsigned int hdr10_dy2;      // Component 2 normalized y chromaticity coordinates range:[0, 50000]; Default:0
+    unsigned int hdr10_wx;       // White piont normalized x chromaticity coordinates range:[0, 50000]; Default:0
+    unsigned int hdr10_wy;       // White piont normalized y chromaticity coordinates range:[0, 50000]; Default:0
+    unsigned int hdr10_maxluma;  // Nominal maximum display luminance Default:0
+    unsigned int hdr10_minluma;  // Nominal minimum display luminance Defaul:0
+} Hdr10DisplayAttr;
+
+typedef struct {
+    unsigned char hdr10_lightlevel_enable;  // 1: enable, 0: disable
+    unsigned int hdr10_maxlight;            // Max content light level
+    unsigned int hdr10_avglight;            // Max picture average light level
+} Hdr10LightAttr;
+
+typedef struct {
+    unsigned char hdr10_color_enable;  // 1: enable, 0: disable
+    unsigned int hdr10_primary;        // primary - Index of chromaticity coordinates range:[0, 9]; Default:9
+    unsigned int hdr10_matrix;         // Index of matrix coefficients range:[0, 9]; Default:9
+    unsigned int hdr10_transfer;       // 0-ITU-R BT.2020; 1-SMPTE ST 2084 2-ARIB STD-B67
+} Hdr10ColorAttr;
+
+typedef struct {
+    unsigned char index;   // index, coresponding with 0 ~ (MAX_ROI_NUM-1)/roi1~roi8 area
+    unsigned char enable;  // 1: enable, 0: disable
+    unsigned int x;        // x-coordinate of the upper-left
+    unsigned int y;        // y-coordinate of the upper-left
+    unsigned int width;    // x-coordinate of the lower-right
+    unsigned int height;   // y-coordinate of the lower-right
+} IpcmAttr;
+
+typedef struct {
+    unsigned int num_of_ipcm;
+    IpcmAttr ipcm_attr[MAX_IPCM_NUM];
+} IpcmParas;
+
+typedef struct {
+    const AVClass *class;
+    // common fields of ThreadContext
+    void *tc;
+    // other fields
+    AVCodecContext *avctx;
+    ESEncVidInternalContext in_ctx;
+    char module_name[20];
+    int internal_enc_index;
+
+    VCEncInst encoder;
+    VCEncOut encOut;
+
+    VCEncGopPicConfig gop_pic_cfg[MAX_GOP_PIC_CONFIG_NUM];
+    VCEncGopPicConfig gop_pic_cfg_pass2[MAX_GOP_PIC_CONFIG_NUM];
+    VCEncGopPicSpecialConfig gop_pic_special_cfg[MAX_GOP_SPIC_CONFIG_NUM];
+
+    VCEncRateCtrl rc;
+
+    bool encoder_is_open;
+    int encoder_is_start;
+    bool encoder_is_end;
+    // bool EncoderFlushPic;
+
+    VCEncIn enc_in_bk;
+    int picture_cnt_bk;
+
+    AdapGopCtr agop;
+    bool adaptive_gop;
+    uint8_t *p_user_data;
+    int next_poc;
+    VCEncPictureCodingType next_coding_type;
+    int32_t next_gop_size;
+    AVVSVDeviceContext *hwdevice;
+    uint8_t *dev_name;
+
+    int64_t frame_numbers;
+    int32_t bframe_delay_time;
+    int32_t bstart_output;
+    int32_t out_pkt_numbers;
+    AVFifoBuffer *output_pkt_queue;
+    int32_t poc;
+    /* param for performance */
+    Ma ma;
+    uint64_t total_bits;
+    uint32_t frame_cnt_total;
+    uint32_t frame_cnt_output;
+
+    /* param pass from ffmpeg */
+    int32_t pic_channel;
+    char *preset;
+    int bitdepth;
+    // User options.
+    int32_t output_rate_numer; /* output frame rate numerator */
+    int32_t output_rate_denom; /* output frame rate denominator */
+    int32_t width;
+    int32_t height;
+    int32_t lum_width_src;
+    int32_t lum_height_src;
+
+    int32_t input_format;
+    int32_t input_format_lookahead;
+    int32_t format_customized_type; /*change general format to customized one*/
+    int32_t byte_stream;
+
+    int32_t max_cu_size;                /* max coding unit size in pixels */
+    int32_t min_cu_size;                /* min coding unit size in pixels */
+    int32_t max_tr_size;                /* max transform size in pixels */
+    int32_t min_tr_size;                /* min transform size in pixels */
+    int32_t tr_depth_intra;             /* max transform hierarchy depth */
+    int32_t tr_depth_inter;             /* max transform hierarchy depth */
+    VCEncVideoCodecFormat codec_format; /* video codec format: hevc/h264/av1 */
+
+    int32_t min_qp_size;
+
+    int32_t enable_cabac; /* [0,1] h.264 entropy coding mode, 0 for cavlc, 1 for cabac */
+    int32_t cabac_init_flag;
+
+    // intra setup
+    uint32_t strong_intra_smoothing_enabled_flag;
+
+    int32_t cir_start;
+    int32_t cir_interval;
+
+    int32_t intra_area_enable;
+    int32_t intra_area_left;
+    int32_t intra_area_top;
+    int32_t intra_area_right;
+    int32_t intra_area_bottom;
+
+    int32_t pcm_loop_filter_disabled_flag;
+
+    int32_t ipcm1_area_left;
+    int32_t ipcm1_area_top;
+    int32_t ipcm1_area_right;
+    int32_t ipcm1_area_bottom;
+
+    int32_t ipcm2_area_left;
+    int32_t ipcm2_area_top;
+    int32_t ipcm2_area_right;
+    int32_t ipcm2_area_bottom;
+
+    int32_t ipcm3_area_left;
+    int32_t ipcm3_area_top;
+    int32_t ipcm4_area_right;
+    int32_t ipcm4_area_bottom;
+
+    int32_t ipcm5_area_left;
+    int32_t ipcm5_area_top;
+    int32_t ipcm5_area_right;
+    int32_t ipcm5_area_bottom;
+
+    int32_t ipcm6_area_left;
+    int32_t ipcm6_area_top;
+    int32_t ipcm6_area_right;
+    int32_t ipcm6_area_bottom;
+
+    int32_t ipcm7_area_left;
+    int32_t ipcm7_area_top;
+    int32_t ipcm7_area_right;
+    int32_t ipcm7_area_bottom;
+
+    int32_t ipcm8_area_left;
+    int32_t ipcm8_area_top;
+    int32_t ipcm8_area_right;
+    int32_t ipcm8_area_bottom;
+
+    int32_t ipcm_map_enable;
+    char *ipcm_map_file;
+    // ipcm option config
+    char *ipcm_str;
+    // save roi config
+    IpcmParas ipcm_tbl;
+
+    char *skip_map_file;
+    int32_t skip_map_enable;
+    int32_t skip_map_block_unit;
+    // roi option config
+    char *roi_str;
+    // save roi config
+    RoiParas roi_tbl;
+    /* rate control parameters */
+    rcMode_e rc_mode;
+    int32_t hrd_conformance;
+    int32_t cpb_size;
+    int32_t intra_pic_rate; /* idr interval */
+
+    int32_t vbr; /* variable bit rate control by qp_min */
+    int32_t qp_hdr;
+    int32_t qp_min;
+    int32_t qp_max;
+    int32_t qp_min_i;
+    int32_t qp_max_i;
+    int32_t bit_per_second;
+    int32_t crf; /*crf constant*/
+
+    int32_t bit_var_range_i;
+
+    int32_t bit_var_range_p;
+
+    int32_t bit_var_range_b;
+    uint32_t u32_static_scene_ibit_percent;
+
+    int32_t tol_moving_bit_rate; /*tolerance of max moving bit rate */
+    int32_t monitor_frames;      /*monitor frame length for moving bit rate*/
+    int32_t pic_rc;
+    int32_t ctb_rc;
+    int32_t block_rc_size;
+    uint32_t rc_qp_delta_range;
+    uint32_t rc_base_mb_complexity;
+    int32_t pic_skip;
+    int32_t pic_qp_delta_min;
+    int32_t pic_qp_delta_max;
+    int32_t ctb_rc_row_qp_step;
+
+    float tol_ctb_rc_inter;
+    float tol_ctb_rc_intra;
+
+    int32_t bitrate_window;
+    int32_t intra_qp_delta;
+    int32_t fixed_qp_I;
+    int32_t fixed_qp_P;
+    int32_t fixed_qp_B;
+    int32_t b_frame_qp_delta;
+
+    int32_t enable_deblocking;
+    int32_t enable_sao;
+    int32_t max_TLayers;  // SVC-T max layers
+    int32_t b_nums;       // B frame numbers within GOP
+    int32_t num_refP;
+    int32_t force_IDR;
+    int32_t insert_AUD;
+    int32_t insert_SPS_PPS;
+
+    int32_t tc_offset;
+    int32_t beta_offset;
+
+    int32_t chroma_qp_offset;
+
+    int32_t profile; /*main profile or main still picture profile*/
+    int32_t tier;    /*main tier or high tier*/
+    int32_t level;   /*main profile level*/
+
+    int32_t bps_adjust_frame[MAX_BPS_ADJUST];
+    int32_t bps_adjust_bitrate[MAX_BPS_ADJUST];
+    int32_t smooth_psnr_in_gop;
+
+    int32_t slice_size;
+
+    int32_t test_id;
+
+    int32_t rotation;
+    int32_t mirror;
+    int32_t hor_offset_src;
+    int32_t ver_offset_src;
+    int32_t color_conversion;
+    /*  Crop info*/
+    char *crop_str;
+
+    int32_t enable_deblock_override;
+    int32_t deblock_override;
+
+    int32_t enable_scaling_list;
+
+    uint32_t compressor;
+
+    int32_t interlaced_frame;
+    int32_t field_order;
+    int32_t video_range;
+    int32_t ssim;
+    int32_t enable_sei;
+    char *user_data;
+    uint32_t gop_size;
+    char *gop_cfg;
+    uint32_t gop_lowdelay;
+    int32_t out_recon_frame;
+    uint32_t long_term_gap;
+    uint32_t long_term_gap_offset;
+    uint32_t ltr_interval;
+    int32_t long_term_qp_delta;
+
+    int32_t gdr_duration;
+    uint32_t roi_map_delta_qp_block_unit;
+    uint32_t roi_map_delta_qp_enable;
+    char *roi_map_delta_qp_file;
+    char *roi_map_delta_qp_bin_file;
+    char *roi_map_info_bin_file;
+    char *roimap_cu_ctrl_info_bin_file;
+    char *roimap_cu_ctrl_index_bin_file;
+    uint32_t roi_cu_ctrl_ver;
+    uint32_t roi_qp_delta_ver;
+    int32_t out_buf_size_max;
+    int32_t multimode;  // multi-stream mode, 0--disable, 1--mult-thread, 2--multi-process
+    char *streamcfg[MAX_STREAMS];
+    int32_t outfile_format;  // 0->hevc, 1->h264, 2->vp9
+    uint32_t enable_output_cu_info;
+
+    uint32_t rdo_level;
+    /* low latency */
+    int32_t input_line_buf_mode;
+    int32_t input_line_buf_depth;
+    int32_t amount_per_loop_back;
+
+    uint32_t hashtype;
+    uint32_t verbose;
+
+    /* constant chroma control */
+    int32_t const_chroma_en;
+    uint32_t const_cb;
+    uint32_t const_cr;
+
+    int32_t scene_change[MAX_SCENE_CHANGE];
+
+    /* for tile*/
+    int32_t tiles_enabled_flag;
+    int32_t num_tile_columns;
+    int32_t num_tile_rows;
+    int32_t loop_filter_across_tiles_enabled_flag;
+
+    /*for skip frame encoding ctr*/
+    int32_t skip_frame_enabled_flag;
+    int32_t skip_frame_poc;
+
+    /*stride*/
+    uint32_t exp_of_input_alignment;
+    uint32_t exp_of_ref_alignment;
+    uint32_t exp_of_ref_ch_alignment;
+
+    uint32_t rps_in_slice_header;
+    uint32_t p010_ref_enable;
+    uint32_t enable_vui;
+
+    uint32_t pic_order_cnt_type;
+    uint32_t log2_max_pic_order_cnt_lsb;
+    uint32_t log2_max_frame_num;
+
+    uint32_t cutree_blkratio;
+    int16_t gmv[2][2];
+    char *gmv_file_name[2];
+    char *half_ds_input;
+
+    uint32_t parallel_core_num;
+
+    uint32_t dump_register;
+    uint32_t rasterscan;
+
+    uint32_t stream_buf_chain;
+    uint32_t lookahead_depth;
+    uint32_t stream_multi_segment_mode;
+    uint32_t stream_multi_segment_amount;
+    // add for new driver
+#ifdef DRV_NEW_ARCH
+    int priority;
+    char *device;
+    int mem_id;
+#endif
+    /*hdr10*/
+    char *hdr_display_str;
+    char *hdr_light_str;
+    char *hdr_color_str;
+
+    /*save hdr10 cfg*/
+    Hdr10DisplayAttr hdr10_display;
+    Hdr10LightAttr hdr10_light;
+    Hdr10ColorAttr hdr10_color;
+
+    // dump streaming and frame
+    char *dump_path;
+
+    int32_t dump_frame_enable;
+    int32_t dump_frame_time;
+    DumpHandle *dump_frame_hnd;
+    int32_t dump_frame_count;
+
+    int32_t dump_pkt_enable;
+    int32_t dump_pkt_time;
+    DumpHandle *dump_pkt_hnd;
+    int32_t dump_pkt_count;
+
+    time_t dump_start_time;
+
+    AVFrame *frame;
+} ESEncVidContext;
+
+av_cold int ff_vsv_h26x_encode_init(AVCodecContext *avctx);
+
+av_cold int ff_vsv_h26x_encode_close(AVCodecContext *avctx);
+
+int ff_vsv_h26x_encode_send_frame(AVCodecContext *avctx, const AVFrame *frame);
+
+int ff_vsv_h26x_encode_receive_packet(AVCodecContext *avctx, AVPacket *avpkt);
+
+int ff_vsv_h26x_encode_encode2(AVCodecContext *avctx, AVPacket *avpkt, const AVFrame *frame, int *got_packet);
+
+#endif
diff --git a/libavcodec/esenc_vid_buffer.c b/libavcodec/esenc_vid_buffer.c
new file mode 100644
index 0000000000..2e97b400d9
--- /dev/null
+++ b/libavcodec/esenc_vid_buffer.c
@@ -0,0 +1,335 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include "tools.h"
+#include "esenc_vid_buffer.h"
+
+void ff_get_output_buffer(ESEncVidInternalContext *in_ctx, VCEncIn *p_enc_in) {
+    int32_t i_buf;
+    for (i_buf = 0; i_buf < in_ctx->stream_buf_num; i_buf++) {
+        // find output buffer of multi-cores
+        in_ctx->outbuf_mem[i_buf] =
+            &(in_ctx->outbuf_mem_factory[in_ctx->picture_enc_cnt % in_ctx->parallel_core_num][i_buf]);
+
+        p_enc_in->busOutBuf[i_buf] = in_ctx->outbuf_mem[i_buf]->busAddress;
+        p_enc_in->outBufSize[i_buf] = in_ctx->outbuf_mem[i_buf]->size;
+        p_enc_in->pOutBuf[i_buf] = in_ctx->outbuf_mem[i_buf]->virtualAddress;
+    }
+}
+
+void ff_fill_roi_qp_map_buffer(ESEncVidInternalContext *in_ctx,
+                               ESEncVidContext *options,
+                               VCEncIn *p_enc_in,
+                               VCEncInst encoder) {
+    struct vcenc_instance *vcenc_instance = (struct vcenc_instance *)encoder;
+
+    if (!options->skip_map_enable && !options->roi_map_delta_qp_enable) {
+        // av_log(NULL, AV_LOG_ERROR, "setup roi map data fail\n");
+        return;
+    }
+
+    if (in_ctx->cu_map_buf_len && in_ctx->cu_map_buf) {
+        p_enc_in->roiMapDeltaSize = MIN(in_ctx->cu_map_buf_len, in_ctx->roi_map_delta_qp_mem->size);
+        p_enc_in->roiMapDeltaQpAddr = in_ctx->roi_map_delta_qp_mem->busAddress;
+        memcpy(in_ctx->roi_map_delta_qp_mem->virtualAddress, in_ctx->cu_map_buf, p_enc_in->roiMapDeltaSize);
+        free(in_ctx->cu_map_buf);
+        in_ctx->cu_map_buf = NULL;
+        in_ctx->cu_map_buf_len = 0;
+    } else {
+        p_enc_in->roiMapDeltaSize = 0;
+        p_enc_in->roiMapDeltaQpAddr = NULL;
+    }
+}
+
+static int32_t ff_get_avaliable_input_buffer_index(uint32_t buf_cnt, uint8_t *buf_status) {
+    int32_t i = 0;
+
+    if (buf_status == NULL) return -1;
+    if (!buf_cnt) return -1;
+
+    for (i = 0; i < buf_cnt; i++) {
+        if (!buf_status[i]) {
+            buf_status[i] = 1;
+            return i;
+        }
+    }
+    return -1;
+}
+
+void ff_get_input_picture_buffer(ESEncVidInternalContext *in_ctx) {
+    int32_t input_buffer_index = 0;
+
+    // find YUV frame buffer
+    input_buffer_index = ff_get_avaliable_input_buffer_index(in_ctx->buffer_cnt, in_ctx->picture_mem_status);
+    if (input_buffer_index < 0) {
+        av_log(NULL, AV_LOG_ERROR, "ff_get_avaliable_input_buffer_index fail\n");
+        return;
+    }
+    av_log(NULL, AV_LOG_DEBUG, "current_buffer_index: %d, buffer_cnt: %d\n", input_buffer_index, in_ctx->buffer_cnt);
+
+    in_ctx->picture_mem = &(in_ctx->picture_mem_factory[input_buffer_index]);
+}
+
+int32_t ff_release_input_picture_buffer(ESEncVidInternalContext *in_ctx, ptr_t in_bus_addr) {
+    int32_t i = 0;
+
+    if (in_ctx == NULL) return -1;
+    // not using by encoder, clear flag
+    if (in_bus_addr) {
+        for (i = 0; i < in_ctx->buffer_cnt; i++) {
+            if (in_ctx->picture_mem_factory[i].busAddress == in_bus_addr) {
+                if (in_ctx->picture_mem_status[i] > 0) in_ctx->picture_mem_status[i] = 0;
+                return 0;
+            }
+        }
+
+        av_log(NULL, AV_LOG_ERROR, "ff_release_input_picture_buffer %d, %x fail\n", in_bus_addr, in_bus_addr);
+        return -1;
+    }
+
+    return 0;
+}
+
+void ff_get_input_roi_qp_map_buffer(ESEncVidInternalContext *in_ctx) {
+    int32_t input_buffer_index = 0;
+
+    if (!in_ctx->cu_map_buf_len || !in_ctx->cu_map_buf) return;
+    // find YUV frame buffer
+    input_buffer_index = ff_get_avaliable_input_buffer_index(in_ctx->buffer_cnt, in_ctx->roi_qp_map_mem_status);
+    if (input_buffer_index < 0) {
+        av_log(NULL, AV_LOG_ERROR, "roi_qp_map, ff_get_avaliable_input_buffer_index fail\n");
+        return;
+    }
+    av_log(NULL,
+           AV_LOG_DEBUG,
+           "roi_qp_map, current_buffer_index: %d, buffer_cnt: %d\n",
+           input_buffer_index,
+           in_ctx->buffer_cnt);
+
+    // find ROI Map buffer of multi-cores
+    in_ctx->roi_map_delta_qp_mem = &(in_ctx->roi_map_delta_qp_mem_factory[input_buffer_index]);
+}
+
+int32_t ff_release_input_roi_qp_map_buffer(ESEncVidInternalContext *in_ctx, ptr_t in_bus_addr) {
+    int32_t i = 0;
+
+    if (in_ctx == NULL) return -1;
+    // not using by encoder, clear flag
+    if (in_bus_addr) {
+        for (i = 0; i < in_ctx->buffer_cnt; i++) {
+            if (in_ctx->roi_map_delta_qp_mem_factory[i].busAddress == in_bus_addr) {
+                if (in_ctx->roi_qp_map_mem_status[i] > 0) in_ctx->roi_qp_map_mem_status[i] = 0;
+                return 0;
+            }
+        }
+
+        av_log(
+            NULL, AV_LOG_ERROR, "roi_qp_map, ff_release_input_picture_buffer %d, %x fail\n", in_bus_addr, in_bus_addr);
+        return -1;
+    }
+
+    return 0;
+}
+
+MemInfo *ff_alloc_and_fill_mem_info(int64_t fd, unsigned long vpa, AVFrame *frame) {
+    MemInfo *mem = (MemInfo *)malloc(sizeof(MemInfo));
+    if (mem) {
+        mem->dma_fd = fd;
+        mem->vpa = vpa;
+        if (frame) {
+            mem->frame = av_frame_clone(frame);
+            // av_log(NULL, AV_LOG_WARNING, "share fd, clone frame, old: %p, new: %p\n", frame, mem->frame);
+        } else {
+            mem->frame = NULL;
+        }
+    }
+
+    return mem;
+}
+
+int ff_push_mem_info_into_queue(ESEncVidInternalContext *in_ctx, MemInfo *mem_info) {
+    if (!in_ctx || !mem_info) return -1;
+
+    pthread_mutex_lock(&in_ctx->in_mem_queue_mutex);
+    es_queue_push_tail(in_ctx->in_mem_queue, (void *)mem_info);
+    pthread_mutex_unlock(&in_ctx->in_mem_queue_mutex);
+
+    return 0;
+}
+
+int ff_get_mem_info_queue_size(ESEncVidInternalContext *in_ctx) {
+    int ret = 0;
+    if (!in_ctx) return -1;
+
+    pthread_mutex_lock(&in_ctx->in_mem_queue_mutex);
+    ret = es_queue_get_length(in_ctx->in_mem_queue);
+    pthread_mutex_unlock(&in_ctx->in_mem_queue_mutex);
+
+    return ret;
+}
+
+MemInfo *ff_get_mem_info_by_vpa(ESEncVidInternalContext *in_ctx, unsigned long dst_va) {
+    if (!in_ctx) return NULL;
+
+    pthread_mutex_lock(&in_ctx->in_mem_queue_mutex);
+
+    ESQueue *q = in_ctx->in_mem_queue;
+    List *node = NULL;
+    int found = 0;
+    MemInfo *mem_info = NULL;
+    node = q->head;
+
+    while (node) {
+        mem_info = (MemInfo *)node->data;
+        if (mem_info && (mem_info->vpa == dst_va)) {
+            found = 1;
+            break;
+        } else {
+            node = node->next;
+        }
+    }
+
+    pthread_mutex_unlock(&in_ctx->in_mem_queue_mutex);
+    return found ? mem_info : NULL;
+}
+
+int ff_remove_mem_info_from_queue(ESEncVidInternalContext *in_ctx, MemInfo *mem_info) {
+    int ret = 0;
+    if (!in_ctx || !mem_info) return -1;
+
+    pthread_mutex_lock(&in_ctx->in_mem_queue_mutex);
+    ret = es_queue_delete_data(in_ctx->in_mem_queue, (void *)mem_info);
+    pthread_mutex_unlock(&in_ctx->in_mem_queue_mutex);
+    if (mem_info->frame) {
+        // av_log(NULL, AV_LOG_WARNING, "share fd, unref frame: %p\n", mem_info->frame);
+        av_frame_free(&mem_info->frame);
+        mem_info->frame = NULL;
+    }
+    free(mem_info);
+    mem_info = NULL;
+
+    return ret;
+}
+
+int ff_clean_mem_info_queue(ESEncVidInternalContext *in_ctx) {
+    if (!in_ctx) return -1;
+
+    pthread_mutex_lock(&in_ctx->in_mem_queue_mutex);
+    ESQueue *q = in_ctx->in_mem_queue;
+    List *node = NULL;
+    MemInfo *mem_info = NULL;
+    node = q->head;
+
+    while (node) {
+        mem_info = (MemInfo *)node->data;
+        // delete node
+        if (mem_info) {
+            es_queue_delete_data(q, mem_info);
+            if (mem_info->frame) av_frame_free(&mem_info->frame);
+            free(mem_info);
+        }
+        node = node->next;
+    }
+
+    pthread_mutex_unlock(&in_ctx->in_mem_queue_mutex);
+
+    return 0;
+}
+
+DtsInfo *ff_alloc_and_fill_dts_info(int64_t dts) {
+    DtsInfo *dts_info = (DtsInfo *)malloc(sizeof(DtsInfo));
+    if (dts_info) {
+        dts_info->dts = dts;
+        // av_log(NULL, AV_LOG_WARNING, "alloc dts_info: %p, dts: %ld\n", dts_info, dts_info->dts);
+    }
+
+    return dts_info;
+}
+
+int ff_remove_dts_info_from_queue(ESEncVidInternalContext *in_ctx, DtsInfo *dts_info) {
+    int ret = 0;
+    if (!in_ctx || !dts_info) return -1;
+
+    pthread_mutex_lock(&in_ctx->dts_queue_mutex);
+    ret = es_queue_delete_data(in_ctx->dts_queue, (void *)dts_info);
+    pthread_mutex_unlock(&in_ctx->dts_queue_mutex);
+    free(dts_info);
+    dts_info = NULL;
+
+    return ret;
+}
+
+int ff_push_dts_info_into_queue(ESEncVidInternalContext *in_ctx, DtsInfo *dts_info) {
+    if (!in_ctx || !dts_info) return -1;
+
+    pthread_mutex_lock(&in_ctx->dts_queue_mutex);
+    es_queue_push_tail(in_ctx->dts_queue, (void *)dts_info);
+    pthread_mutex_unlock(&in_ctx->dts_queue_mutex);
+
+    return 0;
+}
+
+int64_t ff_get_and_del_min_dts_from_queue(ESEncVidInternalContext *in_ctx) {
+    if (!in_ctx) return NULL;
+
+    pthread_mutex_lock(&in_ctx->dts_queue_mutex);
+
+    ESQueue *q = in_ctx->dts_queue;
+    List *node = NULL;
+    int64_t min_pts = AV_NOPTS_VALUE;
+    DtsInfo *min_dts_info = NULL;
+    DtsInfo *dts_info = NULL;
+    node = q->head;
+
+    while (node) {
+        dts_info = (DtsInfo *)node->data;
+        if (dts_info) {
+            // av_log(NULL, AV_LOG_WARNING, "found dts_info: %p, dts: %ld\n", dts_info, dts_info->dts);
+            if (min_pts == AV_NOPTS_VALUE) {
+                min_pts = dts_info->dts;
+                min_dts_info = dts_info;
+            } else {
+                if (min_pts > dts_info->dts) {
+                    min_pts = dts_info->dts;
+                    min_dts_info = dts_info;
+                }
+            }
+        }
+
+        node = node->next;
+    }
+
+    // delete node
+    es_queue_delete_data(q, min_dts_info);
+    pthread_mutex_unlock(&in_ctx->dts_queue_mutex);
+
+    // av_log(NULL, AV_LOG_WARNING, "min_dts_info: %p, min_info->dts: %ld, min_pts: %ld\n", min_dts_info,
+    // min_dts_info->dts, min_pts);
+    return min_pts;
+}
+
+int ff_clean_dts_queue(ESEncVidInternalContext *in_ctx) {
+    if (!in_ctx) return -1;
+
+    pthread_mutex_lock(&in_ctx->dts_queue_mutex);
+
+    ESQueue *q = in_ctx->dts_queue;
+    List *node = NULL;
+    DtsInfo *dts_info = NULL;
+    node = q->head;
+
+    while (node) {
+        dts_info = (DtsInfo *)node->data;
+        // delete node
+        if (dts_info) {
+            es_queue_delete_data(q, dts_info);
+            free(dts_info);
+        }
+        node = node->next;
+    }
+
+    pthread_mutex_unlock(&in_ctx->dts_queue_mutex);
+
+    return 0;
+}
\ No newline at end of file
diff --git a/libavcodec/esenc_vid_buffer.h b/libavcodec/esenc_vid_buffer.h
new file mode 100644
index 0000000000..ecb516d588
--- /dev/null
+++ b/libavcodec/esenc_vid_buffer.h
@@ -0,0 +1,53 @@
+#ifndef AVCODEC_ESENC_VIDEO_BUFFER_H
+#define AVCODEC_ESENC_VIDEO_BUFFER_H
+
+#include "esenc_vid.h"
+
+typedef struct {
+    int64_t dma_fd;     // dma buffer fd
+    unsigned long vpa;  // dma buffer virtual addr
+    AVFrame *frame;     // refence of frame
+} MemInfo;
+
+typedef struct {
+    int64_t dts;
+} DtsInfo;
+
+void ff_get_output_buffer(ESEncVidInternalContext *tb, VCEncIn *pEncIn);
+
+void ff_get_input_picture_buffer(ESEncVidInternalContext *tb);
+
+int32_t ff_release_input_picture_buffer(ESEncVidInternalContext *in_ctx, ptr_t in_bus_addr);
+
+void ff_get_input_roi_qp_map_buffer(ESEncVidInternalContext *tb);
+
+void ff_fill_roi_qp_map_buffer(ESEncVidInternalContext *tb,
+                               ESEncVidContext *options,
+                               VCEncIn *pEncIn,
+                               VCEncInst encoder);
+
+int32_t ff_release_input_roi_qp_map_buffer(ESEncVidInternalContext *in_ctx, ptr_t in_bus_addr);
+
+MemInfo *ff_alloc_and_fill_mem_info(int64_t fd, unsigned long vpa, AVFrame *frame);
+
+int ff_push_mem_info_into_queue(ESEncVidInternalContext *in_ctx, MemInfo *mem_info);
+
+int ff_get_mem_info_queue_size(ESEncVidInternalContext *in_ctx);
+
+MemInfo *ff_get_mem_info_by_vpa(ESEncVidInternalContext *in_ctx, unsigned long dst_va);
+
+int ff_remove_mem_info_from_queue(ESEncVidInternalContext *in_ctx, MemInfo *mem_info);
+
+int ff_clean_mem_info_queue(ESEncVidInternalContext *in_ctx);
+
+DtsInfo *ff_alloc_and_fill_dts_info(int64_t dts);
+
+int ff_push_dts_info_into_queue(ESEncVidInternalContext *in_ctx, DtsInfo *dts_info);
+
+int ff_remove_dts_info_from_queue(ESEncVidInternalContext *in_ctx, DtsInfo *dts_info);
+
+int64_t ff_get_and_del_min_dts_from_queue(ESEncVidInternalContext *in_ctx);
+
+int ff_clean_dts_queue(ESEncVidInternalContext *in_ctx);
+
+#endif
\ No newline at end of file
diff --git a/libavcodec/esenc_vid_internal.c b/libavcodec/esenc_vid_internal.c
new file mode 100644
index 0000000000..ef75b61c64
--- /dev/null
+++ b/libavcodec/esenc_vid_internal.c
@@ -0,0 +1,1341 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include "tools.h"
+#include "esenc_vid_internal.h"
+
+#define MAX_LINE_LENGTH_BLOCK 512 * 8
+
+//           Type POC QPoffset  QPfactor  num_ref_pics ref_pics  used_by_cur
+const char *RpsDefault_GOPSize_1[] = {
+    "Frame1:  P    1   0        0.578     0      1        -1         1",
+    NULL,
+};
+
+const char *RpsDefault_V60_GOPSize_1[] = {
+    "Frame1:  P    1   0        0.8     0      1        -1         1",
+    NULL,
+};
+
+const char *RpsDefault_H264_GOPSize_1[] = {
+    "Frame1:  P    1   0        0.4     0      1        -1         1",
+    NULL,
+};
+
+const char *RpsDefault_GOPSize_2[] = {
+    "Frame1:  P        2   0        0.6     0      1        -2         1",
+    "Frame2:  nrefB    1   0        0.68    0      2        -1 1       1 1",
+    NULL,
+};
+
+const char *RpsDefault_GOPSize_3[] = {
+    "Frame1:  P        3   0        0.5     0      1        -3         1   ",
+    "Frame2:  B        1   0        0.5     0      2        -1 2       1 1 ",
+    "Frame3:  nrefB    2   0        0.68    0      2        -1 1       1 1 ",
+    NULL,
+};
+
+const char *RpsDefault_GOPSize_4[] = {
+    "Frame1:  P        4   0        0.5      0     1       -4         1 ",
+    "Frame2:  B        2   0        0.3536   0     2       -2 2       1 1",
+    "Frame3:  nrefB    1   0        0.5      0     3       -1 1 3     1 1 0",
+    "Frame4:  nrefB    3   0        0.5      0     2       -1 1       1 1 ",
+    NULL,
+};
+
+const char *RpsDefault_GOPSize_5[] = {
+    "Frame1:  P        5   0        0.442    0     1       -5         1 ",
+    "Frame2:  B        2   0        0.3536   0     2       -2 3       1 1",
+    "Frame3:  nrefB    1   0        0.68     0     3       -1 1 4     1 1 0",
+    "Frame4:  B        3   0        0.3536   0     2       -1 2       1 1 ",
+    "Frame5:  nrefB    4   0        0.68     0     2       -1 1       1 1 ",
+    NULL,
+};
+
+const char *RpsDefault_GOPSize_6[] = {
+    "Frame1:  P        6   0        0.442    0     1       -6         1 ",
+    "Frame2:  B        3   0        0.3536   0     2       -3 3       1 1",
+    "Frame3:  B        1   0        0.3536   0     3       -1 2 5     1 1 0",
+    "Frame4:  nrefB    2   0        0.68     0     3       -1 1 4     1 1 0",
+    "Frame5:  B        4   0        0.3536   0     2       -1 2       1 1 ",
+    "Frame6:  nrefB    5   0        0.68     0     2       -1 1       1 1 ",
+    NULL,
+};
+
+const char *RpsDefault_GOPSize_7[] = {
+    "Frame1:  P        7   0        0.442    0     1       -7         1 ",
+    "Frame2:  B        3   0        0.3536   0     2       -3 4       1 1",
+    "Frame3:  B        1   0        0.3536   0     3       -1 2 6     1 1 0",
+    "Frame4:  nrefB    2   0        0.68     0     3       -1 1 5     1 1 0",
+    "Frame5:  B        5   0        0.3536   0     2       -2 2       1 1 ",
+    "Frame6:  nrefB    4   0        0.68     0     3       -1 1 3     1 1 0",
+    "Frame7:  nrefB    6   0        0.68     0     2       -1 1       1 1 ",
+    NULL,
+};
+
+const char *RpsDefault_GOPSize_8[] = {
+    "Frame1:  P        8   0        0.442    0  1           -8        1 ",
+    "Frame2:  B        4   0        0.3536   0  2           -4 4      1 1 ",
+    "Frame3:  B        2   0        0.3536   0  3           -2 2 6    1 1 0 ",
+    "Frame4:  nrefB    1   0        0.68     0  4           -1 1 3 7  1 1 0 0",
+    "Frame5:  nrefB    3   0        0.68     0  3           -1 1 5    1 1 0",
+    "Frame6:  B        6   0        0.3536   0  2           -2 2      1 1",
+    "Frame7:  nrefB    5   0        0.68     0  3           -1 1 3    1 1 0",
+    "Frame8:  nrefB    7   0        0.68     0  2           -1 1      1 1",
+    NULL,
+};
+
+const char *RpsDefault_GOPSize_16[] = {
+    "Frame1:  P       16   0        0.6      0  1           -16                   1",
+    "Frame2:  B        8   0        0.2      0  2           -8   8                1   1",
+    "Frame3:  B        4   0        0.33     0  3           -4   4  12            1   1   0",
+    "Frame4:  B        2   0        0.33     0  4           -2   2   6  14        1   1   0   0",
+    "Frame5:  nrefB    1   0        0.4      0  5           -1   1   3   7  15    1   1   0   0   0",
+    "Frame6:  nrefB    3   0        0.4      0  4           -1   1   5  13        1   1   0   0",
+    "Frame7:  B        6   0        0.33     0  3           -2   2  10            1   1   0",
+    "Frame8:  nrefB    5   0        0.4      0  4           -1   1   3  11        1   1   0   0",
+    "Frame9:  nrefB    7   0        0.4      0  3           -1   1   9            1   1   0",
+    "Frame10: B       12   0        0.33     0  2           -4   4                1   1",
+    "Frame11: B       10   0        0.33     0  3           -2   2   6            1   1   0",
+    "Frame12: nrefB    9   0        0.4      0  4           -1   1   3   7        1   1   0   0",
+    "Frame13: nrefB   11   0        0.4      0  3           -1   1   5            1   1   0",
+    "Frame14: B       14   0        0.33     0  2           -2   2                1   1",
+    "Frame15: nrefB   13   0        0.4      0  3           -1   1   3            1   1   0",
+    "Frame16: nrefB   15   0        0.4      0  2           -1   1                1   1",
+    NULL,
+};
+
+const char *RpsDefault_Interlace_GOPSize_1[] = {
+    "Frame1:  P    1   0        0.8       0   2           -1 -2     0 1",
+    NULL,
+};
+
+const char *RpsLowdelayDefault_GOPSize_1[] = {
+    "Frame1:  B    1   0        0.65      0     2       -1 -2         1 1",
+    NULL,
+};
+
+const char *RpsLowdelayDefault_GOPSize_2[] = {
+    "Frame1:  B    1   0        0.4624    0     2       -1 -3         1 1",
+    "Frame2:  B    2   0        0.578     0     2       -1 -2         1 1",
+    NULL,
+};
+
+const char *RpsLowdelayDefault_GOPSize_3[] = {
+    "Frame1:  B    1   0        0.4624    0     2       -1 -4         1 1",
+    "Frame2:  B    2   0        0.4624    0     2       -1 -2         1 1",
+    "Frame3:  B    3   0        0.578     0     2       -1 -3         1 1",
+    NULL,
+};
+
+const char *RpsLowdelayDefault_GOPSize_4[] = {
+    "Frame1:  B    1   0        0.4624    0     2       -1 -5         1 1",
+    "Frame2:  B    2   0        0.4624    0     2       -1 -2         1 1",
+    "Frame3:  B    3   0        0.4624    0     2       -1 -3         1 1",
+    "Frame4:  B    4   0        0.578     0     2       -1 -4         1 1",
+    NULL,
+};
+
+const char *RpsPass2_GOPSize_4[] = {
+    "Frame1:  B        4   0        0.5      0     2       -4 -8      1 1",
+    "Frame2:  B        2   0        0.3536   0     2       -2 2       1 1",
+    "Frame3:  nrefB    1   0        0.5      0     3       -1 1 3     1 1 0",
+    "Frame4:  nrefB    3   0        0.5      0     3       -1 -3 1    1 0 1",
+    NULL,
+};
+
+const char *RpsPass2_GOPSize_8[] = {
+    "Frame1:  B        8   0        0.442    0  2           -8 -16    1 1",
+    "Frame2:  B        4   0        0.3536   0  2           -4 4      1 1",
+    "Frame3:  B        2   0        0.3536   0  3           -2 2 6    1 1 0",
+    "Frame4:  nrefB    1   0        0.68     0  4           -1 1 3 7  1 1 0 0",
+    "Frame5:  nrefB    3   0        0.68     0  4           -1 -3 1 5 1 0 1 0",
+    "Frame6:  B        6   0        0.3536   0  3           -2 -6 2   1 0 1",
+    "Frame7:  nrefB    5   0        0.68     0  4           -1 -5 1 3 1 0 1 0",
+    "Frame8:  nrefB    7   0        0.68     0  3           -1 -7 1   1 0 1",
+    NULL,
+};
+
+const char *RpsPass2_GOPSize_2[] = {
+    "Frame1:  B        2   0        0.6     0      2        -2 -4      1 1",
+    "Frame2:  nrefB    1   0        0.68    0      2        -1 1       1 1",
+    NULL,
+};
+
+// 2 reference frames for P
+const char *Rps_2RefForP_GOPSize_1[] = {
+    "Frame1:  P    1   0        0.578     0      2        -1 -2         1 1",
+    NULL,
+};
+
+const char *Rps_2RefForP_H264_GOPSize_1[] = {
+    "Frame1:  P    1   0        0.4     0      2        -1 -2         1 1",
+    NULL,
+};
+
+const char *Rps_2RefForP_GOPSize_2[] = {
+    "Frame1:  P        2   0        0.6     0      2        -2 -4      1 1",
+    "Frame2:  nrefB    1   0        0.68    0      2        -1 1       1 1",
+    NULL,
+};
+
+const char *Rps_2RefForP_GOPSize_3[] = {
+    "Frame1:  P        3   0        0.5     0      2        -3 -6      1 1 ",
+    "Frame2:  B        1   0        0.5     0      2        -1 2       1 1 ",
+    "Frame3:  nrefB    2   0        0.68    0      3        -1 -2 1    1 0 1 ",
+    NULL,
+};
+
+const char *Rps_2RefForP_GOPSize_4[] = {
+    "Frame1:  P        4   0        0.5      0     2       -4 -8      1 1 ",
+    "Frame2:  B        2   0        0.3536   0     2       -2 2       1 1",
+    "Frame3:  nrefB    1   0        0.5      0     3       -1 1 3     1 1 0",
+    "Frame4:  nrefB    3   0        0.5      0     3       -1 -3 1    1 0 1",
+    NULL,
+};
+
+const char *Rps_2RefForP_GOPSize_5[] = {
+    "Frame1:  P        5   0        0.442    0     2       -5 -10     1 1",
+    "Frame2:  B        2   0        0.3536   0     2       -2 3       1 1",
+    "Frame3:  nrefB    1   0        0.68     0     3       -1 1 4     1 1 0",
+    "Frame4:  B        3   0        0.3536   0     3       -1 -3 2    1 0 1 ",
+    "Frame5:  nrefB    4   0        0.68     0     3       -1 -4 1    1 0 1 ",
+    NULL,
+};
+
+const char *Rps_2RefForP_GOPSize_6[] = {
+    "Frame1:  P        6   0        0.442    0     2       -6 -12     1 1",
+    "Frame2:  B        3   0        0.3536   0     2       -3 3       1 1",
+    "Frame3:  B        1   0        0.3536   0     3       -1 2 5     1 1 0",
+    "Frame4:  nrefB    2   0        0.68     0     4       -1 -2 1 4  1 0 1 0",
+    "Frame5:  B        4   0        0.3536   0     3       -1 -4 2    1 0 1 ",
+    "Frame6:  nrefB    5   0        0.68     0     3       -1 -5 1    1 0 1 ",
+    NULL,
+};
+
+const char *Rps_2RefForP_GOPSize_7[] = {
+    "Frame1:  P        7   0        0.442    0     2       -7 -14     1 1",
+    "Frame2:  B        3   0        0.3536   0     2       -3 4       1 1",
+    "Frame3:  B        1   0        0.3536   0     3       -1 2 6     1 1 0",
+    "Frame4:  nrefB    2   0        0.68     0     4       -1 -2 1 5  1 0 1 0",
+    "Frame5:  B        5   0        0.3536   0     3       -2 -5 2    1 0 1 ",
+    "Frame6:  nrefB    4   0        0.68     0     4       -1 -4 1 3  1 0 1 0",
+    "Frame7:  nrefB    6   0        0.68     0     3       -1 -6 1    1 0 1 ",
+    NULL,
+};
+
+const char *Rps_2RefForP_GOPSize_8[] = {
+    "Frame1:  P        8   0        0.442    0  2          -8 -16     1 1",
+    "Frame2:  B        4   0        0.3536   0  2          -4 4       1 1 ",
+    "Frame3:  B        2   0        0.3536   0  3          -2 2 6     1 1 0 ",
+    "Frame4:  nrefB    1   0        0.68     0  4          -1 1 3 7   1 1 0 0",
+    "Frame5:  nrefB    3   0        0.68     0  4          -1 -3 1 5  1 0 1 0",
+    "Frame6:  B        6   0        0.3536   0  3          -2 -6 2    1 0 1",
+    "Frame7:  nrefB    5   0        0.68     0  4          -1 -5 1 3  1 0 1 0",
+    "Frame8:  nrefB    7   0        0.68     0  3          -1 -7 1    1 0 1",
+    NULL,
+};
+
+void ff_change_to_customized_format(ESEncVidContext *options, VCEncPreProcessingCfg *pre_proc_cfg) {
+#ifndef ESW_FF_ENHANCEMENT
+    if ((options->format_customized_type == 0) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        if (IS_HEVC(options->codec_format))
+            pre_proc_cfg->inputType = VCENC_YUV420_PLANAR_8BIT_DAHUA_HEVC;
+        else
+            pre_proc_cfg->inputType = VCENC_YUV420_PLANAR_8BIT_DAHUA_H264;
+        pre_proc_cfg->origWidth = ((pre_proc_cfg->origWidth + 16 - 1) & (~(16 - 1)));
+    }
+#endif
+    if ((options->format_customized_type == 1)
+        && ((options->input_format == VCENC_YUV420_SEMIPLANAR) || (options->input_format == VCENC_YUV420_SEMIPLANAR_VU)
+            || (options->input_format == VCENC_YUV420_PLANAR_10BIT_P010))) {
+#ifndef ESW_FF_ENHANCEMENT
+        if (options->input_format == VCENC_YUV420_SEMIPLANAR)
+            pre_proc_cfg->inputType = VCENC_YUV420_SEMIPLANAR_8BIT_FB;
+        else if (options->input_format == VCENC_YUV420_SEMIPLANAR_VU)
+            pre_proc_cfg->inputType = VCENC_YUV420_SEMIPLANAR_VU_8BIT_FB;
+        else
+            pre_proc_cfg->inputType = VCENC_YUV420_PLANAR_10BIT_P010_FB;
+#else
+        if (options->input_format == VCENC_YUV420_SEMIPLANAR_VU)
+            pre_proc_cfg->inputType = VCENC_YUV420_SEMIPLANAR_VU_8BIT_TILE_4_4;
+        else
+            pre_proc_cfg->inputType = VCENC_YUV420_PLANAR_10BIT_P010;
+#endif
+    }
+
+    if ((options->format_customized_type == 2) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_SEMIPLANAR_101010;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 6 * 6;
+    }
+
+    if ((options->format_customized_type == 3) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_8BIT_TILE_64_4;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 64 * 64;
+        pre_proc_cfg->yOffset = pre_proc_cfg->yOffset / 4 * 4;
+    }
+
+    if ((options->format_customized_type == 4) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_UV_8BIT_TILE_64_4;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 64 * 64;
+        pre_proc_cfg->yOffset = pre_proc_cfg->yOffset / 4 * 4;
+    }
+
+    if ((options->format_customized_type == 5) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_10BIT_TILE_32_4;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 32 * 32;
+        pre_proc_cfg->yOffset = pre_proc_cfg->yOffset / 4 * 4;
+    }
+
+    if ((options->format_customized_type == 6) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_10BIT_TILE_48_4;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 48 * 48;
+        pre_proc_cfg->yOffset = pre_proc_cfg->yOffset / 4 * 4;
+    }
+
+    if ((options->format_customized_type == 7) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_VU_10BIT_TILE_48_4;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 48 * 48;
+        pre_proc_cfg->yOffset = pre_proc_cfg->yOffset / 4 * 4;
+    }
+
+    if ((options->format_customized_type == 8) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_8BIT_TILE_128_2;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 128 * 128;
+    }
+
+    if ((options->format_customized_type == 9) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_UV_8BIT_TILE_128_2;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 128 * 128;
+    }
+
+    if ((options->format_customized_type == 10) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_10BIT_TILE_96_2;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 96 * 96;
+    }
+
+    if ((options->format_customized_type == 11) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        pre_proc_cfg->inputType = VCENC_YUV420_VU_10BIT_TILE_96_2;
+        pre_proc_cfg->xOffset = pre_proc_cfg->xOffset / 96 * 96;
+    }
+}
+
+void ff_change_cml_customized_format(ESEncVidContext *options) {
+    if ((options->format_customized_type == 0) && (options->input_format == VCENC_YUV420_PLANAR)) {
+        if (IS_H264(options->codec_format)) {
+            if (options->ver_offset_src != DEFAULT) options->ver_offset_src = options->ver_offset_src & (~(16 - 1));
+            if (options->hor_offset_src != DEFAULT) options->hor_offset_src = options->hor_offset_src & (~(16 - 1));
+        } else {
+            if (options->ver_offset_src != DEFAULT) options->ver_offset_src = options->ver_offset_src & (~(32 - 1));
+            if (options->hor_offset_src != DEFAULT) options->hor_offset_src = options->hor_offset_src & (~(32 - 1));
+        }
+        options->width = options->width & (~(16 - 1));
+        options->height = options->height & (~(16 - 1));
+    }
+
+    if ((options->format_customized_type == 1)
+        && ((options->input_format == VCENC_YUV420_SEMIPLANAR) || (options->input_format == VCENC_YUV420_SEMIPLANAR_VU)
+            || (options->input_format == VCENC_YUV420_PLANAR_10BIT_P010))) {
+        options->ver_offset_src = 0;
+        options->hor_offset_src = 0;
+        if (options->test_id == 16) options->test_id = 0;
+
+        options->rotation = 0;
+    } else if (options->format_customized_type == 1) {
+        options->format_customized_type = -1;
+    }
+
+    if (((options->format_customized_type >= 2) && (options->format_customized_type <= 11))
+        && (options->input_format == VCENC_YUV420_PLANAR)) {
+        if (options->test_id == 16) options->test_id = 0;
+        options->rotation = 0;
+    } else {
+        options->format_customized_type = -1;
+    }
+}
+
+static void trans_yuv_to_fb_format(ESEncVidInternalContext *in_ctx, ESEncVidContext *options) {
+    uint8_t *transform_buf;
+    uint32_t x, y;
+    VCEncIn *pEncIn = &(in_ctx->enc_in);
+    uint32_t alignment;
+    uint32_t byte_per_compt = 0;
+    uint32_t size_lum;
+
+#ifdef USE_OLD_DRV
+    transform_buf = (uint8_t *)in_ctx->transform_mem->virtualAddress;
+#endif
+    alignment = (in_ctx->input_alignment == 0 ? 1 : in_ctx->input_alignment);
+
+    if (options->input_format == VCENC_YUV420_SEMIPLANAR || options->input_format == VCENC_YUV420_SEMIPLANAR_VU)
+        byte_per_compt = 1;
+    else if (options->input_format == VCENC_YUV420_PLANAR_10BIT_P010)
+        byte_per_compt = 2;
+
+    if ((options->input_format == VCENC_YUV420_SEMIPLANAR) || (options->input_format == VCENC_YUV420_SEMIPLANAR_VU)
+        || (options->input_format == VCENC_YUV420_PLANAR_10BIT_P010)) {
+        uint32_t stride;
+        stride = (options->lum_width_src * 4 * byte_per_compt + alignment - 1) & (~(alignment - 1));
+
+        // luma
+        for (x = 0; x < options->lum_width_src / 4; x++) {
+            for (y = 0; y < options->lum_height_src; y++) {
+                memcpy(
+                    transform_buf + y % 4 * 4 * byte_per_compt + stride * (y / 4) + x * 16 * byte_per_compt,
+                    in_ctx->lum + y * ((options->lum_width_src + 15) & (~15)) * byte_per_compt + x * 4 * byte_per_compt,
+                    4 * byte_per_compt);
+            }
+        }
+
+        transform_buf += stride * options->lum_height_src / 4;
+
+        // chroma
+        for (x = 0; x < options->lum_width_src / 4; x++) {
+            for (y = 0; y < ((options->lum_height_src / 2) + 3) / 4 * 4; y++) {
+                memcpy(
+                    transform_buf + y % 4 * 4 * byte_per_compt + stride * (y / 4) + x * 16 * byte_per_compt,
+                    in_ctx->cb + y * ((options->lum_width_src + 15) & (~15)) * byte_per_compt + x * 4 * byte_per_compt,
+                    4 * byte_per_compt);
+            }
+        }
+    }
+
+    size_lum = ((options->lum_width_src * 4 * byte_per_compt + alignment - 1) & (~(alignment - 1)))
+               * options->lum_height_src / 4;
+
+    pEncIn->busChromaU = pEncIn->busLuma + (uint32_t)size_lum;
+#ifndef ESW_FF_ENHANCEMENT
+#ifndef USE_OLD_DRV
+    EWLTransDataRC2EP(in_ctx->ewl, in_ctx->transform_mem, in_ctx->transform_mem, in_ctx->transform_mem->size);
+#endif
+#endif
+}
+
+int32_t ff_read_gmv(ESEncVidInternalContext *in_ctx, VCEncIn *p_enc_in, ESEncVidContext *options) {
+    int16_t i;
+
+    for (i = 0; i < 2; i++) {
+        p_enc_in->gmv[i][0] = options->gmv[i][0];
+        p_enc_in->gmv[i][1] = options->gmv[i][1];
+    }
+
+    return 0;
+}
+
+static char *next_token(char *str) {
+    char *p = strchr(str, ' ');
+    if (p) {
+        while (*p == ' ') p++;
+        if (*p == '\0') p = NULL;
+    }
+    return p;
+}
+
+static int parse_gop_config_string(char *line, VCEncGopConfig *gop_cfg, int frame_idx, int gop_size) {
+    if (!line) return -1;
+
+    av_log(NULL, AV_LOG_INFO, "parserGOP, %s\n", line);
+
+    // format: FrameN Type POC QPoffset QPfactor  num_ref_pics ref_pics  used_by_cur
+    int frameN, poc, num_ref_pics, i;
+    char type[10];
+    VCEncGopPicConfig *cfg = NULL;
+    VCEncGopPicSpecialConfig *scfg = NULL;
+
+    // frame idx
+    sscanf(line, "Frame%d", &frameN);
+    if ((frameN != (frame_idx + 1)) && (frameN != 0)) return -1;
+
+    if (frameN > gop_size) return 0;
+
+    if (0 == frameN) {
+        // format: FrameN Type  QPoffset  QPfactor   TemporalId  num_ref_pics   ref_pics  used_by_cur  LTR    Offset
+        // Interval
+        scfg = &(gop_cfg->pGopPicSpecialCfg[gop_cfg->special_size++]);
+
+        // frame type
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%s", type);
+        scfg->nonReference = 0;
+        if (strcmp(type, "I") == 0 || strcmp(type, "i") == 0)
+            scfg->codingType = VCENC_INTRA_FRAME;
+        else if (strcmp(type, "P") == 0 || strcmp(type, "p") == 0)
+            scfg->codingType = VCENC_PREDICTED_FRAME;
+        else if (strcmp(type, "B") == 0 || strcmp(type, "b") == 0)
+            scfg->codingType = VCENC_BIDIR_PREDICTED_FRAME;
+        /* P frame not for reference */
+        else if (strcmp(type, "nrefP") == 0) {
+            scfg->codingType = VCENC_PREDICTED_FRAME;
+            scfg->nonReference = 1;
+        }
+        /* B frame not for reference */
+        else if (strcmp(type, "nrefB") == 0) {
+            scfg->codingType = VCENC_BIDIR_PREDICTED_FRAME;
+            scfg->nonReference = 1;
+        } else
+            scfg->codingType = scfg->nonReference = FRAME_TYPE_RESERVED;
+
+        // qp offset
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &(scfg->QpOffset));
+
+        // qp factor
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%lf", &(scfg->QpFactor));
+        scfg->QpFactor = sqrt(scfg->QpFactor);
+
+        // temporalId factor
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &(scfg->temporalId));
+
+        // num_ref_pics
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &num_ref_pics);
+        if (num_ref_pics > VCENC_MAX_REF_FRAMES) /* NUMREFPICS_RESERVED -1 */
+        {
+            av_log(
+                NULL, AV_LOG_ERROR, "GOP Config: Error, num_ref_pic can not be more than %d \n", VCENC_MAX_REF_FRAMES);
+            return -1;
+        }
+        scfg->numRefPics = num_ref_pics;
+
+        if ((scfg->codingType == VCENC_INTRA_FRAME) && (0 == num_ref_pics)) num_ref_pics = 1;
+        // ref_pics
+        for (i = 0; i < num_ref_pics; i++) {
+            line = next_token(line);
+            if (!line) return -1;
+            if ((strncmp(line, "L", 1) == 0) || (strncmp(line, "l", 1) == 0)) {
+                sscanf(line, "%c%d", &type[0], &(scfg->refPics[i].ref_pic));
+                scfg->refPics[i].ref_pic = LONG_TERM_REF_ID2DELTAPOC(scfg->refPics[i].ref_pic - 1);
+            } else {
+                sscanf(line, "%d", &(scfg->refPics[i].ref_pic));
+            }
+        }
+        if (i < num_ref_pics) return -1;
+
+        // used_by_cur
+        for (i = 0; i < num_ref_pics; i++) {
+            line = next_token(line);
+            if (!line) return -1;
+            sscanf(line, "%u", &(scfg->refPics[i].used_by_cur));
+        }
+        if (i < num_ref_pics) return -1;
+
+        // LTR
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &scfg->i32Ltr);
+        if (VCENC_MAX_LT_REF_FRAMES < scfg->i32Ltr) return -1;
+
+        // Offset
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &scfg->i32Offset);
+
+        // Interval
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &scfg->i32Interval);
+
+        if (0 != scfg->i32Ltr) {
+            gop_cfg->u32LTR_idx[gop_cfg->ltrcnt] = LONG_TERM_REF_ID2DELTAPOC(scfg->i32Ltr - 1);
+            gop_cfg->ltrcnt++;
+            if (VCENC_MAX_LT_REF_FRAMES < gop_cfg->ltrcnt) return -1;
+        }
+
+        // short_change
+        scfg->i32short_change = 0;
+        if (0 == scfg->i32Ltr) {
+            /* not long-term ref */
+            scfg->i32short_change = 1;
+            for (i = 0; i < num_ref_pics; i++) {
+                if (IS_LONG_TERM_REF_DELTAPOC(scfg->refPics[i].ref_pic) && (0 != scfg->refPics[i].used_by_cur)) {
+                    scfg->i32short_change = 0;
+                    break;
+                }
+            }
+        }
+    } else {
+        // format: FrameN Type  POC  QPoffset    QPfactor   TemporalId  num_ref_pics  ref_pics  used_by_cur
+        cfg = &(gop_cfg->pGopPicCfg[gop_cfg->size++]);
+
+        // frame type
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%s", type);
+        cfg->nonReference = 0;
+        if (strcmp(type, "P") == 0 || strcmp(type, "p") == 0)
+            cfg->codingType = VCENC_PREDICTED_FRAME;
+        else if (strcmp(type, "B") == 0 || strcmp(type, "b") == 0)
+            cfg->codingType = VCENC_BIDIR_PREDICTED_FRAME;
+        /* P frame not for reference */
+        else if (strcmp(type, "nrefP") == 0) {
+            cfg->codingType = VCENC_PREDICTED_FRAME;
+            cfg->nonReference = 1;
+        }
+        /* B frame not for reference */
+        else if (strcmp(type, "nrefB") == 0) {
+            cfg->codingType = VCENC_BIDIR_PREDICTED_FRAME;
+            cfg->nonReference = 1;
+        } else
+            return -1;
+
+        // poc
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &poc);
+        if (poc < 1 || poc > gop_size) return -1;
+        cfg->poc = poc;
+
+        // qp offset
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &(cfg->QpOffset));
+
+        // qp factor
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%lf", &(cfg->QpFactor));
+        // sqrt(QpFactor) is used in calculating lambda
+        cfg->QpFactor = sqrt(cfg->QpFactor);
+
+        // temporalId factor
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &(cfg->temporalId));
+
+        // num_ref_pics
+        line = next_token(line);
+        if (!line) return -1;
+        sscanf(line, "%d", &num_ref_pics);
+        if (num_ref_pics < 0 || num_ref_pics > VCENC_MAX_REF_FRAMES) {
+            av_log(
+                NULL, AV_LOG_ERROR, "GOP Config: Error, num_ref_pic can not be more than %d \n", VCENC_MAX_REF_FRAMES);
+            return -1;
+        }
+
+        // ref_pics
+        for (i = 0; i < num_ref_pics; i++) {
+            line = next_token(line);
+            if (!line) return -1;
+            if ((strncmp(line, "L", 1) == 0) || (strncmp(line, "l", 1) == 0)) {
+                sscanf(line, "%c%d", &type[0], &(cfg->refPics[i].ref_pic));
+                cfg->refPics[i].ref_pic = LONG_TERM_REF_ID2DELTAPOC(cfg->refPics[i].ref_pic - 1);
+            } else {
+                sscanf(line, "%d", &(cfg->refPics[i].ref_pic));
+            }
+        }
+        if (i < num_ref_pics) return -1;
+
+        // used_by_cur
+        for (i = 0; i < num_ref_pics; i++) {
+            line = next_token(line);
+            if (!line) return -1;
+            sscanf(line, "%u", &(cfg->refPics[i].used_by_cur));
+        }
+        if (i < num_ref_pics) return -1;
+
+        cfg->numRefPics = num_ref_pics;
+    }
+
+    return 0;
+}
+
+static int parse_gop_config_file(int gop_size, char *fname, VCEncGopConfig *gop_cfg) {
+#define MAX_LINE_LENGTH 1024
+    int frame_idx = 0, line_idx = 0, add_tmp;
+    char ach_parser_buffer[MAX_LINE_LENGTH];
+    FILE *fIn = fopen(fname, "r");
+    if (fIn == NULL) {
+        av_log(NULL, AV_LOG_ERROR, "GOP Config: Error, Can Not Open File %s\n", fname);
+        return -1;
+    }
+
+    while (0 == feof(fIn)) {
+        char *line;
+        char *s;
+        if (feof(fIn)) break;
+        line_idx++;
+        ach_parser_buffer[0] = '\0';
+        // Read one line
+        line = fgets((char *)ach_parser_buffer, MAX_LINE_LENGTH, fIn);
+        if (!line) break;
+        // handle line end
+        s = strpbrk(line, "#\n");
+        if (s) *s = '\0';
+
+        add_tmp = 1;
+        line = strstr(line, "Frame");
+        if (line) {
+            if (0 == strncmp(line, "Frame0", 6)) add_tmp = 0;
+
+            if (parse_gop_config_string(line, gop_cfg, frame_idx, gop_size) < 0) {
+                av_log(NULL, AV_LOG_ERROR, "Invalid gop configure!\n");
+                return -1;
+            }
+
+            frame_idx += add_tmp;
+        }
+    }
+
+    fclose(fIn);
+    if (frame_idx != gop_size) {
+        av_log(NULL, AV_LOG_ERROR, "GOP Config: Error, Parsing File %s Failed at Line %d\n", fname, line_idx);
+        return -1;
+    }
+    return 0;
+}
+
+static int read_gop_config(char *fname, char **config, VCEncGopConfig *gop_cfg, int gop_size, uint8_t *gop_cfg_offset) {
+    int ret = -1;
+
+    if (gop_cfg->size >= MAX_GOP_PIC_CONFIG_NUM) return -1;
+
+    if (gop_cfg_offset) gop_cfg_offset[gop_size] = gop_cfg->size;
+    if (fname) {
+        ret = parse_gop_config_file(gop_size, fname, gop_cfg);
+    } else if (config) {
+        int id = 0;
+        while (config[id]) {
+            parse_gop_config_string(config[id], gop_cfg, id, gop_size);
+            id++;
+        }
+        ret = 0;
+    }
+    return ret;
+}
+
+int ff_init_gop_configs(int gopSize,
+                        ESEncVidContext *options,
+                        VCEncGopConfig *gopCfg,
+                        uint8_t *gopCfgOffset,
+                        bool bPass2,
+                        uint32_t hwId) {
+    int i, pre_load_num;
+    char *fname = options->gop_cfg;
+    VCEncGopPicConfig *cfgStart = NULL;
+
+    uint32_t singleRefForP =
+        (options->lookahead_depth && !bPass2) || (options->num_refP == 1);  // not enable multiref for P in pass-1
+
+    const char **rpsDefaultGop1 = singleRefForP ? RpsDefault_GOPSize_1 : Rps_2RefForP_GOPSize_1;
+    if (IS_H264(options->codec_format))
+        rpsDefaultGop1 = singleRefForP ? RpsDefault_H264_GOPSize_1 : Rps_2RefForP_H264_GOPSize_1;
+    else if (HW_PRODUCT_SYSTEM60(hwId) || HW_PRODUCT_VC9000LE(hwId))
+        rpsDefaultGop1 = RpsDefault_V60_GOPSize_1;
+
+    const char **default_configs[16] = {options->gop_lowdelay ? RpsLowdelayDefault_GOPSize_1 : rpsDefaultGop1,
+                                        options->gop_lowdelay ? RpsLowdelayDefault_GOPSize_2
+                                        : singleRefForP       ? RpsDefault_GOPSize_2
+                                                              : Rps_2RefForP_GOPSize_2,
+                                        options->gop_lowdelay ? RpsLowdelayDefault_GOPSize_3
+                                        : singleRefForP       ? RpsDefault_GOPSize_3
+                                                              : Rps_2RefForP_GOPSize_3,
+                                        options->gop_lowdelay ? RpsLowdelayDefault_GOPSize_4
+                                        : singleRefForP       ? RpsDefault_GOPSize_4
+                                                              : Rps_2RefForP_GOPSize_4,
+                                        singleRefForP ? RpsDefault_GOPSize_5 : Rps_2RefForP_GOPSize_5,
+                                        singleRefForP ? RpsDefault_GOPSize_6 : Rps_2RefForP_GOPSize_6,
+                                        singleRefForP ? RpsDefault_GOPSize_7 : Rps_2RefForP_GOPSize_7,
+                                        singleRefForP ? RpsDefault_GOPSize_8 : Rps_2RefForP_GOPSize_8,
+                                        NULL,
+                                        NULL,
+                                        NULL,
+                                        NULL,
+                                        NULL,
+                                        NULL,
+                                        NULL,
+                                        RpsDefault_GOPSize_16};
+
+    if (gopSize < 0 || gopSize > MAX_GOP_SIZE
+        || (gopSize > 0 && default_configs[gopSize - 1] == NULL && fname == NULL)) {
+        av_log(NULL, AV_LOG_ERROR, "GOP Config: Error, Invalid GOP Size\n");
+        return -1;
+    }
+
+    // use lowdelay B for pass2 only if multi-reference is not support.
+    if (bPass2 && (options->num_refP == 1)) {
+        default_configs[1] = RpsPass2_GOPSize_2;
+        default_configs[3] = RpsPass2_GOPSize_4;
+        default_configs[7] = RpsPass2_GOPSize_8;
+    }
+
+    // Handle Interlace
+    if (options->interlaced_frame && gopSize == 1) {
+        default_configs[0] = RpsDefault_Interlace_GOPSize_1;
+    }
+
+    // GOP size in rps array for gopSize=N
+    // N<=4:      GOP1, ..., GOPN
+    // 4<N<=8:    GOP1, GOP2, GOP3, GOP4, GOPN
+    // N > 8:     GOP1, GOP2, GOP3, GOP4, GOPN
+    // Adaptive:  GOP1, GOP2, GOP3, GOP4, GOP6, GOP8
+    if (gopSize > 8)
+        pre_load_num = 4;
+    else if (gopSize >= 4 || gopSize == 0)
+        pre_load_num = 4;
+    else
+        pre_load_num = gopSize;
+
+    gopCfg->special_size = 0;
+    gopCfg->ltrcnt = 0;
+
+    for (i = 1; i <= pre_load_num; i++) {
+        if (read_gop_config(gopSize == i ? fname : NULL, (char **)default_configs[i - 1], gopCfg, i, gopCfgOffset))
+            return -1;
+    }
+
+    if (gopSize == 0) {
+        // gop6
+        if (read_gop_config(NULL, (char **)default_configs[5], gopCfg, 6, gopCfgOffset)) return -1;
+        // gop8
+        if (read_gop_config(NULL, (char **)default_configs[7], gopCfg, 8, gopCfgOffset)) return -1;
+    } else if (gopSize > 4) {
+        // gopSize
+        if (read_gop_config(fname, (char **)default_configs[gopSize - 1], gopCfg, gopSize, gopCfgOffset)) return -1;
+    }
+
+    if ((DEFAULT != options->ltr_interval) && (gopCfg->special_size == 0)) {
+        if (options->gop_size != 1) {
+            av_log(NULL,
+                   AV_LOG_ERROR,
+                   "GOP Config: Error, when using --LTR configure option, the gopsize alse should be set to 1!\n");
+            return -1;
+        }
+        gopCfg->pGopPicSpecialCfg[0].poc = 0;
+        gopCfg->pGopPicSpecialCfg[0].QpOffset = options->long_term_qp_delta;
+        gopCfg->pGopPicSpecialCfg[0].QpFactor = QPFACTOR_RESERVED;
+        gopCfg->pGopPicSpecialCfg[0].temporalId = TEMPORALID_RESERVED;
+        gopCfg->pGopPicSpecialCfg[0].codingType = FRAME_TYPE_RESERVED;
+        gopCfg->pGopPicSpecialCfg[0].numRefPics = NUMREFPICS_RESERVED;
+        gopCfg->pGopPicSpecialCfg[0].i32Ltr = 1;
+        gopCfg->pGopPicSpecialCfg[0].i32Offset = 0;
+        gopCfg->pGopPicSpecialCfg[0].i32Interval = options->ltr_interval;
+        gopCfg->pGopPicSpecialCfg[0].i32short_change = 0;
+        gopCfg->u32LTR_idx[0] = LONG_TERM_REF_ID2DELTAPOC(0);
+
+        gopCfg->pGopPicSpecialCfg[1].poc = 0;
+        gopCfg->pGopPicSpecialCfg[1].QpOffset = QPOFFSET_RESERVED;
+        gopCfg->pGopPicSpecialCfg[1].QpFactor = QPFACTOR_RESERVED;
+        gopCfg->pGopPicSpecialCfg[1].temporalId = TEMPORALID_RESERVED;
+        gopCfg->pGopPicSpecialCfg[1].codingType = FRAME_TYPE_RESERVED;
+        gopCfg->pGopPicSpecialCfg[1].numRefPics = 2;
+        gopCfg->pGopPicSpecialCfg[1].refPics[0].ref_pic = -1;
+        gopCfg->pGopPicSpecialCfg[1].refPics[0].used_by_cur = 1;
+        gopCfg->pGopPicSpecialCfg[1].refPics[1].ref_pic = LONG_TERM_REF_ID2DELTAPOC(0);
+        gopCfg->pGopPicSpecialCfg[1].refPics[1].used_by_cur = 1;
+        gopCfg->pGopPicSpecialCfg[1].i32Ltr = 0;
+        gopCfg->pGopPicSpecialCfg[1].i32Offset = options->long_term_gap_offset;
+        gopCfg->pGopPicSpecialCfg[1].i32Interval = options->long_term_gap;
+        gopCfg->pGopPicSpecialCfg[1].i32short_change = 0;
+
+        gopCfg->special_size = 2;
+        gopCfg->ltrcnt = 1;
+    }
+
+    CLIENT_TYPE client_type = IS_H264(options->codec_format) ? EWL_CLIENT_TYPE_H264_ENC : EWL_CLIENT_TYPE_HEVC_ENC;
+    u32 hw_id = EncAsicGetAsicHWid(client_type, NULL);
+    if (0) {
+        for (i = 0; i < (gopSize == 0 ? gopCfg->size : gopCfgOffset[gopSize]); i++) {
+            // when use long-term, change P to B in default configs (used for last gop)
+            VCEncGopPicConfig *cfg = &(gopCfg->pGopPicCfg[i]);
+            if (cfg->codingType == VCENC_PREDICTED_FRAME) cfg->codingType = VCENC_BIDIR_PREDICTED_FRAME;
+        }
+    }
+
+    /* 6.0 software: merge */
+    if (hw_id < 0x80006010 && IS_H264(options->codec_format) && gopCfg->ltrcnt > 0) {
+        av_log(NULL, AV_LOG_ERROR, "GOP Config: Error, H264 LTR not supported before 6.0.10!\n");
+        return -1;
+    }
+
+    // Compatible with old bFrameQpDelta setting
+    if (options->b_frame_qp_delta >= 0 && fname == NULL) {
+        for (i = 0; i < gopCfg->size; i++) {
+            VCEncGopPicConfig *cfg = &(gopCfg->pGopPicCfg[i]);
+            if (cfg->codingType == VCENC_BIDIR_PREDICTED_FRAME) cfg->QpOffset = options->b_frame_qp_delta;
+        }
+    }
+
+    // lowDelay auto detection
+    cfgStart = &(gopCfg->pGopPicCfg[gopCfgOffset[gopSize]]);
+    if (gopSize == 1) {
+        options->gop_lowdelay = 1;
+    } else if ((gopSize > 1) && (options->gop_lowdelay == 0)) {
+        options->gop_lowdelay = 1;
+        for (i = 1; i < gopSize; i++) {
+            if (cfgStart[i].poc < cfgStart[i - 1].poc) {
+                options->gop_lowdelay = 0;
+                break;
+            }
+        }
+    }
+
+#ifdef INTERNAL_TEST
+    if ((options->testId == TID_POC && gopSize == 1) && !IS_H264(options->codecFormat) && !IS_AV1(options->codecFormat)
+        && !IS_VP9(options->codecFormat)) {
+        VCEncGopPicConfig *cfg = &(gopCfg->pGopPicCfg[0]);
+        if (cfg->numRefPics == 2) cfg->refPics[1].ref_pic = -(options->intraPicRate - 1);
+    }
+#endif
+
+    {
+        i32 i32LtrPoc[VCENC_MAX_LT_REF_FRAMES];
+        i32 i32LtrIndex = 0;
+
+        for (i = 0; i < VCENC_MAX_LT_REF_FRAMES; i++) i32LtrPoc[i] = -1;
+        for (i = 0; i < gopCfg->special_size; i++) {
+            if (gopCfg->pGopPicSpecialCfg[i].i32Ltr > VCENC_MAX_LT_REF_FRAMES) {
+                av_log(NULL, AV_LOG_ERROR, "GOP Config: Error, Invalid long-term index\n");
+                return -1;
+            }
+            if (gopCfg->pGopPicSpecialCfg[i].i32Ltr > 0) {
+                i32LtrPoc[i32LtrIndex] = gopCfg->pGopPicSpecialCfg[i].i32Ltr - 1;
+                i32LtrIndex++;
+            }
+        }
+
+        for (i = 0; i < gopCfg->ltrcnt; i++) {
+            if ((0 != i32LtrPoc[0]) || (-1 == i32LtrPoc[i]) || ((i > 0) && i32LtrPoc[i] != (i32LtrPoc[i - 1] + 1))) {
+                av_log(NULL, AV_LOG_ERROR, "GOP Config: Error, Invalid long-term index\n");
+                return -1;
+            }
+        }
+    }
+
+    // For lowDelay, Handle the first few frames that miss reference frame
+    if (1) {
+        int nGop;
+        int idx = 0;
+        int maxErrFrame = 0;
+        VCEncGopPicConfig *cfg;
+
+        // Find the max frame number that will miss its reference frame defined in rps
+        while ((idx - maxErrFrame) < gopSize) {
+            nGop = (idx / gopSize) * gopSize;
+            cfg = &(cfgStart[idx % gopSize]);
+
+            for (i = 0; i < cfg->numRefPics; i++) {
+                // POC of this reference frame
+                int refPoc = cfg->refPics[i].ref_pic + cfg->poc + nGop;
+                if (refPoc < 0) {
+                    maxErrFrame = idx + 1;
+                }
+            }
+            idx++;
+        }
+
+        // Try to config a new rps for each "error" frame by modifying its original rps
+        for (idx = 0; idx < maxErrFrame; idx++) {
+            int j, iRef, nRefsUsedByCur, nPoc;
+            VCEncGopPicConfig *cfgCopy;
+
+            if (gopCfg->size >= MAX_GOP_PIC_CONFIG_NUM) break;
+
+            // Add to array end
+            cfg = &(gopCfg->pGopPicCfg[gopCfg->size]);
+            cfgCopy = &(cfgStart[idx % gopSize]);
+            memcpy(cfg, cfgCopy, sizeof(VCEncGopPicConfig));
+            gopCfg->size++;
+
+            // Copy reference pictures
+            nRefsUsedByCur = iRef = 0;
+            nPoc = cfgCopy->poc + ((idx / gopSize) * gopSize);
+            for (i = 0; i < cfgCopy->numRefPics; i++) {
+                int newRef = 1;
+                int used_by_cur = cfgCopy->refPics[i].used_by_cur;
+                int ref_pic = cfgCopy->refPics[i].ref_pic;
+                // Clip the reference POC
+                if ((cfgCopy->refPics[i].ref_pic + nPoc) < 0) ref_pic = 0 - (nPoc);
+
+                // Check if already have this reference
+                for (j = 0; j < iRef; j++) {
+                    if (cfg->refPics[j].ref_pic == ref_pic) {
+                        newRef = 0;
+                        if (used_by_cur) cfg->refPics[j].used_by_cur = used_by_cur;
+                        break;
+                    }
+                }
+
+                // Copy this reference
+                if (newRef) {
+                    cfg->refPics[iRef].ref_pic = ref_pic;
+                    cfg->refPics[iRef].used_by_cur = used_by_cur;
+                    iRef++;
+                }
+            }
+            cfg->numRefPics = iRef;
+            // If only one reference frame, set P type.
+            for (i = 0; i < cfg->numRefPics; i++) {
+                if (cfg->refPics[i].used_by_cur) nRefsUsedByCur++;
+            }
+            if (nRefsUsedByCur == 1) cfg->codingType = VCENC_PREDICTED_FRAME;
+        }
+    }
+
+#if 1
+    // print for debug
+    int idx;
+    av_log(NULL, AV_LOG_INFO, "====== REF PICTURE SETS from %s ======\n", fname ? fname : "DEFAULT");
+    for (idx = 0; idx < gopCfg->size; idx++) {
+        int i;
+        VCEncGopPicConfig *cfg = &(gopCfg->pGopPicCfg[idx]);
+        char type = cfg->codingType == VCENC_PREDICTED_FRAME ? 'P' : cfg->codingType == VCENC_INTRA_FRAME ? 'I' : 'B';
+        av_log(NULL,
+               AV_LOG_INFO,
+               " FRAME%2d:  %c %d %d %f %d",
+               idx,
+               type,
+               cfg->poc,
+               cfg->QpOffset,
+               cfg->QpFactor,
+               cfg->numRefPics);
+        for (i = 0; i < cfg->numRefPics; i++) av_log(NULL, AV_LOG_INFO, " %d", cfg->refPics[i].ref_pic);
+        for (i = 0; i < cfg->numRefPics; i++) av_log(NULL, AV_LOG_INFO, " %d", cfg->refPics[i].used_by_cur);
+        av_log(NULL, AV_LOG_INFO, "\n");
+    }
+    av_log(NULL, AV_LOG_INFO, "===========================================\n");
+#endif
+    return 0;
+}
+
+/*------------------------------------------------------------------------------
+
+ read_user_data
+ Read user data from file and pass to encoder
+
+ Params:
+ name - name of file in which user data is located
+
+ Returns:
+ NULL - when user data reading failed
+ pointer - allocated buffer containing user data
+
+ ------------------------------------------------------------------------------*/
+uint8_t *ff_read_user_data(VCEncInst encoder, char *name) {
+    FILE *file = NULL;
+    int32_t byte_cnt;
+    uint8_t *data;
+
+    if (name == NULL) return NULL;
+
+    if (strcmp("0", name) == 0) return NULL;
+
+    /* Get user data length from FILE */
+    file = fopen(name, "rb");
+    if (file == NULL) {
+        av_log(NULL, AV_LOG_ERROR, "Unable to open User Data file: %s\n", name);
+        return NULL;
+    }
+    fseeko(file, 0L, SEEK_END);
+    byte_cnt = ftell(file);
+    rewind(file);
+
+    /* Minimum size of user data */
+    if (byte_cnt < 16) byte_cnt = 16;
+
+    /* Maximum size of user data */
+    if (byte_cnt > 2048) byte_cnt = 2048;
+    /* Allocate memory for user data */
+    if ((data = (uint8_t *)malloc(sizeof(uint8_t) * byte_cnt)) == NULL) {
+        fclose(file);
+        av_log(NULL, AV_LOG_ERROR, "Unable to alloc User Data memory\n");
+        return NULL;
+    }
+
+    /* Read user data from FILE */
+    fread(data, sizeof(uint8_t), byte_cnt, file);
+    fclose(file);
+
+    av_log(NULL, AV_LOG_ERROR, "User data: %d bytes [%d %d %d %d ...]\n", byte_cnt, data[0], data[1], data[2], data[3]);
+    /* Pass the data buffer to encoder
+     * The encoder reads the buffer during following VCEncStrmEncode() calls.
+     * User data writing must be disabled (with VCEncSetSeiUserData(enc, 0, 0)) */
+    VCEncSetSeiUserData(encoder, data, byte_cnt);
+
+    return data;
+}
+
+/*------------------------------------------------------------------------------
+ Calculate average bitrate of moving window
+ ------------------------------------------------------------------------------*/
+int32_t ff_ma(Ma *ma) {
+    int32_t i;
+    unsigned long long sum = 0; /* Using 64-bits to avoid overflow */
+
+    for (i = 0; i < ma->count; i++) sum += ma->frame[i];
+
+    if (!ma->frame_rate_denom) return 0;
+
+    sum = sum / ma->count;
+
+    return sum * (ma->frame_rate_numer + ma->frame_rate_denom - 1) / ma->frame_rate_denom;
+}
+
+void ff_ma_add_frame(Ma *ma, int32_t frame_size_bits) {
+    ma->frame[ma->pos++] = frame_size_bits;
+
+    if (ma->pos == ma->length) ma->pos = 0;
+
+    if (ma->count < ma->length) ma->count++;
+}
+
+static int32_t adaptive_gop_decision(
+    ESEncVidInternalContext *in_ctx, VCEncIn *p_enc_in, VCEncInst encoder, int32_t *next_gop_size, AdapGopCtr *agop) {
+    int32_t gop_size = -1;
+
+    struct vcenc_instance *vcenc_instance = (struct vcenc_instance *)encoder;
+    unsigned int ui_intra_cu8_num = vcenc_instance->asic.regs.intraCu8Num;
+    unsigned int ui_skip_cu8_num = vcenc_instance->asic.regs.skipCu8Num;
+    unsigned int ui_pb_frame_cost = vcenc_instance->asic.regs.PBFrame4NRdCost;
+    double d_intra_vs_inter_skip = (double)ui_intra_cu8_num / (double)((in_ctx->width / 8) * (in_ctx->height / 8));
+    double d_skip_vs_inter_skip = (double)ui_skip_cu8_num / (double)((in_ctx->width / 8) * (in_ctx->height / 8));
+
+    agop->gop_frm_num++;
+    agop->sum_intra_vs_interskip += d_intra_vs_inter_skip;
+    agop->sum_skip_vs_interskip += d_skip_vs_inter_skip;
+    agop->sum_costP += (p_enc_in->codingType == VCENC_PREDICTED_FRAME) ? ui_pb_frame_cost : 0;
+    agop->sum_costB += (p_enc_in->codingType == VCENC_BIDIR_PREDICTED_FRAME) ? ui_pb_frame_cost : 0;
+    agop->sum_intra_vs_interskipP += (p_enc_in->codingType == VCENC_PREDICTED_FRAME) ? d_intra_vs_inter_skip : 0;
+    agop->sum_intra_vs_interskipB += (p_enc_in->codingType == VCENC_BIDIR_PREDICTED_FRAME) ? d_intra_vs_inter_skip : 0;
+
+    if (p_enc_in->gopPicIdx
+        == p_enc_in->gopSize - 1) {  // last frame of the current gop. decide the gopsize of next gop.
+        d_intra_vs_inter_skip = agop->sum_intra_vs_interskip / agop->gop_frm_num;
+        d_skip_vs_inter_skip = agop->sum_skip_vs_interskip / agop->gop_frm_num;
+        agop->sum_costB = (agop->gop_frm_num > 1) ? (agop->sum_costB / (agop->gop_frm_num - 1)) : 0xFFFFFFF;
+        agop->sum_intra_vs_interskipB =
+            (agop->gop_frm_num > 1) ? (agop->sum_intra_vs_interskipB / (agop->gop_frm_num - 1)) : 0xFFFFFFF;
+        // Enabled adaptive GOP size for large resolution
+        if (((in_ctx->width * in_ctx->height) >= (1280 * 720))
+            || ((MAX_ADAPTIVE_GOP_SIZE > 3) && ((in_ctx->width * in_ctx->height) >= (416 * 240)))) {
+            if ((((double)agop->sum_costP / (double)agop->sum_costB) < 1.1) && (d_skip_vs_inter_skip >= 0.95)) {
+                agop->last_gop_size = gop_size = 1;
+            } else if (((double)agop->sum_costP / (double)agop->sum_costB) > 5) {
+                gop_size = agop->last_gop_size;
+            } else {
+                if (((agop->sum_intra_vs_interskipP > 0.40) && (agop->sum_intra_vs_interskipP < 0.70)
+                     && (agop->sum_intra_vs_interskipB < 0.10))) {
+                    agop->last_gop_size++;
+                    if (agop->last_gop_size == 5 || agop->last_gop_size == 7) agop->last_gop_size++;
+                    agop->last_gop_size = MIN(agop->last_gop_size, MAX_ADAPTIVE_GOP_SIZE);
+                    gop_size = agop->last_gop_size;  //
+                } else if (d_intra_vs_inter_skip >= 0.30) {
+                    agop->last_gop_size = gop_size = 1;  // No B
+                } else if (d_intra_vs_inter_skip >= 0.20) {
+                    agop->last_gop_size = gop_size = 2;  // One B
+                } else if (d_intra_vs_inter_skip >= 0.10) {
+                    agop->last_gop_size--;
+                    if (agop->last_gop_size == 5 || agop->last_gop_size == 7) agop->last_gop_size--;
+                    agop->last_gop_size = MAX(agop->last_gop_size, 3);
+                    gop_size = agop->last_gop_size;  //
+                } else {
+                    agop->last_gop_size++;
+                    if (agop->last_gop_size == 5 || agop->last_gop_size == 7) agop->last_gop_size++;
+                    agop->last_gop_size = MIN(agop->last_gop_size, MAX_ADAPTIVE_GOP_SIZE);
+                    gop_size = agop->last_gop_size;  //
+                }
+            }
+        } else {
+            gop_size = 3;
+        }
+        agop->gop_frm_num = 0;
+        agop->sum_intra_vs_interskip = 0;
+        agop->sum_skip_vs_interskip = 0;
+        agop->sum_costP = 0;
+        agop->sum_costB = 0;
+        agop->sum_intra_vs_interskipP = 0;
+        agop->sum_intra_vs_interskipB = 0;
+
+        gop_size = MIN(gop_size, MAX_ADAPTIVE_GOP_SIZE);
+    }
+
+    if (gop_size != -1) *next_gop_size = gop_size;
+
+    return gop_size;
+}
+
+int32_t ff_get_next_gop_size(
+    ESEncVidInternalContext *in_ctx, VCEncIn *p_enc_in, VCEncInst encoder, int32_t *next_gop_size, AdapGopCtr *agop) {
+    struct vcenc_instance *vcenc_instance = (struct vcenc_instance *)encoder;
+#ifndef ESW_FF_ENHANCEMENT
+    if (vcenc_instance->lookaheadDepth) {
+        int32_t upd_gop = getPass1UpdatedGopSize(vcenc_instance->lookahead.priv_inst);
+        if (upd_gop) *next_gop_size = upd_gop;
+    } else if (p_enc_in->codingType != VCENC_INTRA_FRAME) {
+        adaptive_gop_decision(in_ctx, p_enc_in, encoder, next_gop_size, agop);
+    }
+#endif
+    return *next_gop_size;
+}
+
+#if defined(SUPPORT_DEC400) || defined(SUPPORT_TCACHE)
+#ifndef ESW_FF_ENHANCEMENT
+#include "fb_ips.h"
+#include "dec400_f2_api.h"
+#include "tcache_api.h"
+#include "trans_edma_api.h"
+#include "dtrc_api.h"
+#include "l2cache_api.h"
+#endif
+#define VCE_HEIGHT_ALIGNMENT 64
+#define VCE_INPUT_ALIGNMENT 32
+#endif
+
+int32_t ff_change_format_for_fb(ESEncVidInternalContext *in_ctx,
+                                ESEncVidContext *options,
+                                VCEncPreProcessingCfg *pre_proc_cfg) {
+    switch (options->input_format) {
+#ifdef SUPPORT_DEC400
+        // for dec400
+#ifndef ESW_FF_ENHANCEMENT
+        case INPUT_FORMAT_YUV420_SEMIPLANAR_8BIT_COMPRESSED_FB:
+            pre_proc_cfg->inputType = VCENC_YUV420_SEMIPLANAR_8BIT_FB;
+            pre_proc_cfg->input_alignment = 1024;
+            break;
+        case INPUT_FORMAT_YUV420_SEMIPLANAR_VU_8BIT_COMPRESSED_FB:
+            pre_proc_cfg->inputType = VCENC_YUV420_SEMIPLANAR_VU_8BIT_FB;
+            pre_proc_cfg->input_alignment = 1024;
+            break;
+        case INPUT_FORMAT_YUV420_PLANAR_10BIT_P010_COMPRESSED_FB:
+            pre_proc_cfg->inputType = VCENC_YUV420_PLANAR_10BIT_P010_FB;
+            pre_proc_cfg->input_alignment = 1024;
+            break;
+#endif
+#endif
+#ifdef SUPPORT_TCACHE
+        // for tcache
+        case VCENC_YUV420_PLANAR:
+        case VCENC_YUV420_SEMIPLANAR:
+        case VCENC_YUV420_SEMIPLANAR_VU:
+        case INPUT_FORMAT_YUV422P:
+        case INPUT_FORMAT_YUV444P:
+        case INPUT_FORMAT_RFC_8BIT_COMPRESSED_FB:
+            pre_proc_cfg->inputType = VCENC_YUV420_SEMIPLANAR;
+            pre_proc_cfg->input_alignment = 32;
+            break;
+        case VCENC_YUV420_PLANAR_10BIT_P010: /*this is semiplaner P010LE*/
+        case INPUT_FORMAT_YUV420_SEMIPLANAR_10BIT_P010BE:
+        case INPUT_FORMAT_YUV420_PLANAR_10BIT_P010BE:
+        case INPUT_FORMAT_YUV420_PLANAR_10BIT_P010LE:
+        case INPUT_FORMAT_YUV422P10LE:
+        case INPUT_FORMAT_YUV422P10BE:
+        case INPUT_FORMAT_RFC_10BIT_COMPRESSED_FB:
+            pre_proc_cfg->inputType = VCENC_YUV420_PLANAR_10BIT_P010;
+            pre_proc_cfg->input_alignment = 32;
+            break;
+        case INPUT_FORMAT_ARGB_FB:
+        case INPUT_FORMAT_ABGR_FB:
+        case INPUT_FORMAT_BGRA_FB:
+        case INPUT_FORMAT_RGBA_FB:
+        case INPUT_FORMAT_BGR24_FB:
+        case INPUT_FORMAT_RGB24_FB:
+            pre_proc_cfg->inputType =
+                (options->bit_depth_luma == 10) ? VCENC_YUV420_PLANAR_10BIT_P010 : VCENC_YUV420_SEMIPLANAR;
+            pre_proc_cfg->input_alignment = 32;
+            break;
+#else
+        case VCENC_YUV420_SEMIPLANAR:
+        case VCENC_YUV420_PLANAR_10BIT_P010:
+            // don't change
+            break;
+#endif
+#ifndef ESW_FF_ENHANCEMENT
+        case INPUT_FORMAT_PP_YUV420_SEMIPLANNAR:
+        case INPUT_FORMAT_PP_YUV420_SEMIPLANNAR_VU:
+            pre_proc_cfg->inputType = VCENC_YUV420_SEMIPLANAR;
+            // pre_proc_cfg->input_alignment = 32; //depend on the options option
+            break;
+        case INPUT_FORMAT_PP_YUV420_PLANAR_10BIT_P010:
+            pre_proc_cfg->inputType = VCENC_YUV420_PLANAR_10BIT_P010;
+            pre_proc_cfg->input_alignment = 32;
+            break;
+#endif
+        default:
+            break;
+    }
+    av_log(NULL,
+           AV_LOG_DEBUG,
+           "::::: format %d -> %d, input alignment change to %d\n",
+           options->input_format,
+           pre_proc_cfg->inputType,
+           pre_proc_cfg->input_alignment);
+    return 0;
+}
+
+FILE *ff_format_customized_yuv(ESEncVidInternalContext *in_ctx, ESEncVidContext *options) {
+    if ((options->format_customized_type == 1)
+        && ((options->input_format == VCENC_YUV420_SEMIPLANAR) || (options->input_format == VCENC_YUV420_SEMIPLANAR_VU)
+            || (options->input_format == VCENC_YUV420_PLANAR_10BIT_P010)))
+        trans_yuv_to_fb_format(in_ctx, options);
+    return NULL;
+}
+
+void ff_init_slice_ctl(ESEncVidInternalContext *in_ctx, ESEncVidContext *options) {
+    int i;
+    for (i = 0; i < MAX_CORE_NUM; i++) {
+        in_ctx->slice_ctl_factory[i].multislice_encoding =
+            (options->slice_size != 0 && (((options->height + 63) / 64) > options->slice_size)) ? 1 : 0;
+        in_ctx->slice_ctl_factory[i].output_byte_stream = options->byte_stream ? 1 : 0;
+        in_ctx->slice_ctl_factory[i].out_stream_file = in_ctx->out;
+        in_ctx->slice_ctl_factory[i].stream_pos = 0;
+    }
+}
+
+void ff_init_stream_segment_ctl(ESEncVidInternalContext *in_ctx, ESEncVidContext *options) {
+    in_ctx->stream_seg_ctl.stream_rd_counter = 0;
+    in_ctx->stream_seg_ctl.stream_multi_seg_en = options->stream_multi_segment_mode != 0;
+#ifdef USE_OLD_DRV
+    in_ctx->stream_seg_ctl.stream_base = (uint8_t *)in_ctx->outbuf_mem_factory[0][0].virtualAddress;
+#else
+    in_ctx->stream_seg_ctl.stream_base = (uint8_t *)in_ctx->outbuf_mem_factory[0][0].virtualAddress;
+#endif
+
+    if (in_ctx->stream_seg_ctl.stream_multi_seg_en) {
+        in_ctx->stream_seg_ctl.segment_size =
+            in_ctx->outbuf_mem_factory[0][0].size / options->stream_multi_segment_amount;
+        in_ctx->stream_seg_ctl.segment_size =
+            ((in_ctx->stream_seg_ctl.segment_size + 16 - 1) & (~(16 - 1)));  // segment size must be aligned to 16byte
+        in_ctx->stream_seg_ctl.segment_amount = options->stream_multi_segment_amount;
+    }
+    in_ctx->stream_seg_ctl.start_code_done = 0;
+    in_ctx->stream_seg_ctl.output_byte_stream = in_ctx->byte_stream;
+    in_ctx->stream_seg_ctl.out_stream_file = in_ctx->out;
+}
+
+void ff_setup_slice_ctl(ESEncVidInternalContext *in_ctx) {
+    // find transform buffer of multi-cores
+    in_ctx->slice_ctl = &(in_ctx->slice_ctl_factory[in_ctx->picture_enc_cnt % in_ctx->parallel_core_num]);
+    in_ctx->slice_ctl_out = &(in_ctx->slice_ctl_factory[(in_ctx->picture_enc_cnt + 1) % in_ctx->parallel_core_num]);
+}
+
+// Helper function to calculate time diffs.
+unsigned int ff_utime_diff(struct timeval end, struct timeval start) {
+    return (end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec);
+}
diff --git a/libavcodec/esenc_vid_internal.h b/libavcodec/esenc_vid_internal.h
new file mode 100644
index 0000000000..e1b958edfd
--- /dev/null
+++ b/libavcodec/esenc_vid_internal.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ESENC_VIDEO_INTERNAL_H
+#define AVCODEC_ESENC_VIDEO_INTERNAL_H
+
+#include "esenc_vid.h"
+
+void ff_change_to_customized_format(ESEncVidContext *options, VCEncPreProcessingCfg *pre_proc_cfg);
+
+void ff_change_cml_customized_format(ESEncVidContext *options);
+
+int32_t ff_read_gmv(ESEncVidInternalContext *tb, VCEncIn *pEncIn, ESEncVidContext *options);
+
+uint64_t ff_next_picture(ESEncVidInternalContext *tb, int picture_cnt);
+
+int ff_init_gop_configs(int gopSize,
+                        ESEncVidContext *options,
+                        VCEncGopConfig *gopCfg,
+                        uint8_t *gopCfgOffset,
+                        bool bPass2,
+                        uint32_t hwId);
+
+uint8_t *ff_read_user_data(VCEncInst encoder, char *name);
+
+void ff_ma_add_frame(Ma *ma, int32_t frame_size_bits);
+
+int32_t ff_ma(Ma *ma);
+
+int32_t ff_get_next_gop_size(
+    ESEncVidInternalContext *tb, VCEncIn *pEncIn, VCEncInst encoder, int32_t *pnextgopsize, AdapGopCtr *agop);
+
+int32_t ff_change_format_for_fb(ESEncVidInternalContext *tb,
+                                ESEncVidContext *options,
+                                VCEncPreProcessingCfg *pre_proc_cfg);
+
+FILE *ff_format_customized_yuv(ESEncVidInternalContext *tb, ESEncVidContext *options);
+
+void ff_init_slice_ctl(ESEncVidInternalContext *tb, ESEncVidContext *options);
+
+void ff_init_stream_segment_ctl(ESEncVidInternalContext *tb, ESEncVidContext *options);
+
+void ff_setup_slice_ctl(ESEncVidInternalContext *tb);
+
+unsigned int ff_utime_diff(struct timeval end, struct timeval start);
+
+#endif
diff --git a/libavcodec/esjdecapi.c b/libavcodec/esjdecapi.c
new file mode 100644
index 0000000000..f7e73da6c9
--- /dev/null
+++ b/libavcodec/esjdecapi.c
@@ -0,0 +1,2252 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "esjdecapi.h"
+#include "jpegdecapi.h"
+#include "libavutil/hwcontext_es.h"
+#include "esqueue.h"
+#include "esdecbuffer.h"
+#include "esdec_internal.h"
+#include "esdec_wrapper.h"
+
+#ifdef MODEL_SIMULATION
+#include <deccfg.h>
+extern u32 g_hw_build_id;
+extern u32 g_hw_id;
+extern u32 g_hw_ver;
+#endif
+
+static void report_dec_pic_info( JDECContext *dec_ctx,  struct DecPicture *picture)
+{
+    char info_string[2048];
+    static const char* pic_types[] = {"        IDR", "Non-IDR (P)", "Non-IDR (B)"};
+
+    log_debug(dec_ctx, "PIC %2d/%2d, type %s, ",
+                              dec_ctx->pic_display_number,
+                              picture->picture_info.pic_id,
+                              picture->picture_info.pic_coding_type);
+    if (picture->picture_info.cycles_per_mb) {
+        log_debug(dec_ctx,
+                              " %4d cycles / mb,",
+                              picture->picture_info.cycles_per_mb);
+    }
+
+    log_debug(dec_ctx,
+            " %d x %d, Crop: (%d, %d), %d x %d %s",
+            picture->sequence_info.pic_width,
+            picture->sequence_info.pic_height,
+            picture->sequence_info.crop_params.crop_left_offset,
+            picture->sequence_info.crop_params.crop_top_offset,
+            picture->sequence_info.crop_params.crop_out_width,
+            picture->sequence_info.crop_params.crop_out_height,
+            picture->picture_info.is_corrupted ? "CORRUPT" : "");
+
+    log_debug(dec_ctx, "%s\n", info_string);
+}
+
+static void esjdec_print_decode_return(enum DecRet jpeg_ret) {
+    switch (jpeg_ret) {
+    case DEC_PIC_RDY:
+        log_debug(NULL, "JpegDecDecode API returned : DEC_PIC_RDY\n");
+        break;
+    case DEC_OK:
+        log_debug(NULL, "JpegDecDecode API returned : DEC_OK\n");
+        break;
+    case DEC_ERROR:
+        log_error(NULL, "JpegDecDecode API returned : DEC_ERROR\n");
+        break;
+    case DEC_HW_TIMEOUT:
+        log_error(NULL, "JpegDecDecode API returned : JPEGDEC_HW_TIMEOUT\n");
+        break;
+    case DEC_UNSUPPORTED:
+        log_error(NULL, "JpegDecDecode API returned : DEC_UNSUPPORTED\n");
+        break;
+    case DEC_PARAM_ERROR:
+        log_error(NULL, "JpegDecDecode API returned : DEC_PARAM_ERROR\n");
+        break;
+    case DEC_MEMFAIL:
+        log_error(NULL, "JpegDecDecode API returned : DEC_MEMFAIL\n");
+        break;
+    case DEC_INITFAIL:
+        log_error(NULL, "JpegDecDecode API returned : DEC_INITFAIL\n");
+        break;
+    case DEC_HW_BUS_ERROR:
+        log_error(NULL, "JpegDecDecode API returned : DEC_HW_BUS_ERROR\n");
+        break;
+    case DEC_SYSTEM_ERROR:
+        log_error(NULL, "JpegDecDecode API returned : DEC_SYSTEM_ERROR\n");
+        break;
+    case DEC_DWL_ERROR:
+        log_error(NULL, "JpegDecDecode API returned : DEC_DWL_ERROR\n");
+        break;
+    case DEC_INVALID_STREAM_LENGTH:
+        log_error(NULL,
+                "JpegDecDecode API returned : DEC_INVALID_STREAM_LENGTH\n");
+        break;
+    case DEC_STRM_ERROR:
+        log_error(NULL, "JpegDecDecode API returned : DEC_STRM_ERROR\n");
+        break;
+    case DEC_INVALID_INPUT_BUFFER_SIZE:
+        log_error(NULL,
+                "JpegDecDecode API returned : DEC_INVALID_INPUT_BUFFER_SIZE\n");
+        break;
+    case DEC_INCREASE_INPUT_BUFFER:
+        log_debug(NULL,
+                "JpegDecDecode API returned : DEC_INCREASE_INPUT_BUFFER\n");
+        break;
+    case DEC_SLICE_MODE_UNSUPPORTED:
+        log_error(NULL,
+                "JpegDecDecode API returned : DEC_SLICE_MODE_UNSUPPORTED\n");
+        break;
+    case DEC_NO_DECODING_BUFFER:
+        log_debug(NULL,
+                "JpegDecDecode API returned : DEC_NO_DECODING_BUFFER\n");
+        break;
+    case DEC_WAITING_FOR_BUFFER:
+        log_debug(NULL,
+                "JpegDecDecode API returned : DEC_WAITING_FOR_BUFFER\n");
+        break;
+    case DEC_FORMAT_NOT_SUPPORTED:
+        log_error(NULL,
+                "JpegDecDecode API returned : DEC_FORMAT_NOT_SUPPORTED\n");
+        break;
+    case DEC_STRM_PROCESSED:
+        log_error(NULL,
+                "JpegDecDecode API returned : DEC_STRM_PROCESSED\n");
+        break;
+    default:
+        log_error(NULL, "JpegDecDecode API returned unknown status\n");
+        break;
+    }
+}
+
+static void esjdec_print_image_info(struct DecSequenceInfo * image_info) {
+  assert(image_info);
+
+  /* Select if Thumbnail or full resolution image will be decoded */
+  if(image_info->thumbnail_type == JPEGDEC_THUMBNAIL_JPEG) {
+    /* decode thumbnail */
+    log_debug(NULL, "\t-JPEG THUMBNAIL IN STREAM\n");
+    log_debug(NULL, "\t-JPEG THUMBNAIL INFO\n");
+    log_debug(NULL, "\t\t-JPEG thumbnail display resolution(W x H): %d x %d\n",
+            image_info->scaled_width_thumb, image_info->scaled_height_thumb);
+    log_debug(NULL, "\t\t-JPEG thumbnail HW decoded RESOLUTION(W x H): %d x %d\n",
+            NEXT_MULTIPLE(image_info->scaled_width_thumb, 16),
+            NEXT_MULTIPLE(image_info->scaled_height_thumb, 8));
+    log_debug(NULL, "\t\t-JPEG thumbnail OUTPUT SIZE(Stride x H): %d x %d\n",
+            image_info->pic_width_thumb, image_info->pic_height_thumb);
+
+    /* stream type */
+    switch (image_info->coding_mode_thumb) {
+    case JPEG_BASELINE:
+      log_debug(NULL, "\t\t-JPEG: STREAM TYPE: JPEG_BASELINE\n");
+      break;
+    case JPEG_PROGRESSIVE:
+      log_debug(NULL, "\t\t-JPEG: STREAM TYPE: JPEG_PROGRESSIVE\n");
+      break;
+    case JPEG_NONINTERLEAVED:
+      log_debug(NULL, "\t\t-JPEG: STREAM TYPE: JPEG_NONINTERLEAVED\n");
+      break;
+    }
+
+    if(image_info->output_format_thumb) {
+      switch (image_info->output_format_thumb) {
+      case DEC_OUT_FRM_YUV400:
+        log_debug(NULL,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV400\n");
+        break;
+      case DEC_OUT_FRM_YUV420SP:
+        log_debug(NULL,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV420SP\n");
+        break;
+      case DEC_OUT_FRM_YUV422SP:
+        log_debug(NULL,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV422SP\n");
+        break;
+      case DEC_OUT_FRM_YUV440:
+        log_debug(NULL,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV440\n");
+        break;
+      case DEC_OUT_FRM_YUV411SP:
+        log_debug(NULL,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV411SP\n");
+        break;
+      case DEC_OUT_FRM_YUV444SP:
+        log_debug(NULL,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: DEC_OUT_FRM_YUV444SP\n");
+        break;
+      default:
+        log_debug(NULL,
+                "\t\t-JPEG: THUMBNAIL OUTPUT: NOT SUPPORT\n");
+        break;
+      }
+    }
+  } else if(image_info->thumbnail_type == JPEGDEC_NO_THUMBNAIL) {
+    /* decode full image */
+    log_debug(NULL,
+            "\t-NO THUMBNAIL IN STREAM ==> Decode full resolution image\n");
+  } else if(image_info->thumbnail_type == JPEGDEC_THUMBNAIL_NOT_SUPPORTED_FORMAT) {
+    /* decode full image */
+    log_debug(NULL,
+            "\tNot SUPPORTED THUMBNAIL IN STREAM ==> Decode full resolution image\n");
+  }
+
+  log_debug(NULL, "\t-JPEG FULL RESOLUTION INFO\n");
+  log_debug(NULL, "\t\t-JPEG display resolution(W x H): %d x %d\n",
+          image_info->scaled_width, image_info->scaled_height);
+  log_debug(NULL, "\t\t-JPEG HW decoded RESOLUTION(W x H): %d x %d\n",
+          NEXT_MULTIPLE(image_info->scaled_width, 8),
+          NEXT_MULTIPLE(image_info->scaled_height, 8));
+  log_debug(NULL, "\t\t-JPEG OUTPUT SIZE(Stride x H): %d x %d\n",
+          image_info->pic_width, image_info->pic_height);
+  if(image_info->output_format) {
+    switch (image_info->output_format) {
+    case DEC_OUT_FRM_YUV400:
+      log_debug(NULL,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV400\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_0_0 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV420SP:
+      log_debug(NULL,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV420SP\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_2_0 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV422SP:
+      log_debug(NULL,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV422SP\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_2_2 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV440:
+      log_debug(NULL,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV440\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_4_0 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV411SP:
+      log_debug(NULL,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV411SP\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_1_1 = 1;
+#endif
+      break;
+    case DEC_OUT_FRM_YUV444SP:
+      log_debug(NULL,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: DEC_OUT_FRM_YUV444SP\n");
+#ifdef ASIC_TRACE_SUPPORT
+      decoding_tools.sampling_4_4_4 = 1;
+#endif
+      break;
+    default:
+      log_debug(NULL,
+              "\t\t-JPEG: FULL RESOLUTION OUTPUT: NOT SUPPORT\n");
+      break;
+    }
+  }
+
+  /* stream type */
+  switch (image_info->coding_mode) {
+        case JPEG_BASELINE:
+            log_debug(NULL, "\t\t-JPEG: STREAM TYPE: JPEG_BASELINE\n");
+            break;
+        case JPEG_PROGRESSIVE:
+            log_debug(NULL, "\t\t-JPEG: STREAM TYPE: JPEG_PROGRESSIVE\n");
+#ifdef ASIC_TRACE_SUPPORT
+        decoding_tools.progressive = 1;
+#endif
+             break;
+        case JPEG_NONINTERLEAVED:
+            log_debug(NULL, "\t\t-JPEG: STREAM TYPE: JPEG_NONINTERLEAVED\n");
+            break;
+   }
+
+  if(image_info->thumbnail_type == JPEGDEC_THUMBNAIL_JPEG) {
+    log_debug(NULL, "\t-JPEG ThumbnailType: JPEG\n");
+#ifdef ASIC_TRACE_SUPPORT
+    decoding_tools.thumbnail = 1;
+#endif
+  } else if(image_info->thumbnail_type == JPEGDEC_NO_THUMBNAIL)
+    log_debug(NULL, "\t-JPEG ThumbnailType: NO THUMBNAIL\n");
+  else if(image_info->thumbnail_type == JPEGDEC_THUMBNAIL_NOT_SUPPORTED_FORMAT)
+    log_debug(NULL, "\t-JPEG ThumbnailType: NOT SUPPORTED THUMBNAIL\n");
+}
+
+static bool check_scale_value( uint32_t v) {
+    if (v == -1 || v == -2 || v == -4 || v == -8) {
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static void esjdec_ppu_print(struct DecConfig *config){
+
+    for(int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (config->ppu_cfg[i].enabled) {
+            log_debug(NULL, "ppu_cfg[%d].tiled_e = %d\n", i,
+               config->ppu_cfg[i].tiled_e);
+            log_debug(NULL, "ppu_cfg[%d].scale.enabled = %d\n",
+                i, config->ppu_cfg[i].scale.enabled);
+            log_debug(NULL, "ppu_cfg[%d].scale.scale_by_ratio = %d\n",
+                i, config->ppu_cfg[i].scale.scale_by_ratio);
+            log_debug(NULL, "ppu_cfg[%d].scale.ratio_x = %d\n",
+                i, config->ppu_cfg[i].scale.ratio_x);
+            log_debug(NULL, "ppu_cfg[%d].scale.ratio_y = %d\n",
+                i, config->ppu_cfg[i].scale.ratio_y);
+            log_debug(NULL, "ppu_cfg[%d].scale.width = %d\n",
+                i, config->ppu_cfg[i].scale.width);
+            log_debug(NULL, "ppu_cfg[%d].scale.height = %d\n",
+                i, config->ppu_cfg[i].scale.height);
+            log_debug(NULL, "ppu_cfg[%d].crop.enabled = %d\n",
+                i, config->ppu_cfg[i].crop.enabled);
+            log_debug(NULL, "ppu_cfg[%d].crop.x = %d\n",
+                i, config->ppu_cfg[i].crop.x);
+            log_debug(NULL, "ppu_cfg[%d].crop.y = %d\n",
+                i, config->ppu_cfg[i].crop.y);
+            log_debug(NULL, "ppu_cfg[%d].crop.width = %d\n",
+                i, config->ppu_cfg[i].crop.width);
+            log_debug(NULL, "ppu_cfg[%d].crop.height = %d\n",
+                i, config->ppu_cfg[i].crop.height);
+            log_debug(NULL, "ppu_cfg[%d].out_p010 = %d\n",
+                i, config->ppu_cfg[i].out_p010);
+            log_debug(NULL, "ppu_cfg[%d].out_I010 = %d\n",
+                i, config->ppu_cfg[i].out_I010);
+            log_debug(NULL, "ppu_cfg[%d].align = %d\n",
+                i, config->ppu_cfg[i].align);
+            log_debug(NULL, "ppu_cfg[%d].shaper_enabled = %d\n",
+                i, config->ppu_cfg[i].shaper_enabled);
+            log_debug(NULL, "ppu_cfg[%d].cr_first = %d\n",
+                i, config->ppu_cfg[i].cr_first);
+            log_debug(NULL, "ppu_cfg[%d].rgb = %d\n",
+                i, config->ppu_cfg[i].rgb);
+            log_debug(NULL, "ppu_cfg[%d].rgb_format = %d\n",
+                i, config->ppu_cfg[i].rgb_format);
+        }
+    }
+}
+
+static int esjdec_init_pkt_dump_handle(JDECContext *dec_ctx, struct DecSequenceInfo *info) {
+    DumpParas paras;
+
+    if(dec_ctx->packet_dump && !dec_ctx->pkt_dump_handle) {
+        paras.width = info->pic_width;
+        paras.height = info->pic_height;
+        paras.pic_stride = 0;
+        paras.pic_stride_ch = 0;
+        paras.prefix_name = "jdec";
+        paras.suffix_name = "jpeg";
+        paras.fmt = NULL;
+        dec_ctx->pkt_dump_handle = ff_codec_dump_file_open(dec_ctx->dump_path, dec_ctx->packet_dump_time, &paras);
+        if (!dec_ctx->pkt_dump_handle) {
+            log_error(NULL, "init pkt_dump_handle failed\n");
+            return FAILURE;
+        }
+    }
+
+    return SUCCESS;
+}
+
+static int esjdec_init_frame_dump_handle(JDECContext *dec_ctx, struct DecPicturePpu *pic) {
+    int ret = 0;
+
+    for ( int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if(dec_ctx->cfg_pp_enabled[i] == 1 && dec_ctx->frame_dump[i] && !dec_ctx->frame_dump_handle[i]) {
+            DumpParas paras;
+            paras.width = pic->pictures[i].pic_width;
+            paras.height = pic->pictures[i].pic_height;
+            paras.pic_stride = pic->pictures[i].pic_stride;
+            paras.pic_stride_ch = pic->pictures[i].pic_stride_ch;
+            paras.prefix_name = "jdec";
+
+            if (i == 0)
+                paras.ppu_channel = "pp0";
+            else
+                paras.ppu_channel = "pp01";
+
+            if (IS_PIC_RGB_FMT(pic->pictures[i].picture_info.format))
+                paras.suffix_name = "rgb";
+            else
+                paras.suffix_name = "yuv";
+
+            paras.fmt = ff_codec_decfmt_to_char(pic->pictures[i].picture_info.format);
+
+            dec_ctx->frame_dump_handle[i] = ff_codec_dump_file_open(dec_ctx->dump_path,
+                                                                    dec_ctx->frame_dump_time[i],
+                                                                    &paras);
+
+        }
+    }
+
+    return ret;
+}
+
+static int esjdec_frame_dump(JDECContext *dec_ctx, struct DecPicturePpu *pic) {
+    int ret = 0;
+    for ( int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if(dec_ctx->cfg_pp_enabled[i] == 1 && dec_ctx->frame_dump[i]) {
+            if (dec_ctx->frame_dump_handle[i]) {
+                ret = ff_codec_dump_data_to_file_by_decpicture(&pic->pictures[i], dec_ctx->frame_dump_handle[i]);
+                if (ret == ERR_TIMEOUT) {
+                    log_info(NULL, "frame dump timeout\n");
+                    ff_codec_dump_file_close(&dec_ctx->frame_dump_handle[i]);
+                    dec_ctx->frame_dump[i] = 0;
+                    return 0;
+                } else if (ret < 0) {
+                    log_error(NULL, "write file error\n");
+                    return -1;
+                }
+            } else {
+                log_error(NULL,"fp is not inited\n");
+                return -1;
+            }
+        }
+    }
+
+    return 0;
+}
+
+static int esjdec_pkt_dump(JDECContext *dec_ctx, InputBuffer *buffer)
+{
+    int ret = 0;
+    if(dec_ctx->packet_dump) {
+        if (dec_ctx->pkt_dump_handle) {
+            ret = ff_codec_dump_bytes_to_file(buffer->vir_addr, buffer->size,  dec_ctx->pkt_dump_handle);
+            if (ret == ERR_TIMEOUT) {
+                log_info(NULL, "pkt dump timeout\n");
+                ff_codec_dump_file_close(&dec_ctx->pkt_dump_handle);
+                dec_ctx->packet_dump = 0;
+            } else if (ret < 0) {
+                log_error(NULL, "write frame into file failed\n");
+                return FAILURE;
+            }
+        } else {
+            log_error(NULL, "fp is not inited\n");
+            return FAILURE;
+        }
+    }
+
+    return SUCCESS;
+}
+
+static bool esjdec_drop_pkt(JDECContext *dec_ctx)
+{
+    bool ret = FALSE;
+
+    if (!dec_ctx) {
+        log_error(NULL, "dec_ctx is null, dex_ctx: %p\n", dec_ctx);
+        return ret;
+    }
+
+    if (dec_ctx->drop_frame_interval <= 0) {
+        return ret;
+    }
+
+    if (dec_ctx->got_package_number % (dec_ctx->drop_frame_interval + 1) == 0) {
+        log_debug(dec_ctx, "drop pkt number: %d\n", dec_ctx->got_package_number);
+        ret = TRUE;
+    } else {
+        ret = FALSE;
+    }
+
+    return ret;
+}
+
+static int esjdec_get_image_info(void *inst, struct DecSequenceInfo *info, struct DecConfig *config)
+{
+    JpegDecInput jpeg_input;
+    enum DecRet rv;
+    JpegDecImageInfo image_info;
+
+    jpeg_input.stream_buffer = info->jpeg_input_info.stream_buffer;
+    jpeg_input.stream_length = info->jpeg_input_info.strm_len;
+    jpeg_input.buffer_size = info->jpeg_input_info.buffer_size;
+    jpeg_input.stream = info->jpeg_input_info.stream;
+
+    DWLmemset(&image_info, 0, sizeof(image_info));
+
+    rv = JpegDecGetImageInfo(inst, &jpeg_input, &image_info);
+
+    info->scaled_width = image_info.display_width;
+    info->scaled_height = image_info.display_height;
+    info->pic_width = image_info.output_width;
+    info->pic_height = image_info.output_height;
+    info->scaled_width_thumb = image_info.display_width_thumb;
+    info->scaled_height_thumb = image_info.display_height_thumb;
+    info->pic_width_thumb = image_info.output_width_thumb;
+    info->pic_height_thumb = image_info.output_height_thumb;
+    info->output_format = image_info.output_format;
+    info->output_format_thumb = image_info.output_format_thumb;
+    info->coding_mode = image_info.coding_mode;
+    info->coding_mode_thumb = image_info.coding_mode_thumb;
+    info->thumbnail_type = image_info.thumbnail_type;
+    info->img_max_dec_width = image_info.img_max_dec_width;
+    info->img_max_dec_height = image_info.img_max_dec_height;
+    /* update the alignment setting in "image_info" data structure and output picture width */
+    info->pic_width = NEXT_MULTIPLE(info->pic_width, ALIGN(config->align));
+    info->pic_width_thumb = NEXT_MULTIPLE(info->pic_width_thumb, ALIGN(config->align));
+
+    esjdec_print_image_info(&info);
+
+    if(rv != DEC_OK) {
+        log_error(NULL, "get SequenceInfo failed, rv: %d\n", rv);
+        return FAILURE;
+    }
+
+    return SUCCESS;
+}
+static int esjdec_modify_config_by_image_info(JDECContext *dec_ctx,
+                                                 struct DecSequenceInfo *sequence_info)
+{
+    enum DecRet rv_info;
+    int i;
+    /* process pp size -1/-2/-4/-8. */
+    struct DecConfig *config = &dec_ctx->jdec_config;
+    uint32_t alignh = sequence_info->is_interlaced ? 4 : 2;
+    uint32_t alignw = 2;
+
+    uint32_t original_width = sequence_info->pic_width;
+    uint32_t original_height = sequence_info->pic_height;
+
+    //crop
+    for (i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (config->ppu_cfg[i].enabled && config->ppu_cfg[i].crop.enabled) {
+            if (config->ppu_cfg[i].crop.x > original_width ||
+                config->ppu_cfg[i].crop.y > original_height ||
+                ((config->ppu_cfg[i].crop.x + config->ppu_cfg[i].crop.width) > original_width) ||
+                ((config->ppu_cfg[i].crop.x + config->ppu_cfg[i].crop.height) > original_height)) {
+                log_error(dec_ctx,
+                       "invalid crop config, original_width: %d original_height: %d\n",
+                       original_width, original_height);
+                return FAILURE;
+            }
+
+            // check value
+            if(config->ppu_cfg[i].crop.width < 48 || config->ppu_cfg[i].crop.height < 48) {
+                log_error(dec_ctx,
+                       "pp%d invalid crop config, crop.width: %d crop.height: %d, "
+                        "request values equal to or more than 48\n",
+                        i,
+                        config->ppu_cfg[i].crop.width,
+                        config->ppu_cfg[i].crop.height);
+                return FAILURE;
+            }
+
+            if ((config->ppu_cfg[i].crop.width % 2) || (config->ppu_cfg[i].crop.height % 2)) {
+                log_error(dec_ctx,
+                      "pp%d invalid crop config, crop.width: %d crop.height: %d, request values is even\n",
+                       i,
+                       config->ppu_cfg[i].crop.width,
+                       config->ppu_cfg[i].crop.height);
+                config->ppu_cfg[i].crop.width = NEXT_MULTIPLE(config->ppu_cfg[i].crop.width, alignw);
+                config->ppu_cfg[i].crop.height = NEXT_MULTIPLE(config->ppu_cfg[i].crop.height, alignh);
+            }
+        }
+    }
+
+    // scale
+    for (i = 1; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (config->ppu_cfg[i].enabled && config->ppu_cfg[i].scale.enabled) {
+            if (check_scale_value(config->ppu_cfg[i].scale.width) ||
+                check_scale_value(config->ppu_cfg[i].scale.height)) {
+
+                if (config->ppu_cfg[i].scale.width == -1
+                    && config->ppu_cfg[i].scale.height == -1) {
+                    rv_info = DEC_INFOPARAM_ERROR;
+                    break;
+                }
+
+                if (config->ppu_cfg[i].crop.enabled) {
+                    if (config->ppu_cfg[i].crop.width != original_width) {
+                        original_width = config->ppu_cfg[i].crop.width;
+                    }
+                    if (config->ppu_cfg[i].crop.height != original_height) {
+                        original_height = config->ppu_cfg[i].crop.height;
+                    }
+                }
+
+                log_debug(dec_ctx, "original_width = %d, original_height = %d\n",
+                    original_width, original_height);
+
+                if (config->ppu_cfg[i].scale.width == -1 &&
+                    !check_scale_value(config->ppu_cfg[i].scale.height) &&
+                    config->ppu_cfg[i].scale.height > 0) {
+                    config->ppu_cfg[i].scale.width =
+                        NEXT_MULTIPLE((original_width
+                                    * config->ppu_cfg[i].scale.height)/original_height, alignw);
+                    config->ppu_cfg[i].scale.height =
+                        NEXT_MULTIPLE(config->ppu_cfg[i].scale.height, alignh);
+                } else if (config->ppu_cfg[i].scale.height == -1 &&
+                        !check_scale_value(config->ppu_cfg[i].scale.width) &&
+                        config->ppu_cfg[i].scale.width > 0) {
+                    config->ppu_cfg[i].scale.width =
+                        NEXT_MULTIPLE(config->ppu_cfg[i].scale.width, alignw);
+                    config->ppu_cfg[i].scale.height =
+                        NEXT_MULTIPLE((original_height
+                                    * config->ppu_cfg[i].scale.width)/original_width, alignh);
+                } else if (check_scale_value(config->ppu_cfg[i].scale.width) &&
+                        check_scale_value(config->ppu_cfg[i].scale.height)) {
+                    config->ppu_cfg[i].scale.scale_by_ratio = 1;
+                    config->ppu_cfg[i].scale.ratio_x = -config->ppu_cfg[i].scale.width;
+                    config->ppu_cfg[i].scale.ratio_y = -config->ppu_cfg[i].scale.height;
+                    config->ppu_cfg[i].scale.width = 0;
+                    config->ppu_cfg[i].scale.height = 0;
+                } else {
+                    rv_info = DEC_INFOPARAM_ERROR;
+                    log_error(dec_ctx,
+                           "invalid scale config, scale.width: %d scale.height: %d\n",
+                           config->ppu_cfg[i].scale.width,
+                           config->ppu_cfg[i].scale.height);
+                    break;
+                }
+            } else if (config->ppu_cfg[i].scale.width > 0 && config->ppu_cfg[i].scale.width > 0) {
+                if(config->ppu_cfg[i].scale.width > original_width ||
+                    config->ppu_cfg[i].scale.height > original_height) {
+                    log_error(dec_ctx,
+                           "invalid scale config, scale.width: %d scale.height: %d\n",
+                           config->ppu_cfg[i].scale.width,
+                           config->ppu_cfg[i].scale.height);
+                    return FAILURE;
+                }
+            } else if (config->ppu_cfg[i].scale.width != 0 && config->ppu_cfg[i].scale.height != 0){
+                log_error(dec_ctx,
+                       "invalid scale config, scale.width: %d scale.height: %d\n",
+                       config->ppu_cfg[i].scale.width,
+                       config->ppu_cfg[i].scale.height);
+                return FAILURE;
+            }
+        }
+    }
+
+    dec_ctx->jdec_config.dec_image_type = sequence_info->jpeg_input_info.dec_image_type;
+
+    esjdec_ppu_print(config);
+
+    return SUCCESS;
+}
+
+static void esjdec_modify_thum_config_by_image_info(struct DecSequenceInfo *image_info, struct DecConfig *config, uint32_t thumb_out)
+{
+    u32 display_width = (image_info->scaled_width + 1) & ~0x1;
+    u32 display_height = (image_info->scaled_height + 1) & ~0x1;
+    u32 display_width_thumb = (image_info->scaled_width_thumb + 1) & ~0x1;
+    u32 display_height_thumb = (image_info->scaled_height_thumb + 1) & ~0x1;
+    u32 crop_width_thumb = 0;
+    u32 crop_height_thumb = 0;
+
+    if (!config->ppu_cfg[0].crop.set_by_user) {
+      config->ppu_cfg[0].crop.width = thumb_out ? display_width_thumb: display_width;
+      config->ppu_cfg[0].crop.height = thumb_out ? display_height_thumb: display_height;
+      config->ppu_cfg[0].crop.enabled = 1;
+    }
+    u32 crop_w = config->ppu_cfg[0].crop.width;
+    u32 crop_h = config->ppu_cfg[0].crop.height;
+
+    crop_width_thumb = NEXT_MULTIPLE(crop_w - 1, 2);
+    crop_height_thumb = NEXT_MULTIPLE(crop_h - 1, 2);
+    image_info->pic_width = NEXT_MULTIPLE(crop_width_thumb, ALIGN(config->align));
+    image_info->pic_width_thumb = NEXT_MULTIPLE(crop_width_thumb, ALIGN(config->align));
+    image_info->pic_height = crop_height_thumb;
+    image_info->pic_height_thumb = crop_height_thumb;
+
+    if (thumb_out == 1) {
+        // set image type
+        config->dec_image_type = JPEGDEC_THUMBNAIL;
+
+        //set ppu config
+        for (int i = 0; i < DEC_MAX_PPU_COUNT; i++) {
+            if (!config->ppu_cfg[i].enabled)
+                    continue;
+            if (config->ppu_cfg[i].scale.enabled == 1) {
+                config->ppu_cfg[i].scale.scale_by_ratio = 0;
+                config->ppu_cfg[i].scale.width = image_info->scaled_width_thumb;
+                config->ppu_cfg[i].scale.height = image_info->scaled_height_thumb;
+            }
+            if (config->ppu_cfg[i].crop.enabled == 1) {
+                config->ppu_cfg[i].crop.enabled = 0;
+                config->ppu_cfg[i].crop.set_by_user = 0;
+            }
+        }
+    }
+}
+
+static int esjdec_enlarge_input_port(JDECContext *dec_ctx, int buf_num) {
+    int ret = SUCCESS;
+    int output_buffer_num;
+
+    if (!dec_ctx) {
+        log_error(dec_ctx, "error dec_ctx: %p, buf_num: %d\n", dec_ctx, buf_num);
+        return FAILURE;
+    }
+
+    if (buf_num > 0) {
+        output_buffer_num = buf_num < JPEG_DEFAULT_INPUT_MAX_BUFFERS ? buf_num : JPEG_DEFAULT_INPUT_MAX_BUFFERS; 
+    } else {
+        output_buffer_num = JPEG_DEFAULT_INPUT_BUFFERS;
+    }
+
+    ret = esdec_enlarge_input_port(dec_ctx->codec,
+                                      dec_ctx->input_port,
+                                      dec_ctx->dwl_ref,
+                                      output_buffer_num);
+    if (ret < 0) {
+        log_error(dec_ctx, "es_decode_enlarge_input_port failed\n");
+        return FAILURE;
+    }
+
+    return SUCCESS;
+}
+
+static int esjdec_enlarge_out_port(JDECContext *dec_ctx, int buf_num) {
+    int ret = SUCCESS;
+    int output_buffer_num;
+
+    if (!dec_ctx) {
+        log_error(dec_ctx, "error dec_ctx: %p, buf_num: %d\n", dec_ctx, buf_num);
+        return FAILURE;
+    }
+
+    if (buf_num > 0) {
+        output_buffer_num = buf_num < JPEG_DEFAULT_OUTPUT_MAX_BUFFERS ? buf_num : JPEG_DEFAULT_OUTPUT_MAX_BUFFERS;
+    } else {
+        output_buffer_num = JPEG_DEFAULT_OUTPUT_BUFFERS;
+    }
+
+    ret = esdec_enlarge_output_port(dec_ctx->codec,
+                                    dec_ctx->output_port,
+                                    dec_ctx->dec_inst,
+                                    dec_ctx->dwl_ref,
+                                    output_buffer_num);
+    if (ret == FAILURE) {
+        log_error(dec_ctx, "esdec_enlarge_output_port error\n");
+        ret = FAILURE;
+    }
+
+    return ret;
+}
+
+int ff_jdec_send_packet(JDECContext *dec_ctx, AVPacket *pkt, int timeout) {
+    int ret;
+    int data_size = 0;
+    bool is_discard = 0;
+    InputBuffer buffer;
+    ESInputPort *port;
+
+    if (!dec_ctx || !dec_ctx->input_port) {
+        return AVERROR(EINVAL);
+    }
+    port = dec_ctx->input_port;
+
+    if (pkt) {
+        data_size = pkt->size;
+    }
+
+    if (dec_ctx->got_package_number == 2 && pkt->size > 0) {
+        esjdec_enlarge_input_port(dec_ctx, dec_ctx->input_buf_num);
+    }
+
+    is_discard = esjdec_drop_pkt(dec_ctx);
+    if (is_discard && pkt && pkt->size > 0) {
+        dec_ctx->drop_pkt_number++;
+        log_debug(dec_ctx,
+                  "drop pkt number: %d, has dropped pkt number: %d\n",
+                  dec_ctx->got_package_number,
+                  dec_ctx->drop_pkt_number);
+        return SUCCESS;
+    }
+
+    ret = esdec_get_input_buffer_unitl_timeout(port->release_queue, &buffer, timeout);
+    if (ret == SUCCESS) {
+        if (buffer.max_size < data_size) {
+            ret = es_decode_realloc_input_memory(port, data_size + ES_DEFAULT_STREAM_BUFFER_SIZE, &buffer);
+        }
+
+        if (ret == SUCCESS) {
+            buffer.size = data_size;
+            if (pkt) {
+                buffer.pts = pkt->pts;
+                buffer.reordered_opaque = dec_ctx->reordered_opaque;
+                memcpy((void *)buffer.vir_addr, pkt->data, data_size);
+                log_debug(dec_ctx,
+                              "get input buffer virtual_address: %p",
+                              buffer.vir_addr);
+            }
+            esdec_push_input_packet_buffer(port->packet_queue, &buffer);
+        }
+    }
+
+    return ret;
+}
+
+int ff_jdec_send_packet_receive_frame(JDECContext *dec_ctx, AVPacket *pkt, AVFrame *frame) {
+    int ret;
+    if (!dec_ctx || !pkt || !frame) {
+        log_error(dec_ctx, "error !!! dec_ctx or pkt or frame is null pkt: %p, frame: %p\n", pkt, frame);
+        return FAILURE;
+    }
+
+    for (;;) {
+        ret = ff_jdec_send_packet(dec_ctx, pkt, 20 /*20ms*/);
+        if (ret == SUCCESS) {
+            ret = ff_jdec_get_frame(dec_ctx, frame, 0);
+            av_packet_unref(pkt);
+            break;
+        } else {
+            ret = ff_jdec_get_frame(dec_ctx, frame, 0);
+            if (ret == SUCCESS) {
+                log_info(dec_ctx, "get frame data_left: %d\n", pkt->size);
+                break;
+            }
+        }
+    }
+
+    if (frame->buf[0]) {
+        ret = SUCCESS;
+    } else {
+        ret = AVERROR(EAGAIN);
+    }
+
+    return ret;
+}
+
+static int esjdec_fill_frame_prop(JDECContext *dec_ctx, OutputBuffer *buffer, AVFrame *frame) {
+    int ret = SUCCESS;
+    DecPicturePri *pri_pic;
+    OutPutInfo *info;
+    ESOutputMemory *memory;
+    uint64_t dma_fd;
+    if (!dec_ctx || !buffer || !frame) {
+        return FAILURE;
+    }
+
+    ret = ff_decode_frame_props(dec_ctx->avctx, frame);
+    if (ret < 0) {
+        av_log(dec_ctx, AV_LOG_ERROR, "ff_decode_frame_props failed\n");
+        return ret;
+    }
+
+    memory = buffer->memory;
+    pri_pic = &memory->pic_pri;
+    info = pri_pic->default_pic;
+
+    frame->format = info->format;
+    frame->width = info->width;
+    frame->height = info->height;
+    frame->key_frame = info->key_frame;
+    frame->pts = buffer->pts;
+    frame->reordered_opaque = buffer->reordered_opaque;
+    for (int i = 0; i < info->n_planes; i++) {
+        frame->data[i] = (uint8_t *)info->virtual_address + info->offset[i];
+        frame->linesize[i] = info->stride[i];
+    }
+    if (ESDecIsSimulation()) {
+        dma_fd = (uint64_t)info->virtual_address;
+    } else {
+        dma_fd = (uint64_t)info->fd;
+    }
+    ff_es_codec_add_fd_to_side_data(frame, dma_fd);
+
+    frame->buf[0] = av_buffer_create(
+        (uint8_t *)pri_pic, sizeof(*pri_pic), esdec_picture_consume, dec_ctx->output_port, AV_BUFFER_FLAG_READONLY);
+    if (!frame->buf[0]) {
+        ret = FAILURE;
+        log_error(dec_ctx, "av_buffer_create frame[0] failed\n");
+    }
+
+    return ret;
+}
+
+int ff_jdec_get_frame(JDECContext *dec_ctx, AVFrame *frame, int timeout_ms) {
+    int ret;
+    int is_discard = 0;
+    OutputBuffer buffer;
+    ESOutputPort *port;
+    if (!dec_ctx || !frame) {
+        return AVERROR(EINVAL);
+    }
+    port = dec_ctx->output_port;
+    if (!port) {
+        return AVERROR(EAGAIN);
+    }
+
+    ret = esdec_get_output_frame_buffer(port->frame_queue, &buffer, timeout_ms);
+    if (ret == SUCCESS) {
+        ret = esjdec_fill_frame_prop(dec_ctx, &buffer, frame);
+        if (ret < 0) {
+            log_error(dec_ctx, "esjdec_fill_frame_prop failed\n");
+            esdec_release_output_buffer(port->consumed_queue, &buffer);
+        } else {
+            dec_ctx->pic_output_number++;
+            log_info(dec_ctx,
+                "%d got frame :size=%dx%d,data[0]=%p,data[1]=%p,buf[0]=%p,pts=%lld\n",
+                dec_ctx->pic_output_number,
+                frame->width,
+                frame->height,
+                frame->data[0],
+                frame->data[1],
+                frame->buf[0],
+                frame->pts);
+        }
+    }
+
+    if (frame->buf[0]) {
+        log_info(dec_ctx, "buffer picture: %p\n", buffer.memory->vir_addr);
+        ret = SUCCESS;
+    }
+
+    return ret;
+}
+
+static int esjdec_fill_thumb_mem(struct DecPicturePpu *pic, ESThumbOutputMemory *thumb_mem) {
+    int ret = FAILURE;
+    uint32_t *virtual_address;
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        virtual_address = pic->pictures[i].luma.virtual_address;
+        if (virtual_address != NULL && virtual_address == thumb_mem->virtual_address) {
+            ret = SUCCESS;
+            thumb_mem->picture = *pic;
+            thumb_mem->state = Using;
+            log_debug(NULL, "this is a thumbnail pic, virtual_address: %p\n", virtual_address);
+            break;
+        }
+    }
+
+    return ret;
+}
+
+static int esjdec_fill_thumb_mem_into_output_buffer(OutputBuffer *buffer, ESThumbOutputMemory *thumb_mem, int index) {
+    int ret = FAILURE;
+    DecPicturePri *pri_pic = NULL;
+    struct DecPicturePpu *pic;
+    ESOutputMemory *memory;
+
+    if (!buffer || !thumb_mem) {
+        log_error(NULL, "error !!! buffer: %p, thumb_mem: %p\n", buffer, thumb_mem);
+        return FAILURE;
+    }
+
+    memory = buffer->memory;
+    pri_pic = &memory->pic_pri;
+    pic = &thumb_mem->picture;
+
+    if (thumb_mem->state != Using) {
+        log_error(NULL, "thumbnail memory has no valid data\n");
+        return FAILURE;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (pic->pictures[i].luma.virtual_address != NULL && index == i) {
+            pri_pic->pic_count++;
+            pri_pic->pictures[2].fd = thumb_mem->fd[i];
+            esdec_fill_planes(&pri_pic->pictures[2], &pic->pictures[i]);
+            ret = SUCCESS;
+            log_info(NULL, "index: %d, virtual_address: %p\n", i, pic->pictures[i].luma.virtual_address);
+            break;
+        }
+    }
+    thumb_mem->state = Used;
+
+    return ret;
+}
+
+static int esjdec_fill_output_buffer(JDECContext *dec_ctx, struct DecPicturePpu *pic)
+{
+    int ret = SUCCESS;
+    int index = FAILURE;
+    OutputBuffer *buffer = NULL;
+    ESOutputMemory *memory;
+    DecPicturePri *pri_pic = NULL;
+    ESOutputPort *port;
+    if (!dec_ctx || !pic || !dec_ctx->output_port) {
+        log_error(dec_ctx, "error !!! dec_ctx: %p, pic: %p\n", dec_ctx, pic);
+        return FAILURE;
+    }
+    port = dec_ctx->output_port;
+
+    memory = esdec_find_memory_by_picture(port, pic);
+    if (!memory) {
+        log_error(dec_ctx, "esdec_find_memory_index_by_picture failed\n");
+        return FAILURE;
+    } else {
+        log_debug(
+            dec_ctx, "find memory vir_addr: %p, state: %s\n", memory->vir_addr, esdec_str_output_state(memory->state));
+    }
+
+    buffer = &memory->buffer;
+    buffer->memory = memory;
+    buffer->vir_addr = memory->vir_addr;
+    buffer->buffer_ref = av_buffer_ref(memory->buffer_ref);
+    buffer->port_ref = av_buffer_ref(memory->port_ref);
+
+    memory->picture = *pic;
+    pri_pic = &memory->pic_pri;
+    pri_pic->hwpic = (void *)buffer;
+
+    pri_pic->stride_align = dec_ctx->stride_align;
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (pic->pictures[i].luma.virtual_address != NULL) {
+            pri_pic->pic_count++;
+            pri_pic->pictures[i].fd = memory->fd[i];
+            esdec_fill_planes(&pri_pic->pictures[i], &pic->pictures[i]);
+            if (i == dec_ctx->pp_out) {
+                pri_pic->default_index = i;
+                pri_pic->default_pic = &pri_pic->pictures[i];
+            } else if (index == -1) {
+                index = i;
+            }
+            log_debug(dec_ctx, "index: %d, vir_addr: %p\n", i, pic->pictures[i].luma.virtual_address);
+        } else if (pri_pic->pictures[i].enabled) {
+            pri_pic->pictures[i].enabled = FALSE;
+        }
+    }
+
+    if (pri_pic->pic_count > 0) {
+        uint32_t pic_id;
+        ReorderPkt pkt;
+        if (!pri_pic->default_pic) {
+            pri_pic->default_index = index;
+            pri_pic->default_pic = &pri_pic->pictures[index];
+            log_info(dec_ctx, "DEFAULT_INDEX: %d, real pic_index: %d\n", dec_ctx->pp_out, index);
+            dec_ctx->pp_out = index;
+        }
+
+        pic_id = dec_ctx->pic_id;
+        if (dec_ctx->get_reorder_pkt_by_pic_id) {
+            int ret = dec_ctx->get_reorder_pkt_by_pic_id(dec_ctx, pic_id, &pkt);
+            if (ret == SUCCESS) {
+                buffer->pts = pkt.pts;
+                buffer->reordered_opaque = pkt.reordered_opaque;
+            } else {
+                log_error(dec_ctx, "get reorder pkt failed pic_id: %d\n", pic_id);
+            }
+        }
+
+        log_info(dec_ctx, ": %d\n", dec_ctx->pp_out, index);
+
+        if (!dec_ctx->picture) {
+            dec_ctx->picture = av_mallocz(sizeof(*dec_ctx->picture));
+            if (!dec_ctx->picture) {
+                log_error(dec_ctx, "av_malloc picture fialed\n");
+            } else {
+                *dec_ctx->picture = *pic;
+            }
+        }
+
+        if (dec_ctx->thumb_mem.state == Using) {
+            ret = esjdec_fill_thumb_mem_into_output_buffer(buffer, &dec_ctx->thumb_mem, dec_ctx->pp_out);
+        }
+
+        esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_FRAME_QUEUE);
+        ret = esdec_push_frame_output_buffer(port->frame_queue, buffer);
+        if (ret == FAILURE) {
+            esdec_set_output_buffer_state(memory, OUTPUT_MEMORY_STATE_ERROR);
+            log_error(dec_ctx, "esdec_push_frame_output_buffer failed vir_addr: %p\n", buffer->vir_addr);
+        } else {
+            log_debug(dec_ctx, "esdec_push_frame_output_buffer vir_addr: %p\n", memory->vir_addr);
+        }
+    } else {
+        log_error(dec_ctx, "error !!! no picture\n");
+        return FAILURE;
+    }
+
+    return ret;
+}
+
+static enum DecRet esjdec_jpeg_next_picture(const void *inst, struct DecPicturePpu *pic,  uint32_t thumb_out)
+{
+    enum DecRet rv;
+    JpegDecOutput jpic;
+    JpegDecImageInfo info;
+    u32 stride, stride_ch, i;
+
+    memset(&jpic, 0, sizeof(JpegDecOutput));
+    memset(pic, 0, sizeof(struct DecPicturePpu));
+    rv = JpegDecNextPicture(inst, &jpic, &info);
+
+    if (rv != DEC_PIC_RDY)
+        return rv;
+    for (i = 0; i < DEC_MAX_OUT_COUNT; i++)
+    {
+        stride = jpic.pictures[i].pic_stride;
+        stride_ch = jpic.pictures[i].pic_stride_ch;
+
+        pic->pictures[i].picture_info.cycles_per_mb = jpic.cycles_per_mb;
+        pic->pictures[i].luma = jpic.pictures[i].output_picture_y;
+        pic->pictures[i].chroma = jpic.pictures[i].output_picture_cb_cr;
+        pic->pictures[i].chroma_cr = jpic.pictures[i].output_picture_cr;
+        pic->pictures[i].sequence_info.pic_width = jpic.pictures[i].output_width;
+        pic->pictures[i].sequence_info.pic_height = jpic.pictures[i].output_height;
+        pic->pictures[i].sequence_info.scaled_width = jpic.pictures[i].display_width;
+        pic->pictures[i].sequence_info.scaled_height = jpic.pictures[i].display_height;
+        pic->pictures[i].sequence_info.pic_width_thumb = jpic.pictures[i].output_width_thumb;
+        pic->pictures[i].sequence_info.pic_height_thumb = jpic.pictures[i].output_height_thumb;
+        pic->pictures[i].sequence_info.scaled_width_thumb = jpic.pictures[i].display_width_thumb;
+        pic->pictures[i].sequence_info.scaled_height_thumb = jpic.pictures[i].display_height_thumb;
+        pic->pictures[i].sequence_info.bit_depth_luma = jpic.bit_depth;
+        pic->pictures[i].sequence_info.bit_depth_chroma = jpic.bit_depth;
+
+        if(thumb_out == 0){
+            pic->pictures[i].pic_width = jpic.pictures[i].display_width;
+            pic->pictures[i].pic_height = jpic.pictures[i].display_height;
+        }else{
+            pic->pictures[i].pic_width = jpic.pictures[i].display_width_thumb;
+            pic->pictures[i].pic_height = jpic.pictures[i].display_height_thumb;
+        }
+
+        if (IS_PIC_TILE(jpic.pictures[i].output_format)) {
+            pic->pictures[i].luma.size = stride * (NEXT_MULTIPLE(pic->pictures[i].pic_height, 4) / 4);
+            pic->pictures[i].chroma.size = stride_ch * (NEXT_MULTIPLE(pic->pictures[i].pic_height / 2, 4) / 4);
+        } else if (IS_PIC_PLANAR(jpic.pictures[i].output_format)) {
+            pic->pictures[i].luma.size = stride * pic->pictures[i].pic_height;
+            pic->pictures[i].chroma.size = stride_ch * pic->pictures[i].pic_height;
+        } else if (jpic.pictures[i].output_format == DEC_OUT_FRM_RFC) {
+            pic->pictures[i].luma.size = stride * pic->pictures[i].pic_height / 4;
+            pic->pictures[i].chroma.size = stride_ch * pic->pictures[i].pic_height / 8;
+        } else {
+            pic->pictures[i].luma.size = stride * pic->pictures[i].pic_height;
+            if (!IS_PIC_RGB(jpic.pictures[i].output_format))
+                pic->pictures[i].chroma.size = stride_ch * pic->pictures[i].pic_height / 2;
+        }
+
+        pic->pictures[i].pic_stride = jpic.pictures[i].pic_stride;
+        pic->pictures[i].pic_stride_ch = jpic.pictures[i].pic_stride_ch;
+        pic->pictures[i].picture_info.format = jpic.pictures[i].output_format;
+#ifdef SUPPORT_DEC400
+        pic->pictures[i].dec400_luma_table = jpic.pictures[i].dec400_luma_table;
+        pic->pictures[i].dec400_chroma_table = jpic.pictures[i].dec400_chroma_table;
+
+#endif
+    }
+    pic->pictures[0].sequence_info.output_format = info.output_format;
+    pic->pictures[0].sequence_info.output_format_thumb = info.output_format_thumb;
+    pic->pictures[0].sequence_info.coding_mode = info.coding_mode;
+    pic->pictures[0].sequence_info.coding_mode_thumb = info.coding_mode_thumb;
+    pic->pictures[0].sequence_info.thumbnail_type = info.thumbnail_type;
+
+    return rv;
+}
+
+static int esjdec_get_next_picture(JDECContext *dec_ctx) {
+    enum DecRet ret;
+    int rv = SUCCESS;
+    struct DecPicturePpu pic;
+
+    if (!dec_ctx) {
+        log_error(NULL, "error !!! dec_ctx: %p\n", dec_ctx);
+        return FAILURE;
+    }
+
+    ret = esjdec_jpeg_next_picture(dec_ctx->dec_inst, &pic, dec_ctx->thumb_out);
+    log_info(dec_ctx, "JpegNextPicture return: %d\n", ret);
+
+    if (ret == DEC_PIC_RDY) {
+        dec_ctx->pic_display_number++;
+        for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+            if(pic.pictures[i].luma.virtual_address != NULL) {
+                log_debug(dec_ctx, "Dec pic rdy, %d -> %d x %d -luma.virtual_address=%p"
+                                            "-luma.bus_address=%ld -luma.size=%d stride=%d"
+                                            "-sequence_info.pic_height=%d -sequence_info.pic_width=%d \n",
+                                            i,
+                                            pic.pictures[i].pic_width,
+                                            pic.pictures[i].pic_height,
+                                            pic.pictures[i].luma.virtual_address,
+                                            pic.pictures[i].luma.bus_address,
+                                            pic.pictures[i].luma.size,
+                                            pic.pictures[i].sequence_info.pic_stride,
+                                            pic.pictures[i].sequence_info.pic_height,
+                                            pic.pictures[i].sequence_info.pic_width);
+            }
+        }
+
+        // create frame file
+        for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++)
+            if(!dec_ctx->frame_dump_handle[i])
+                esjdec_init_frame_dump_handle(dec_ctx, &pic);
+        esjdec_frame_dump(dec_ctx, &pic);
+
+        ret = esjdec_fill_thumb_mem(&pic, &dec_ctx->thumb_mem);
+        if (ret == SUCCESS) {
+            log_info(dec_ctx, "this is a thumb pic, skip fill output buffer\n");
+            return ret;
+        }
+
+        rv = esjdec_fill_output_buffer(dec_ctx, &pic);
+        if (rv < 0) {
+            log_error(dec_ctx, "esjdec_fill_output_buffer failed,\n");
+        }
+    } else if (ret == DEC_END_OF_STREAM) {
+        log_debug(dec_ctx, "End of stream!\n");
+        return FAILURE;
+    }
+    return SUCCESS;
+}
+
+static void esjdec_eos_process(JDECContext *dec_ctx) {
+    int ret;
+    if (!dec_ctx || !dec_ctx->output_port) {
+        return;
+    }
+    log_info(dec_ctx, "JpegDecEndOfStream start\n");
+    JpegDecEndOfStream(dec_ctx->dec_inst);
+
+    for (;;) {
+        ret = esjdec_get_next_picture(dec_ctx);
+        if (ret == FAILURE) {
+            OutputBuffer buffer = {0};
+            buffer.flags = OUTPUT_BUFFERFLAG_EOS;
+            esdec_push_frame_output_buffer(dec_ctx->output_port->frame_queue, &buffer);
+            log_info(dec_ctx, "push eos frames\n");
+            break;
+        }
+    }
+    log_info(dec_ctx, "end\n");
+}
+
+static int esjdec_set_ppu_output_format(JDECContext *dec_ctx){
+    if (!dec_ctx) {
+        log_error(dec_ctx, "esjdec_set_ppu_output_format dec_ctx invaild\n");
+        return FAILURE;
+    }
+
+    struct DecConfig *config = &dec_ctx->jdec_config;
+
+    for(int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if(config->ppu_cfg[i].enabled == 1) {
+
+            enum DecPictureFormat dstpicfmt = ff_codec_pixfmt_to_decfmt(dec_ctx->output_format[i]);
+
+            log_info(NULL,
+                   "dec_ctx->output_format[%d]; %d  dstpicfmt: %d\n",
+                    i,
+                    dec_ctx->output_format[i],dstpicfmt);
+
+            switch (dstpicfmt) {
+                case DEC_OUT_FRM_NV21SP:
+                    config->ppu_cfg[i].cr_first = 1;
+                    break;
+
+                case DEC_OUT_FRM_YUV420SP:
+                    // todo
+                    break;
+
+                case DEC_OUT_FRM_YUV420P:
+                    config->ppu_cfg[i].planar = 1;
+                    break;
+
+                case DEC_OUT_FRM_YUV400:
+                    config->ppu_cfg[i].monochrome = 1;
+                    break;
+
+                case DEC_OUT_FRM_RGB888:
+                case DEC_OUT_FRM_BGR888:
+                case DEC_OUT_FRM_XRGB888:
+                case DEC_OUT_FRM_XBGR888:
+                    config->ppu_cfg[i].rgb = 1;
+                    config->ppu_cfg[i].rgb_format = dstpicfmt;
+                    break;
+
+                case DEC_OUT_FRM_ARGB888:
+                case DEC_OUT_FRM_ABGR888:
+                    config->ppu_cfg[i].rgb = 1;
+                    config->ppu_cfg[i].rgb_stan = BT709;
+                    config->ppu_cfg[i].rgb_alpha = 255;
+                    config->ppu_cfg[i].rgb_format = dstpicfmt;
+                    break;
+
+                default:
+                    log_error(NULL,"[%s:%d] set ppu[%d] output_format failed,"
+                                             "avctx->output_format: %d dstpicfmt: %d\n",
+                                              __func__, __LINE__, i,
+                                              dec_ctx->output_format[i], dstpicfmt);
+                    return FAILURE;
+            }
+        }
+    }
+
+    return SUCCESS;
+}
+
+static int esjdec_parse_ppset(JDECContext *dec_ctx, CropInfo *crop_info, ScaleInfo *scale_info) {
+    if (!dec_ctx) {
+        log_error(dec_ctx, "esjdec_parse_ppset dec_ctx invaild\n");
+        return FAILURE;
+    }
+    if (!crop_info) {
+        log_error(dec_ctx, "esjdec_parse_ppset crop_info invaild\n");
+        return FAILURE;
+    }
+    if (!scale_info) {
+        log_error(dec_ctx, "esjdec_parse_ppset scale_info invaild\n");
+        return FAILURE;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        log_debug(dec_ctx, "dec_ctx->pp_setting[%d]: %s\n", i, dec_ctx->pp_setting[i]);
+
+        if (dec_ctx->pp_setting[i] || dec_ctx->crop_set[i] || (i == 1 && dec_ctx->scale_set)) {
+            int ret = 0;
+
+            if (dec_ctx->pp_setting[i]) {
+                ret = ff_codec_get_crop(dec_ctx->pp_setting[i], crop_info + i);
+            } else if (dec_ctx->crop_set[i]) {
+                ret = es_codec_get_crop(dec_ctx->crop_set[i], crop_info + i);
+            }
+            if (ret < 0) {
+                log_error(dec_ctx, "picture_%d crop config error, please check!\n", i);
+                return FAILURE;
+            }
+
+            if( i == 0)
+                continue;
+
+            ret = 0;
+            if (dec_ctx->pp_setting[i]) {
+                ret = ff_dec_get_scale(dec_ctx->pp_setting[i], scale_info + i, i);
+            } else if (dec_ctx->scale_set) {
+                ret = es_codec_get_scale(dec_ctx->scale_set, scale_info + i);
+            }
+            if (ret < 0) {
+                log_error(dec_ctx, "picture_%d scale config error, please check!\n", i);
+                return FAILURE;
+            }
+        }
+    }
+
+    return SUCCESS;
+}
+
+static int esjdec_set_ppu_crop_and_scale(JDECContext *dec_ctx)
+{
+    struct DecConfig *config = &dec_ctx->jdec_config;
+    CropInfo crop_paras[ES_VID_DEC_MAX_OUT_COUNT];
+    ScaleInfo scale_paras[ES_VID_DEC_MAX_OUT_COUNT];
+    int pp_enabled = 0;
+
+    memset(crop_paras, 0, sizeof(CropInfo) * ES_VID_DEC_MAX_OUT_COUNT);
+    memset(scale_paras, 0, sizeof(ScaleInfo) * ES_VID_DEC_MAX_OUT_COUNT);
+
+    int ret = esjdec_parse_ppset(dec_ctx, &crop_paras, &scale_paras);
+    if (ret < 0) {
+        log_error(dec_ctx, "parse ppset error\n");
+        return FAILURE;
+    }
+
+    //set crop paras
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        // if config->ppu_cfg[i].enabled==0, crop is not assigned
+        if (!config->ppu_cfg[i].enabled ||
+            (crop_paras[i].crop_xoffset == 0 && crop_paras[i].crop_yoffset == 0
+            && crop_paras[i].crop_width == 0 && crop_paras[i].crop_height == 0)) {
+            continue;
+        }
+
+        pp_enabled = 1;
+        config->ppu_cfg[i].crop.enabled = 1;
+        config->ppu_cfg[i].crop.set_by_user = 1;
+        config->ppu_cfg[i].crop.x = crop_paras[i].crop_xoffset;
+        config->ppu_cfg[i].crop.y = crop_paras[i].crop_yoffset;
+        config->ppu_cfg[i].crop.width = crop_paras[i].crop_width;
+        config->ppu_cfg[i].crop.height = crop_paras[i].crop_height;
+
+        log_debug(dec_ctx,
+               "[%s:%d]  ppu_cfg[%d].crop.x: %d  "
+                "ppu_cfg[%d].crop.y: %d  "
+                "ppu_cfg[%d].crop.width: %d  "
+                "ppu_cfg[%d].crop.height: %d\n",
+                __func__,__LINE__,
+                i, config->ppu_cfg[i].crop.x,
+                i, config->ppu_cfg[i].crop.y,
+                i, config->ppu_cfg[i].crop.width,
+                i, config->ppu_cfg[i].crop.height);
+    }
+
+    //set scale paras,pp0 not support scale
+    for (int i = 1; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        // if config->ppu_cfg[i].enabled==0, scale is not assigned
+        if (!config->ppu_cfg[i].enabled ||
+            scale_paras[i].scale_width == 0 && scale_paras[i].scale_height == 0) {
+            continue;
+        }
+        pp_enabled = 1;
+
+        if (!(scale_paras[i].scale_width == 0 && scale_paras[i].scale_height == 0)) {
+            config->ppu_cfg[i].scale.enabled = 1;
+            config->ppu_cfg[i].scale.width = scale_paras[i].scale_width;
+            config->ppu_cfg[i].scale.height = scale_paras[i].scale_height;
+            log_debug(dec_ctx,
+                      "[%s:%d]  ppu_cfg[%d].scale.width: %d   "
+                      "ppu_cfg[%d].scale.height: %d",
+                      __func__, __LINE__,
+                      i, config->ppu_cfg[i].scale.width,
+                      i, config->ppu_cfg[i].scale.height);
+        }
+    }
+
+    dec_ctx->pp_enabled = pp_enabled;
+
+    return SUCCESS;
+}
+
+static int esjdec_dec_init_ppu_cfg(JDECContext *dec_ctx)
+{
+    struct DecConfig *config = &dec_ctx->jdec_config;
+    enum DecPictureFormat dstpicfmt;
+    int ret = 0;
+
+    if (dec_ctx->scale_set == NULL)
+        log_error(dec_ctx, "scale_set is null\n");
+
+    dstpicfmt = ff_codec_pixfmt_to_decfmt(dec_ctx->output_format[0]);
+    if(IS_PIC_RGB(dstpicfmt) && dec_ctx->cfg_pp_enabled[0] == 1) {
+        log_error(dec_ctx, "cannot set pp0 output format as rgb.\n",dec_ctx->pp_out);
+        return FAILURE;
+    }
+
+    if (dec_ctx->cfg_pp_enabled[0] == 1 && dec_ctx->cfg_pp_enabled[1] == 0) {
+        if(dec_ctx->pp_out == 1) {
+            log_error(dec_ctx, "pp_out=1, pp1 disable.\n",dec_ctx->pp_out);
+            return FAILURE;
+        }
+    } else if (dec_ctx->cfg_pp_enabled[0] == 0 && dec_ctx->cfg_pp_enabled[1] == 1) {
+        if(dec_ctx->pp_out == 0) {
+            log_error(dec_ctx, "pp_out=0, but pp0 disable.\n",dec_ctx->pp_out);
+            return FAILURE;
+        }
+    } else if (dec_ctx->cfg_pp_enabled[0] == 0 && dec_ctx->cfg_pp_enabled[1] == 0) {
+        log_error(dec_ctx, "pp0,pp1 are both disable.\n",dec_ctx->pp_out);
+        return FAILURE;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (dec_ctx->cfg_pp_enabled[i] == 1) {
+            dec_ctx->pp_count++;
+        }
+        config->ppu_cfg[i].enabled = dec_ctx->cfg_pp_enabled[i];
+    }
+
+    //set crop and scale
+    ret = esjdec_set_ppu_crop_and_scale(dec_ctx);
+    if (ret < 0) {
+        log_error(dec_ctx, "pp0,pp1 are both disable.\n",dec_ctx->pp_out);
+        return FAILURE;
+    }
+
+    //set output_format
+    ret = esjdec_set_ppu_output_format(dec_ctx);
+    if (ret < 0) {
+        log_error(dec_ctx, "set ppu output format failed.\n",dec_ctx->pp_out);
+        return FAILURE;
+    }
+
+    dec_ctx->pp_enabled = 1;
+
+    return SUCCESS;
+}
+
+static int esjdec_reorder_packet_enqueue(JDECContext *dec_ctx, ReorderPkt *pkt) {
+    int ret = FAILURE;
+    if (!dec_ctx || !pkt) {
+        return FAILURE;
+    }
+
+    ret = es_reorder_packet_enqueue(dec_ctx->reorder_queue, pkt);
+    return ret;
+}
+
+static int esjdec_reorder_pkt_dequeue(JDECContext *dec_ctx, int pic_id, struct ReorderPkt *out_pkt) {
+    int ret;
+    if (!dec_ctx || !out_pkt) {
+        return FAILURE;
+    }
+
+    ret = es_reorder_packet_dequeue(dec_ctx->reorder_queue, pic_id, out_pkt);
+    return ret;
+}
+
+static int esjdec_set_default_dec_config(JDECContext *dec_ctx)
+{
+    int ret = 0;
+
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dec_ctx is invaild\n");
+        return FAILURE;
+    }
+
+    dec_ctx->align = esdec_get_align(dec_ctx->stride_align);
+    dec_ctx->dwl_init.client_type = DWL_CLIENT_TYPE_JPEG_DEC;
+
+    dec_ctx->pic_display_number = 0;
+    dec_ctx->got_package_number = 0;
+    dec_ctx->pic_decode_number = 0;
+    dec_ctx->pic_output_number = 0;
+    dec_ctx->got_inputbuf_number = 0;
+    dec_ctx->drop_pkt_number = 0;
+    dec_ctx->prev_width = 0;
+    dec_ctx->prev_height = 0;
+    dec_ctx->frame_dump_handle[0] = NULL;
+    dec_ctx->frame_dump_handle[1] = NULL;
+    dec_ctx->pkt_dump_handle = NULL;
+    dec_ctx->thumb_exist = 0;
+    dec_ctx->thumb_out = 0;
+    dec_ctx->thumb_done = 0;
+    dec_ctx->need_out_buf_for_thumb = 0;
+    dec_ctx->codec = ES_JPEG;
+    dec_ctx->pp_count = 0;
+
+    dec_ctx->jdec_config.align = dec_ctx->align;
+    dec_ctx->jdec_config.dec_image_type = JPEGDEC_IMAGE;
+    memset(dec_ctx->jdec_config.ppu_cfg, 0, sizeof(dec_ctx->jdec_config.ppu_cfg));
+    memset(dec_ctx->jdec_config.delogo_params, 0, sizeof(dec_ctx->jdec_config.delogo_params));
+
+#ifdef MODEL_SIMULATION
+    g_hw_build_id = 0x1FB1;
+    g_hw_ver = 19001;
+    g_hw_id = 1000;
+#endif
+
+    dec_ctx->reorder_queue = es_queue_create();
+    if (!dec_ctx->reorder_queue) {
+        log_error(dec_ctx, "reorder_queue create failed\n");
+        return FAILURE;
+    }
+    dec_ctx->store_reorder_pkt = esjdec_reorder_packet_enqueue;
+    dec_ctx->get_reorder_pkt_by_pic_id = esjdec_reorder_pkt_dequeue;
+
+    dec_ctx->frame = av_frame_alloc();
+    if (!dec_ctx->frame) {
+        log_error(dec_ctx, "av_frame_alloc failed\n");
+        return FAILURE;
+    }
+
+    if (dec_ctx->fdump) {
+        dec_ctx->frame_dump[0] = dec_ctx->cfg_pp_enabled[0];
+        dec_ctx->frame_dump[1] = dec_ctx->cfg_pp_enabled[1];
+    }
+
+    return ret;
+}
+
+int ff_jdec_set_dec_config(JDECContext *dec_ctx) {
+    int ret = SUCCESS;
+    if (!dec_ctx) {
+        log_error(NULL, "dec_ctx is invaild\n");
+        return FAILURE;
+    }
+
+    // set default paras
+    ret = esjdec_set_default_dec_config(dec_ctx);
+    if (ret < 0){
+        log_error(dec_ctx, "esjdec_set_default_dec_config failed\n");
+        return FAILURE;
+    } else {
+        log_info(dec_ctx, "esjdec_set_default_dec_config success\n");
+    }
+
+    // set ppu config
+    ret = esjdec_dec_init_ppu_cfg(dec_ctx);
+    if (ret < 0){
+        log_error(dec_ctx, "esjdec_dec_init_ppu_cfg failed\n");
+        return FAILURE;
+    } else {
+        log_info(dec_ctx, "esjdec_dec_init_ppu_cfg success\n");
+    }
+
+    return ret;
+}
+
+static enum DecRet esjdec_set_jpeg_info(const void *inst, struct DecConfig config)
+{
+    struct JpegDecConfig dec_cfg;
+    dec_cfg.dec_image_type = config.dec_image_type;
+    dec_cfg.align = config.align;
+
+    DWLmemcpy(dec_cfg.ppu_config, config.ppu_cfg, sizeof(config.ppu_cfg));
+    DWLmemcpy(dec_cfg.delogo_params, config.delogo_params, sizeof(config.delogo_params));
+
+    return JpegDecSetInfo(inst, &dec_cfg);
+}
+
+static int esdec_thumb_mem_fd_split(void *dwl_inst,
+                                        void *dec_inst,
+                                        ESThumbOutputMemory *memory,
+                                        struct DecConfig *dec_config) {
+    int ret = SUCCESS;
+    int dma_fd;
+    int pp_count = 0;
+
+    if (!dwl_inst || !dec_inst || !memory || !dec_config) {
+        log_error(NULL,
+                  "error !!! dwl_inst: %p, dec_inst: %p, memory: %p, dec_config: %p\n",
+                  dwl_inst,
+                  dec_inst,
+                  memory,
+                  dec_config);
+
+        return FAILURE;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        memory->fd[i] = -1;
+    }
+
+    if (ESDecIsSimulation()) {
+        return SUCCESS;
+    }
+
+    dma_fd = ESDecGetDmaBufFd(&memory->mem);
+    if (dma_fd < 0) {
+        log_error(NULL, "dma fd is error dma_fd: %d\n", dma_fd);
+        return FAILURE;
+    }
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (dec_config->ppu_cfg[i].enabled) {
+            memory->fd[i] = dma_fd;
+            pp_count++;
+        }
+    }
+    log_info(NULL, "pp_count: %d\n", pp_count);
+
+    if (pp_count == ES_VID_DEC_MAX_OUT_COUNT) {
+        ret = ESDecGetDmaFdSplit(dwl_inst, dec_inst, dma_fd, memory->fd, ES_VID_DEC_MAX_OUT_COUNT);
+    }
+
+    return ret;
+}
+
+static int esjdec_allocate_thumbnail_memory(ESThumbOutputMemory *thumb_mem,
+                                            void* dec_inst,
+                                            struct AVBufferRef *dwl_ref,
+                                            struct DecConfig *dec_config) {
+    struct DWLLinearMem *mem;
+    struct DecBufferInfo info;
+    AVBufferRef *buffer_ref;
+    void *dwl_inst;
+    enum DecRet rv;
+
+    if (!thumb_mem || !dec_inst || !dwl_ref || !dwl_ref->data || !dec_config) {
+        log_error(NULL, "dec_inst or dwl_inst is null dec_inst: %p, dec_config: %p\n", dec_inst, dec_config);
+        return FAILURE;
+    }
+
+    rv = JpegDecGetBufferInfo(dec_inst, &info);
+    if (rv != DEC_OK) {
+        log_error(NULL, "JpegDecGetBufferInfo failed, rv: %d\n", rv);
+        return FAILURE;
+    }
+
+    dwl_inst = dwl_ref->data;
+
+    if (info.next_buf_size != 0) {
+        mem = &thumb_mem->mem;
+        mem->mem_type = DWL_MEM_TYPE_DPB;
+        if (DWLMallocLinear(dwl_inst, info.next_buf_size, mem) != DWL_OK) {
+            log_error(NULL, "DWLMallocLinear failed size: %d\n", info.next_buf_size);
+            return FAILURE;
+        }
+        if (mem->virtual_address == NULL) {
+            log_error(NULL, "virtual_address is null\n");
+            return FAILURE;
+        }
+
+        struct ESDecoderWrapper esdec;
+        esdec.codec = DEC_JPEG;
+        esdec.inst = dec_inst;
+        esdec_thumb_mem_fd_split(dwl_inst, &esdec, &thumb_mem, dec_config);
+
+        thumb_mem->virtual_address = mem->virtual_address;
+
+        rv = JpegDecAddBuffer(dec_inst, mem);
+        log_info(NULL, "thumbnail output virtual_addres: %p, rv: %d\n", mem->virtual_address, rv);
+        if (rv == DEC_OK) {
+            log_debug(NULL, "DecAddBuffer return DEC_OK\n");
+            thumb_mem->state = No_Use;
+        } else {
+            log_error(NULL, "DecAddBuffer failed, rv: %d\n", rv);
+            return FAILURE;
+        }
+    }
+
+    return SUCCESS;
+}
+
+static int esjdec_release_thumbnail_memory(ESThumbOutputMemory *thumb_mem, struct AVBufferRef *dwl_ref)
+{
+    int dma_fd = -1;
+    void *dwl_inst;
+
+    if (!thumb_mem || !dwl_ref || !dwl_ref->data) {
+        log_error(NULL, "thumb_mem or dwl_inst is null thumb_mem: %p, dwl_ref: %p\n", thumb_mem, dwl_ref);
+        return FAILURE;
+    }
+
+    if (thumb_mem->state == No_Use) {
+        log_info(NULL, "thumbnail memory is not allocated, do not need to release\n");
+        return SUCCESS;
+    }
+
+    dwl_inst = dwl_ref->data;
+
+    dma_fd = ESDecGetDmaBufFd(&thumb_mem->mem);
+    log_info(NULL,
+             "thumbnail memory dma_fd: %d, size: %d, virtual_address: %p\n",
+             dma_fd,
+             thumb_mem->mem.size,
+             thumb_mem->mem.virtual_address);
+
+    for (int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if (thumb_mem->fd[i] >= 0) {
+            if (dma_fd != thumb_mem->fd[i]) {
+                log_info(NULL, "output buffer close  pp_fd[%d]: %d\n", i, thumb_mem->fd[i]);
+                close(thumb_mem->fd[i]);
+            }
+
+            thumb_mem->fd[i] = -1;
+        }
+    }
+
+    DWLFreeLinear(dwl_inst, &thumb_mem->mem);
+
+    return SUCCESS;
+}
+
+static enum DecRet esjdec_decode_one_pic(void* inst, struct DecInputParameters* jpeg_in)
+{
+    enum DecRet rv;
+    JpegDecInput jpeg_input;
+    JpegDecOutput jpeg_out;
+    DWLmemset(&jpeg_input, 0, sizeof(jpeg_input));
+    DWLmemset(&jpeg_out, 0, sizeof(jpeg_out));
+
+    jpeg_input.stream_buffer =jpeg_in->stream_buffer;
+    jpeg_input.stream_length = jpeg_in->strm_len;
+    jpeg_input.buffer_size = jpeg_in->buffer_size;
+    jpeg_input.dec_image_type = jpeg_in->dec_image_type;
+    jpeg_input.slice_mb_set = jpeg_in->slice_mb_set;
+    jpeg_input.ri_count = jpeg_in->ri_count;
+    jpeg_input.ri_array = jpeg_in->ri_array;
+    jpeg_input.picture_buffer_y = jpeg_in->picture_buffer_y;
+    jpeg_input.picture_buffer_cb_cr = jpeg_in->picture_buffer_cb_cr;
+    jpeg_input.picture_buffer_cr = jpeg_in->picture_buffer_cr;
+    jpeg_input.p_user_data = jpeg_in->p_user_data;
+    jpeg_input.stream = jpeg_in->stream;
+
+    rv = JpegDecDecode(inst, &jpeg_input, &jpeg_out);
+
+    esjdec_print_decode_return(rv);
+
+    return rv;
+}
+
+static int esjdec_decode(JDECContext *dec_ctx,
+                         InputBuffer *input_buffer,
+                         struct DecSequenceInfo *sequence_info,
+                         int *peek_frame) {
+    int ret = SUCCESS;
+    enum DecRet rv;
+    ReorderPkt reorder_pkt;
+    struct DWLLinearMem *buffer = NULL;
+
+    if (!dec_ctx || !input_buffer || !peek_frame) {
+        log_error(dec_ctx, "error dec_ctx: %p, buffer: %p\n", dec_ctx, input_buffer);
+        return FAILURE;
+    }
+    *peek_frame = 0;
+    log_debug(dec_ctx, "input_buffer->size: %d\n", input_buffer->size);
+
+    reorder_pkt.pts = input_buffer->pts;
+    reorder_pkt.reordered_opaque = input_buffer->reordered_opaque;
+
+    sequence_info->jpeg_input_info.pic_id = dec_ctx->pic_decode_number;
+    dec_ctx->pic_id = dec_ctx->pic_decode_number;
+
+    do {
+        ret = esjdec_decode_one_pic((void* )dec_ctx->dec_inst, &sequence_info->jpeg_input_info);
+
+        switch (ret) {
+            case DEC_PIC_RDY:
+                reorder_pkt.pic_id = dec_ctx->pic_decode_number;
+                if (dec_ctx->store_reorder_pkt) {
+                    dec_ctx->store_reorder_pkt(dec_ctx, &reorder_pkt);
+                }
+                dec_ctx->pic_decode_number += 1;
+                *peek_frame = 1;
+                log_info(dec_ctx, "\t-JPEG: DEC_PIC_RDY\n");
+                break;
+            case DEC_SCAN_PROCESSED:
+                log_info(dec_ctx, "\t-JPEG: DEC_PIC_RDY\n");
+                break;
+            case DEC_SLICE_RDY:
+                log_info(dec_ctx, "\t-JPEG: DEC_SLICE_RDY\n");
+                break;
+            case DEC_NO_DECODING_BUFFER:
+                if (!dec_ctx->output_port) {
+                    dec_ctx->output_port =
+                    esdec_allocate_output_port(dec_ctx->codec, dec_ctx->dec_inst, dec_ctx->dwl_ref, dec_ctx->pp_count);
+                    if (!dec_ctx->output_port) {
+                        break;
+                    }
+                }
+                if (dec_ctx->got_inputbuf_number == 2) {
+                    esjdec_enlarge_out_port(dec_ctx, dec_ctx->output_buf_num);
+                }
+                ret = esdec_wait_picture_consumed_until_timeout(dec_ctx->codec,
+                                                                dec_ctx->dec_inst,
+                                                                dec_ctx->output_port,
+                                                                20 /*ms*/);
+                if (ret == AVERROR_EXIT) {
+                   return ret;
+                }
+            case DEC_WAITING_FOR_BUFFER:
+                if (!dec_ctx->output_port) {
+                    dec_ctx->output_port =
+                    esdec_allocate_output_port(dec_ctx->codec, dec_ctx->dec_inst, dec_ctx->dwl_ref, dec_ctx->pp_count);
+                    if (!dec_ctx->output_port) {
+                        break;
+                    }
+                }
+            case DEC_STRM_PROCESSED:
+                log_debug(dec_ctx, "\t-JPEG: DEC_STRM_PROCESSED\n");
+                break;
+            case DEC_STRM_ERROR:
+                log_debug(dec_ctx, "\t-JPEG: DEC_STRM_ERROR\n");
+                return FAILURE;
+            default:
+                log_error(dec_ctx, "jpegdecode return: %d\n", ret);
+                return FAILURE;
+        }
+    } while (ret != DEC_PIC_RDY);
+
+    return SUCCESS;
+}
+
+static void esjdec_init_input_paras(InputBuffer *buffer, struct DecInputParameters *jpeg_in) {
+    jpeg_in->stream_buffer.virtual_address = (u32 *) buffer->vir_addr;
+    jpeg_in->stream_buffer.bus_address =  (addr_t)buffer->bus_address;
+    jpeg_in->stream_buffer.logical_size =(u32) buffer->logical_size;
+    jpeg_in->stream = (u8 *) buffer->vir_addr;
+    jpeg_in->strm_len = buffer->size;
+    jpeg_in->buffer_size = 0;
+    jpeg_in->dec_image_type = JPEGDEC_IMAGE;
+}
+
+static int esjdec_set_image_type(JDECContext *dec_ctx,
+                                  struct DecSequenceInfo *sequence_info)
+{
+    int ret = SUCCESS;
+
+    if(sequence_info->thumbnail_type == JPEGDEC_THUMBNAIL_JPEG) {
+        if (dec_ctx->thumb_mode == Only_Decode_Thumb) {
+            sequence_info->jpeg_input_info.dec_image_type = JPEGDEC_THUMBNAIL;
+            dec_ctx->thumb_out = 1;
+        } else if (dec_ctx->thumb_mode == Only_Decode_Pic) {
+            sequence_info->jpeg_input_info.dec_image_type = JPEGDEC_IMAGE;
+        } else {
+            sequence_info->jpeg_input_info.dec_image_type = JPEGDEC_THUMBNAIL;
+            dec_ctx->thumb_out = 1;
+            dec_ctx->need_out_buf_for_thumb = 1;
+        }
+        log_debug(NULL, "thumbnail exits\n");
+    } else if((sequence_info->thumbnail_type == JPEGDEC_NO_THUMBNAIL)
+                ||(sequence_info->thumbnail_type == JPEGDEC_THUMBNAIL_NOT_SUPPORTED_FORMAT)) {
+        if (dec_ctx->thumb_mode == Only_Decode_Thumb) {
+            ret = FAILURE;
+            log_error(NULL, "no thumbnail exits\n");
+        } else {
+            sequence_info->jpeg_input_info.dec_image_type = JPEGDEC_IMAGE;
+        }
+    }
+
+    // if thumbnail and pic both need to decode, 
+    // and thumbnail has decoded, next we will decode pic
+    if (dec_ctx->thumb_mode == Decode_Pic_Thumb && dec_ctx->thumb_done) {
+        sequence_info->jpeg_input_info.dec_image_type = JPEGDEC_IMAGE;
+        dec_ctx->thumb_out = 0;
+        dec_ctx->need_out_buf_for_thumb = 0;
+    }
+
+    return ret;
+}
+
+static int esjdec_decode_and_get_next_picture(JDECContext *dec_ctx,
+                                              InputBuffer *input_buffer) {
+    int *peek_frame;
+    int ret = SUCCESS;
+    enum DecRet rv;
+    struct DecSequenceInfo *sequence_info = &dec_ctx->sequence_info;
+
+    // set input info para according to input buffer
+    esjdec_init_input_paras(input_buffer, &sequence_info->jpeg_input_info);
+
+    do {
+        ret = esjdec_get_image_info((void *)dec_ctx->dec_inst, sequence_info, &dec_ctx->jdec_config);
+        if(ret < 0) {
+            log_error(dec_ctx, "esjdec_get_image_info failed\n");
+            return FAILURE;
+        }
+
+        ret = esjdec_set_image_type(dec_ctx, sequence_info);
+        if (ret < 0) {
+            log_error(dec_ctx, "esjdec_set_image_type failed\n");
+            return FAILURE;
+        }
+
+        ret = esjdec_modify_config_by_image_info(dec_ctx, sequence_info);
+        if (ret < 0) {
+            log_error(dec_ctx, "esjdec_modify_config_by_image_info failed\n");
+            return FAILURE;
+        }
+
+        // init pkt dump handle
+        esjdec_init_pkt_dump_handle(dec_ctx, sequence_info);
+
+        esjdec_modify_thum_config_by_image_info(sequence_info, &dec_ctx->jdec_config, dec_ctx->thumb_out);
+
+        rv = esjdec_set_jpeg_info((void* )dec_ctx->dec_inst, dec_ctx->jdec_config);
+         if(rv != DEC_OK) {
+            log_error(NULL, "esjdec_set_jpeg_info failed, rv: %d\n", rv);
+            return FAILURE;
+        }
+
+        if (dec_ctx->need_out_buf_for_thumb) {
+            ret = esjdec_allocate_thumbnail_memory(&dec_ctx->thumb_mem,
+                                                   dec_ctx->dec_inst,
+                                                   dec_ctx->dwl_ref,
+                                                   &dec_ctx->jdec_config);
+            if (ret == FAILURE) {
+                log_error(dec_ctx, "esjdec_allocate_thumbnail_memory failed\n");
+                return FAILURE;
+            }
+            dec_ctx->need_out_buf_for_thumb = 0;
+        }
+
+        ret = esjdec_decode(dec_ctx, input_buffer, sequence_info, &peek_frame);
+        if (ret == AVERROR_EXIT) {
+            break;
+        } else if (peek_frame) {
+            ret = esjdec_get_next_picture(dec_ctx);
+            if (ret == FAILURE) {
+                log_error(dec_ctx,
+                        "esjdec_get_next_picture failed, pic_decode_number: %d\n",
+                        dec_ctx->pic_decode_number);
+                break;
+            }
+        }
+
+        if(dec_ctx->thumb_mode == Decode_Pic_Thumb && dec_ctx->thumb_out) {
+            dec_ctx->thumb_out = 0;
+            dec_ctx->thumb_done = 1;
+        } else {
+            break;
+        }
+    }while(1);
+
+    return ret;
+}
+
+static void *esjdec_decode_thread_run(void *ctx) {
+    int ret = FAILURE;
+    int end_stream = FALSE;
+    int peek_frame;
+    int abort_request = FALSE;
+    InputBuffer buffer;
+    ESInputPort *input_port;
+    JDECContext *dec_ctx = (JDECContext *)ctx;
+    if (!dec_ctx || !dec_ctx->input_port) {
+        log_error(dec_ctx, "error !!! dec_ctx or input_port is null\n");
+        return NULL;
+    }
+
+    input_port = dec_ctx->input_port;
+
+    while (!abort_request) {
+        ret = esdec_get_input_packet_buffer(input_port->packet_queue, &buffer);
+        if (ret == AVERROR_EXIT) {
+            log_info(dec_ctx, "decode thread will be exit\n");
+            abort_request = TRUE;
+            continue;
+        } else if (ret < 0) {
+            continue;
+        } else {
+            dec_ctx->got_inputbuf_number++;
+            log_info(dec_ctx, "got_inputbuf_number: %d\n", dec_ctx->got_inputbuf_number);
+        }
+
+        ret = esdec_wait_picture_consumed_until_timeout(dec_ctx->codec,
+                                                        dec_ctx->dec_inst,
+                                                        dec_ctx->output_port,
+                                                        0 /*without waiting*/);
+        if (ret == AVERROR_EXIT) {
+            abort_request = TRUE;
+            continue;
+        }
+
+        if (buffer.size <= 0) {
+            esjdec_eos_process(dec_ctx);
+            end_stream = TRUE;
+            continue;
+        }
+
+        ret = esjdec_decode_and_get_next_picture(dec_ctx, &buffer);
+        if (ret == AVERROR_EXIT) {
+            abort_request = TRUE;
+            continue;
+        }
+
+        //  dump packet
+        ret = esjdec_pkt_dump(dec_ctx, &buffer);
+
+        log_info(dec_ctx, "release input buffer\n");
+        esdec_release_input_buffer(input_port->release_queue, &buffer);
+    }
+
+    esdec_output_port_clear(dec_ctx->output_port, esdec_picture_consume);
+    if (dec_ctx->reorder_queue) {
+        es_reorder_queue_clear(dec_ctx->reorder_queue);
+        av_freep(&dec_ctx->reorder_queue);
+    }
+
+    if (dec_ctx->reorder_pkt) {
+        av_freep(&dec_ctx->reorder_pkt);
+    }
+
+    if (!end_stream) {
+        log_info(dec_ctx, "dec end stream\n");
+        JpegDecEndOfStream(dec_ctx->dec_inst);
+    }
+
+    if (dec_ctx->picture) {
+        av_freep(&dec_ctx->picture);
+    }
+
+    if (dec_ctx->frame) {
+        av_frame_free(&dec_ctx->frame);
+    }
+    av_buffer_unref(&dec_ctx->hwframe);
+    av_buffer_unref(&dec_ctx->hwdevice);
+
+    return NULL;
+}
+
+int ff_jdec_decode_start(JDECContext *dec_ctx)
+{
+    if (!dec_ctx) {
+        log_error(dec_ctx, "error !!! dec_ctx is null\n");
+        return FAILURE;
+    }
+
+    if (pthread_create(&dec_ctx->tid, NULL, esjdec_decode_thread_run, dec_ctx)) {
+        log_info(dec_ctx, "esdec_decode_thread_run create failed\n");
+        return FAILURE;
+    }
+
+    log_info(dec_ctx, "esdec_decode_thread_run create success\n");
+
+    return SUCCESS;
+}
+
+static int esjdec_init_jpeg_config(JDECContext *dec_ctx, struct JpegDecConfig *dec_cfg)
+{
+    if (!dec_ctx || !dec_cfg) {
+        log_error(dec_ctx, "esjdec_init_jpeg_config input paras invalid\n");
+        return FAILURE;
+    }
+
+    struct DecConfig *config = &dec_ctx->jdec_config;
+
+    dec_ctx->dwl_inst = (void *)DWLInit(&dec_ctx->dwl_init);
+    if (dec_ctx->dwl_inst == NULL) {
+        log_error(dec_ctx, "DWL Init failed\n");
+        return FAILURE;
+    } else {
+        log_debug(dec_ctx, "DWL Init success\n");
+    }
+
+    dec_ctx->dwl_ref = av_buffer_create(
+        (uint8_t *)dec_ctx->dwl_inst, sizeof(dec_ctx->dwl_inst), esdec_dwl_release, NULL, AV_BUFFER_FLAG_READONLY);
+
+    if ((dec_ctx->decode_mode & DEC_LOW_LATENCY) != 0) {
+        dec_ctx->low_latency = 1;
+    }
+
+    dec_cfg->decoder_mode = DEC_NORMAL;
+    if (dec_ctx->low_latency)
+        dec_cfg->decoder_mode = DEC_LOW_LATENCY;
+
+    dec_cfg->align = config->align;
+    dec_cfg->mcinit_cfg.mc_enable = 0;
+    dec_cfg->mcinit_cfg.stream_consumed_callback = NULL;
+    memcpy(dec_cfg->ppu_config, config->ppu_cfg, sizeof(config->ppu_cfg));
+    memcpy(dec_cfg->delogo_params, config->delogo_params, sizeof(config->delogo_params));
+
+    return SUCCESS;
+}
+
+int ff_jdec_jpegdec_init(JDECContext *dec_ctx)
+{
+    struct JpegDecConfig dec_cfg;
+    ESInputPort *input_port;
+    int ret = SUCCESS;
+
+    ret = esjdec_init_jpeg_config(dec_ctx, &dec_cfg);
+    if (ret) {
+        log_error(dec_ctx, "init jpeg config failed\n");
+        return FAILURE;
+    }
+
+    input_port = esdec_allocate_input_port(dec_ctx->codec, dec_ctx->dwl_ref, &dec_ctx->dwl_init, 1);
+    if (input_port) {
+        dec_ctx->input_port = input_port;
+    } else {
+        log_info(dec_ctx, "es_decode_allocate_input_port failed\n");
+        return FAILURE;
+    }
+
+    ret = JpegDecInit(&dec_ctx->dec_inst, dec_ctx->dwl_inst, &dec_cfg);
+
+    if(ret) {
+        log_error(dec_ctx, "JpegDecInit failed, ret: %d\n", ret);
+        return FAILURE;
+    } else {
+        log_info(dec_ctx, "JpegDecInit success\n");
+    }
+
+    return ret;
+}
+
+static enum AVPixelFormat esjdec_get_format(JDECContext *dec_ctx) {
+    enum AVPixelFormat format = AV_PIX_FMT_NV12;
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dec_ctx is null\n");
+        return AV_PIX_FMT_NONE;
+    }
+
+    for (int i = 0; i < DEC_MAX_PPU_COUNT; i++) {
+        if (dec_ctx->cfg_pp_enabled[i] && dec_ctx->pp_out == i) {
+            format = dec_ctx->output_format[i];
+            log_debug(dec_ctx, "target pp: %d, format: %d\n", i, format);
+            break;
+        }
+    }
+
+    return format;
+}
+
+int ff_jdec_decode_close(JDECContext *dec_ctx) {
+    int ret = SUCCESS;
+    if (!dec_ctx) {
+        log_error(dec_ctx, "dec_ctx is null\n");
+        return FAILURE;
+    }
+
+    esdec_input_port_stop(dec_ctx->input_port);
+    esdec_output_port_stop(dec_ctx->output_port);
+
+    pthread_join(dec_ctx->tid, NULL);
+
+    ret = esjdec_release_thumbnail_memory(&dec_ctx->thumb_mem, dec_ctx->dwl_ref);
+    if (ret == FAILURE) {
+        log_info(dec_ctx, "release thumbnail memory failed\n");
+    }
+
+    if (dec_ctx->dec_inst) {
+        JpegDecRelease(dec_ctx->dec_inst);
+        dec_ctx->dec_inst = NULL;
+        log_info(NULL, "dec_inst release success\n");
+    }
+
+    esdec_input_port_unref(&dec_ctx->input_port);
+    esdec_output_port_unref(&dec_ctx->output_port);
+
+    av_buffer_unref(&dec_ctx->dwl_ref);
+
+    log_info(dec_ctx, "es_decode_close success\n");
+
+    return SUCCESS;
+}
+
+int ff_jdec_init_hwctx(AVCodecContext *avctx)
+{
+    int ret = 0;
+    AVHWFramesContext *hw_frames_ctx;
+    JDECContext *dec_ctx = avctx->priv_data;
+
+    avctx->sw_pix_fmt = esjdec_get_format(dec_ctx);
+    enum AVPixelFormat pix_fmts[3] = {AV_PIX_FMT_ES, avctx->sw_pix_fmt, AV_PIX_FMT_NONE};
+    avctx->pix_fmt = ff_get_format(avctx, pix_fmts);
+    log_info(dec_ctx,
+           "avctx sw_pix_fmt: %s, pix_fmt: %s\n",
+            av_get_pix_fmt_name(avctx->sw_pix_fmt),
+            av_get_pix_fmt_name(avctx->pix_fmt));
+
+    if (avctx->hw_frames_ctx) {
+        dec_ctx->hwframe = av_buffer_ref(avctx->hw_frames_ctx);
+        if (!dec_ctx->hwframe) {
+            log_error(dec_ctx, "init hwframe failed\n");
+            return AVERROR(ENOMEM);
+        }
+    } else {
+        if (avctx->hw_device_ctx) {
+            log_info(avctx, "avctx->hw_device_ctx = %p\n", avctx->hw_device_ctx);
+            dec_ctx->hwdevice = av_buffer_ref(avctx->hw_device_ctx);
+            if (!dec_ctx->hwdevice) {
+                log_error(dec_ctx, "init hwdevice failed\n");
+                return AVERROR(ENOMEM);
+            }
+            log_info(avctx, "dec_ctx->hwdevice = %p\n", dec_ctx->hwdevice);
+        } else {
+            ret = av_hwdevice_ctx_create(&dec_ctx->hwdevice,
+                                         AV_HWDEVICE_TYPE_ES,
+                                         "es",
+                                         NULL,
+                                         0);
+            if (ret < 0) {
+                log_error(dec_ctx, "av_hwdevice_ctx_create failed\n");
+                return FAILURE;
+            }
+        }
+
+        dec_ctx->hwframe = av_hwframe_ctx_alloc(dec_ctx->hwdevice);
+        if (!dec_ctx->hwframe) {
+            log_error(dec_ctx, "av_hwframe_ctx_alloc failed\n");
+            return AVERROR(ENOMEM);
+        }
+
+        hw_frames_ctx = (AVHWFramesContext *)dec_ctx->hwframe->data;
+        hw_frames_ctx->format = AV_PIX_FMT_ES;
+        hw_frames_ctx->sw_format = avctx->sw_pix_fmt;
+    }
+
+    if (avctx->pix_fmt == AV_PIX_FMT_ES) {
+        dec_ctx->extra_hw_frames = avctx->extra_hw_frames > 1 ? avctx->extra_hw_frames : 1;
+    }
+
+    log_info(avctx,
+            "dec_ctx extra_hw_frames: %d, avctx extra_hw_frames: %d\n",
+            dec_ctx->extra_hw_frames,
+            avctx->extra_hw_frames);
+
+    return SUCCESS;
+}
\ No newline at end of file
diff --git a/libavcodec/esjdecapi.h b/libavcodec/esjdecapi.h
new file mode 100644
index 0000000000..470e2ee0c1
--- /dev/null
+++ b/libavcodec/esjdecapi.h
@@ -0,0 +1,179 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ESJDECAPI_H
+#define AVCODEC_ESJDECAPI_H
+
+#include "deccfg.h"
+#include "dectypes.h"
+#include "avcodec.h"
+#include "hwconfig.h"
+#include "internal.h"
+#include "decode.h"
+#include "libavutil/opt.h"
+#include "libavutil/imgutils.h"
+#include "es_common.h"
+#include <stdlib.h>
+#include <linux/limits.h>
+#include "es_common.h"
+#include "esdec_common.h"
+#include "es_codec_private.h"
+#include "libavutil/hwcontext_es.h"
+#include "eslog.h"
+
+#ifndef NEXT_MULTIPLE
+#define NEXT_MULTIPLE(value, n) (((value) + (n) - 1) & ~((n) - 1))
+#endif
+
+#ifndef ALIGN
+#define ALIGN(a) (1 << (a))
+#endif
+
+
+enum ThumbMode {
+    Only_Decode_Pic = 0,
+    Only_Decode_Thumb,
+    Decode_Pic_Thumb
+};
+
+enum ThumbMemState {
+    No_Use = 0,
+    Using,
+    Used
+};
+
+typedef struct _ESThumbOutputMemory {
+    int flag;
+    int target_pp;
+    enum ThumbMemState state;
+    int fd[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t *virtual_address;
+    struct DWLLinearMem mem;
+    struct DecPicturePpu picture;
+} ESThumbOutputMemory;
+
+typedef struct JDECContext JDECContext;
+
+typedef int (*StoreReorderPktFunction)(JDECContext *dec_ctx, struct ReorderPkt *reorder_pkt);
+typedef int (*GetReorderPktFunction)(JDECContext *dec_ctx, int pic_id, struct ReorderPkt *out_pkt);
+
+struct JDECContext{
+    const AVClass *class;
+    AVPacket avpkt;
+    AVFrame *frame;
+
+    char *pp_setting[ES_VID_DEC_MAX_OUT_COUNT];
+    char *scale_set;
+    char * crop_set[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t stride_align;
+
+    uint32_t packet_dump;
+    char *dump_path;
+    uint32_t packet_dump_time;
+    DumpHandle *frame_dump_handle[ES_VID_DEC_MAX_OUT_COUNT];
+    DumpHandle *pkt_dump_handle;
+    uint32_t frame_dump[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t fdump;
+    uint32_t frame_dump_time[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t drop_frame_interval;
+
+    uint32_t thumb_exist;
+    uint32_t thumb_done;
+    uint32_t thumb_out;//whether to output thumbnails 0-output only original image 1-output only thumbnails
+    uint32_t thumb_mode;
+    uint32_t need_out_buf_for_thumb;
+    ESThumbOutputMemory thumb_mem;
+
+    AVCodecContext *avctx;
+    AVBufferRef *hwdevice;
+    AVBufferRef *hwframe;
+    int extra_hw_frames;
+    ESDecState state;
+
+    DecPicAlignment align;  /* default: 64 bytes alignment */
+    uint32_t prev_width;
+    uint32_t prev_height;
+
+    uint32_t output_format[ES_VID_DEC_MAX_OUT_COUNT];
+
+    uint32_t pp_enabled;
+    int32_t pp_fmt[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t cfg_pp_enabled[ES_VID_DEC_MAX_OUT_COUNT];
+    uint32_t pp_out;//control output PP0 or PP
+    uint32_t pp_count;
+
+    ESJDecInst dec_inst;
+    struct DWLInitParam dwl_init;
+    void *dwl_inst;
+    struct AVBufferRef *dwl_ref;
+
+    uint32_t pic_display_number;
+    uint32_t pic_decode_number;
+    uint32_t pic_output_number;
+    uint32_t got_package_number;
+    uint32_t got_inputbuf_number;
+    uint32_t drop_pkt_number;
+    uint32_t decode_mode;
+    uint32_t low_latency;
+    uint32_t low_latency_sim;
+
+    struct ESInputPort *input_port;
+    struct ESOutputPort *output_port;
+    struct AVBufferRef *input_port_ref;
+    struct AVBufferRef *output_port_ref;
+
+    struct ReorderPkt *reorder_pkt;
+    struct ESQueue *reorder_queue;
+    StoreReorderPktFunction store_reorder_pkt;
+    GetReorderPktFunction get_reorder_pkt_by_pic_id;
+    uint32_t pic_id;
+    int64_t reordered_opaque;
+
+    int32_t input_buf_num;
+    int32_t output_buf_num;
+    ESDecCodec codec;
+
+    struct DecPicturePpu pic_out;
+    struct DecPicturePpu *picture;
+
+    struct DecConfig jdec_config;
+    struct JpegDecConfig *dec_cfg;
+    struct DecSequenceInfo sequence_info;
+
+    pthread_t tid;
+};
+
+int ff_jdec_init_hwctx(AVCodecContext *avctx);
+
+int ff_jdec_set_dec_config(JDECContext *dec_ctx);
+
+int ff_jdec_jpegdec_init(JDECContext *dec_ctx);
+
+int ff_jdec_decode_start(JDECContext *dec_ctx);
+
+int ff_jdec_decode_close(JDECContext *dec_ctx);
+
+int ff_jdec_get_frame(JDECContext *dec_ctx, AVFrame *frame, int timeout_ms);
+
+int ff_jdec_send_packet(JDECContext *dec_ctx, AVPacket *pkt, int timeout);
+
+int ff_jdec_send_packet_receive_frame(JDECContext *dec_ctx, AVPacket *pkt, AVFrame *frame);
+
+#endif
diff --git a/libavcodec/esjdecode.c b/libavcodec/esjdecode.c
new file mode 100644
index 0000000000..eb3266c162
--- /dev/null
+++ b/libavcodec/esjdecode.c
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "esjdecapi.h"
+#include "jpegdecapi.h"
+#include "encode.h"
+#include "codec_internal.h"
+
+#define NEXT_MULTIPLE(value, n) (((value) + (n) - 1) & ~((n) - 1))
+#define ALIGN(a) (1 << (a))
+
+static av_cold int ff_es_jpeg_decode_close(AVCodecContext *avctx)
+{
+    JDECContext *dec_ctx = avctx->priv_data;
+    int i;
+
+    log_info(avctx, "Es jpeg decode close.....\n");
+
+    if (dec_ctx->state != ESDEC_STATE_CLOSED) {
+        dec_ctx->state = ESDEC_STATE_CLOSED;
+        ff_jdec_decode_close(dec_ctx);
+    }
+
+    if (dec_ctx->pkt_dump_handle)
+        ff_codec_dump_file_close(&dec_ctx->pkt_dump_handle);
+
+    for ( int i = 0; i < ES_VID_DEC_MAX_OUT_COUNT; i++) {
+        if(dec_ctx->frame_dump_handle[i]) {
+            ff_codec_dump_file_close(&dec_ctx->frame_dump_handle[i]);
+        }
+    }
+
+    return 0;
+}
+
+static av_cold int ff_es_jpeg_decode_init(AVCodecContext *avctx)
+{
+    JDECContext *dec_ctx = avctx->priv_data;
+    JpegDecApiVersion dec_api;
+    enum DecRet rv;
+    int ret = 0;
+    dec_ctx->avctx = avctx;
+
+    dec_api = JpegGetAPIVersion();
+    log_info(avctx, "Jpeg Decoder API v%d.%d\n", dec_api.major, dec_api.minor);
+
+    ret = ff_jdec_init_hwctx(avctx);
+    if (ret < 0) {
+        log_error(dec_ctx, "esjdec_init_hwctx failed\n");
+        return ret;
+    } else {
+        log_info(avctx, "esjdec_init_hwctx ok\n");
+    }
+
+    ret = ff_jdec_set_dec_config(dec_ctx);
+    if (ret < 0){
+        log_error(dec_ctx, "esjdec_set_dec_config failed\n");
+        return ret;
+    } else {
+        log_info(avctx, "esjdec_set_dec_config success\n");
+    }
+
+    rv = ff_jdec_jpegdec_init(dec_ctx);
+    if (rv < 0) {
+        log_error(dec_ctx, "esjdec_jpegdec_init failed!\n");
+         return FAILURE;
+    } else {
+        log_info(avctx, "esjdec_jpegdec_init success!\n");
+    }
+
+    rv = ff_jdec_decode_start(dec_ctx);
+    if (rv < 0) {
+        log_error(dec_ctx, "esjdec_decode_start failed!\n");
+         return FAILURE;
+    } else {
+        dec_ctx->state = ESDEC_STATE_STARTED;
+        avctx->apply_cropping = 0;//for RGB format can output
+        log_info(avctx, "esjdec_decode_start success!\n");
+    }
+
+    return SUCCESS;
+}
+
+static int ff_es_jpeg_eof_proc(JDECContext *dec_ctx, AVFrame *frame) {
+    int ret;
+    if (!dec_ctx) {
+        return AVERROR(EINVAL);
+    }
+
+    log_info(dec_ctx, "dec_ctx->state: %d\n", dec_ctx->state);
+    if (dec_ctx->state == ESDEC_STATE_STARTED) {
+        ret = ff_jdec_send_packet(dec_ctx, NULL, -1 /*always waiting*/);
+        if (ret == SUCCESS) {
+            dec_ctx->state = ESDEC_STATE_STOPPING;
+            log_info(dec_ctx, "send eos packet success enter stopping\n");
+        } else {
+            dec_ctx->state = ESDEC_STATE_STOPPED;
+            log_info(dec_ctx, "dec_ctx->state: %d\n", dec_ctx->state);
+        }
+    }
+
+    if (dec_ctx->state == ESDEC_STATE_STOPPING) {
+        ret = ff_jdec_get_frame(dec_ctx, frame, -1 /* always waiting */);
+        if (ret == AVERROR_EOF || ret == AVERROR_EXIT) {
+            dec_ctx->state = ESDEC_STATE_STOPPED;
+            log_info(dec_ctx, "recv eof decode enter stopped\n");
+        } else {
+            log_info(dec_ctx, "decode state stopping get frame ret: %d\n", ret);
+        }
+    }
+
+    return ret;
+}
+
+static int ff_es_jpeg_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    int ret = SUCCESS;
+    JDECContext *dec_ctx;
+    AVPacket *avpkt;
+    AVFrame *tmp_frame;
+
+    if (!avctx || !avctx->priv_data || !frame) {
+        log_error(dec_ctx, "avctx or private or frame is null avctx: %p, frame: %p\n", avctx, frame);
+        return AVERROR(EINVAL);
+    }
+
+    dec_ctx = (JDECContext *)avctx->priv_data;
+    avpkt = &dec_ctx->avpkt;
+    tmp_frame = dec_ctx->frame;
+
+    if (dec_ctx->state == ESDEC_STATE_UNINIT) {
+        log_error(dec_ctx, "dec_ctx state: %d error\n", dec_ctx->state);
+        return AVERROR(EINVAL);
+    } else if (dec_ctx->state == ESDEC_STATE_STOPPED || dec_ctx->state == ESDEC_STATE_CLOSED) {
+        log_warn(dec_ctx, "dec_ctx state: %d closed\n", dec_ctx->state);
+        return AVERROR_EOF;
+    }
+
+    do {
+        if (dec_ctx->state == ESDEC_STATE_STOPPING) {
+            ret = ff_es_jpeg_eof_proc(dec_ctx, frame);
+            break;
+        }
+
+        if (!avpkt->data || avpkt->size <= 0) {
+            ret = ff_decode_get_packet(avctx, avpkt);
+            log_debug(dec_ctx, "ff_decode_get_packet ret: 0x%x, size: %d\n", ret, avpkt->size);
+            if (ret == SUCCESS) {
+                dec_ctx->got_package_number ++;
+                dec_ctx->reordered_opaque = avctx->reordered_opaque;
+                log_debug(dec_ctx, "ff_decode_get_packet success\n");
+            }
+        } else {
+            log_debug(dec_ctx, "use last pkt size: %d\n", avpkt->size);
+        }
+
+        if (ret == AVERROR(EAGAIN)) {
+            ret = ff_jdec_get_frame(dec_ctx, frame, 0 /*without waiting*/);
+            if (ret == FAILURE) {
+                ret = AVERROR(EAGAIN);
+                log_debug(dec_ctx, "EAGAIN ret: %d\n", ret);
+            }
+            break;
+        } else if (ret == AVERROR_EOF) {
+            ret = ff_es_jpeg_eof_proc(dec_ctx, frame);
+            break;
+        } else if (ret < 0) {
+            log_error(dec_ctx, "ff_decode_get_packet failed ret: 0x%x\n", ret);
+            break;
+        }
+
+        ret = ff_jdec_send_packet_receive_frame(dec_ctx, avpkt, frame);
+    } while (0);
+
+    if (ret == SUCCESS) {
+        if (avctx->width != frame->width || avctx->height != frame->height) {
+            avctx->width = frame->width;
+            avctx->height = frame->height;
+        }
+
+        if (avctx->pix_fmt == AV_PIX_FMT_ES || frame->flags & AV_FRAME_FLAG_DISCARD) {
+            frame->format = AV_PIX_FMT_ES;
+            frame->hw_frames_ctx = av_buffer_ref(dec_ctx->hwframe);
+        } else {
+            av_frame_move_ref(tmp_frame, frame);
+            ret = ff_get_buffer(avctx, frame, 0);
+            if (ret < 0) {
+                log_error(dec_ctx, "ff_get_buffer failed\n");
+            } else {
+                frame->pts = tmp_frame->pts;
+                tmp_frame->hw_frames_ctx = av_buffer_ref(dec_ctx->hwframe);
+                ret = av_hwframe_transfer_data(frame, tmp_frame, 0);
+                if (ret) {
+                    log_error(dec_ctx, "av_hwframe_transfer_data failed\n");
+                }
+            }
+            av_frame_unref(tmp_frame);
+        }
+    }
+
+    return ret;
+}
+
+static void ff_es_jpeg_decode_flush(AVCodecContext *avctx)
+{
+}
+
+#define OFFSET(x) offsetof(JDECContext, x)
+#define VD AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM
+static const AVOption options[] = {
+    { "stride_align", "set out_stride", OFFSET(stride_align),
+        AV_OPT_TYPE_INT,  { .i64 = 64 }, 1, 2048, VD },
+    { "pp0_enabled", "set pp0 output enable", OFFSET(cfg_pp_enabled[0]),
+        AV_OPT_TYPE_INT,  { .i64 = 1 }, 0, 1, VD },
+    { "pp0_format", "set ppu0 output format", OFFSET(output_format[0]),
+        AV_OPT_TYPE_INT,  { .i64 = 23 }, 0, INT_MAX, VD },
+    { "pp0_set", "set pp configure", OFFSET(pp_setting[0]),
+        AV_OPT_TYPE_STRING, {.str=NULL}, 0, 0, VD }, //pp0 not support scale
+    { "pp1_enabled", "set pp0 output enable", OFFSET(cfg_pp_enabled[1]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "pp1_format", "set ppu1 output format", OFFSET(output_format[1]),
+        AV_OPT_TYPE_INT,  { .i64 = 23 }, 0, INT_MAX, VD },
+    { "pp1_set", "set pp configure", OFFSET(pp_setting[1]),
+        AV_OPT_TYPE_STRING, {.str=NULL}, 0, 0, VD },
+    { "packet_dump", "set dump packet", OFFSET(packet_dump),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "dump_path", "set dump packet path", OFFSET(dump_path),
+        AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VD },
+    { "packet_dump_time", "set dump packet time", OFFSET(packet_dump_time),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, INT_MAX, VD },
+    { "pp0_frame_dump", "set pp0 frame dump", OFFSET(frame_dump[0]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 60, VD },
+    { "pp1_frame_dump", "set pp1 frame dump", OFFSET(frame_dump[1]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 60, VD },
+    { "pp0_frame_dump_time", "set dump pp0 frame time", OFFSET(frame_dump_time[0]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, INT_MAX, VD },
+    { "pp1_frame_dump_time", "set dump pp1 frame time", OFFSET(frame_dump_time[1]),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, INT_MAX, VD },
+    { "drop_frame_interval", "set drop frame interval", OFFSET(drop_frame_interval),
+        AV_OPT_TYPE_INT,  {.i64 = 0 }, 0, INT_MAX, VD },
+    { "thumb_mode", "0: only decode picture, 1: only decode thumbnail, 2: decode thumbnail and picture.",
+        OFFSET(thumb_mode), AV_OPT_TYPE_INT,  {.i64 = Decode_Pic_Thumb }, 0, 2, VD, "thumbmode"},
+    { "decode_pic", "0: only decode picture",  0,
+        AV_OPT_TYPE_CONST, { .i64 = Only_Decode_Pic } , 0, 2, VD, "thumbmode"},
+    { "decode_thumb", "1: only decode thumbnail",  0,
+        AV_OPT_TYPE_CONST, { .i64 = Only_Decode_Thumb } , 0, 2, VD, "thumbmode"},
+    { "decode_both", "2: decode thumbnail and picture",  0,
+        AV_OPT_TYPE_CONST, { .i64 = Decode_Pic_Thumb } , 0, 2, VD, "thumbmode"},
+    { "decode_mode", "decode mode: dec_normal, dec_low_latency",  OFFSET(decode_mode),
+        AV_OPT_TYPE_INT, { .i64 =  DEC_NORMAL} , 0, 8, VD, "decode_mode"},
+    { "dec_normal", "decode mode: dec_normal",  0,
+        AV_OPT_TYPE_CONST, { .i64 =  DEC_NORMAL} , 0, 8, VD, "decode_mode"},
+    { "dec_low_latency", "decode mode: dec_low_latency",  0,
+        AV_OPT_TYPE_CONST, { .i64 =  DEC_LOW_LATENCY} , 0, 8, VD, "decode_mode"},
+    { "input_buf_num", "inputbuffer queue size",  0,
+        AV_OPT_TYPE_CONST, { .i64 =  0} , 0, 40, VD, "input_buf_num"},
+    { "output_buf_num", "outputbuffer queue size",  0,
+        AV_OPT_TYPE_CONST, { .i64 =  0} , 0, 40, VD, "output_buf_num"},
+
+    // ffmpeg set opts
+    { "down_scale", "width:height or ratio_x:ratio_y", OFFSET(scale_set),
+        AV_OPT_TYPE_STRING, { .str="0:0" }, 0, 0, VD },
+    { "pp0_crop", "crop (top)x(bottom)x(left)x(right)", OFFSET(crop_set[0]),
+        AV_OPT_TYPE_STRING, { .str=NULL }, 0, 0, VD },
+    { "pp1_crop", "crop (top)x(bottom)x(left)x(right)", OFFSET(crop_set[1]),
+        AV_OPT_TYPE_STRING, { .str=NULL }, 0, 0, VD },
+    { "frame_dump", "frame dump enable, next set filename better", OFFSET(fdump),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "pp0", "PP0 output enable",  OFFSET(cfg_pp_enabled[0]),
+        AV_OPT_TYPE_INT, { .i64 = 1 }, 0, 1, VD, "enable pp"},
+    { "pp1", "PP1 output enable",  OFFSET(cfg_pp_enabled[1]),
+        AV_OPT_TYPE_INT, { .i64 = 0 }, 0, 1, VD, "enable pp"},
+    { "pp_out", "set pp output enable", OFFSET(pp_out),
+        AV_OPT_TYPE_INT,  { .i64 = 0 }, 0, 1, VD },
+    { "enable", "enable pp",  0,
+        AV_OPT_TYPE_CONST, { .i64 = 1 } , 0, 1, VD, "enable pp"},
+    { "disable", "disable pp",  0,
+        AV_OPT_TYPE_CONST, { .i64 = 0 } , 0, 0, VD, "enable pp"},
+    { "pp0_fmt", "set pp0 output format",  OFFSET(output_format[0]),
+        AV_OPT_TYPE_INT, { .i64 = 23 } , 0, 194, VD, "pp0_fmt"},
+    { "pp1_fmt", "set pp1 output format",  OFFSET(output_format[1]),
+        AV_OPT_TYPE_INT, { .i64 = 23 } , 0, 194, VD, "pp1_fmt"},
+
+    // set pp0 format
+    { "nv12", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_NV12 } , 0, 194, VD, "pp0_fmt"},
+    { "nv21", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_NV21 } , 0, 194, VD, "pp0_fmt"},
+    { "yuv420p", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_YUV420P } , 0, 194, VD, "pp0_fmt"},
+    { "gray", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_GRAY8 } , 0, 194, VD, "pp0_fmt"},
+    // set pp1 format
+    { "nv12", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_NV12 } , 0, 194, VD, "pp1_fmt"},
+    { "nv21", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_NV21 } , 0, 194, VD, "pp1_fmt"},
+    { "yuv420p", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_YUV420P } , 0, 194, VD, "pp1_fmt"},
+    { "gray", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_GRAY8 } , 0, 194, VD, "pp1_fmt"},
+    { "rgb24", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_RGB24 } , 0, 194, VD, "pp1_fmt"},
+    { "bgr24", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_BGR24 } , 0, 194, VD, "pp1_fmt"},
+    { "argb", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_ARGB } , 0, 194, VD, "pp1_fmt"},
+    { "abgr", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_ABGR } , 0, 194, VD, "pp1_fmt"},
+    { "0rgb", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_0RGB } , 0, 194, VD, "pp1_fmt"},
+    { "0bgr", "output format",  0,
+        AV_OPT_TYPE_CONST, { .i64 = AV_PIX_FMT_0BGR } , 0, 194, VD, "pp1_fmt"},
+    { NULL },
+};
+
+static const AVClass es_jpeg_decode_class = {
+    .class_name = "es_jpeg_decoder",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+static const FFCodecDefault es_jpeg_decode_defaults[] = {
+    { NULL },
+};
+
+static const enum AVPixelFormat es_jdec_support_pixfmts[] = {AV_PIX_FMT_ES,
+                                                             AV_PIX_FMT_YUV420P,
+                                                             AV_PIX_FMT_NV12,
+                                                             AV_PIX_FMT_NV21,
+                                                             AV_PIX_FMT_GRAY8,
+                                                             AV_PIX_FMT_NONE};
+
+static const AVCodecHWConfigInternal *es_hw_configs[] = {
+    &(const AVCodecHWConfigInternal) {
+        .public = {
+            .pix_fmt     = AV_PIX_FMT_ES,
+            .methods     = AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX
+                           | AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX
+                           | AV_CODEC_HW_CONFIG_METHOD_INTERNAL,
+            .device_type = AV_HWDEVICE_TYPE_ES,
+        },
+        .hwaccel = NULL,
+    },
+    NULL
+};
+
+FFCodec ff_jpeg_es_decoder = {
+    .p.name           = "jpeg_es_decoder",
+    .p.long_name      = NULL_IF_CONFIG_SMALL("Eswin JPEG decoder, on VeriSilicon & GStreamer & FFmpeg."),
+    .p.type           = AVMEDIA_TYPE_VIDEO,
+    .p.id             = AV_CODEC_ID_MJPEG,
+    .priv_data_size = sizeof(JDECContext),
+    .init           = &ff_es_jpeg_decode_init,
+    .close          = &ff_es_jpeg_decode_close,
+    FF_CODEC_RECEIVE_FRAME_CB(ff_es_jpeg_decode_receive_frame),
+    .flush          = &ff_es_jpeg_decode_flush,
+    .p.priv_class     = &es_jpeg_decode_class,
+    .p.capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE | AV_CODEC_CAP_AVOID_PROBING,
+    .defaults       = es_jpeg_decode_defaults,
+    .p.pix_fmts       = es_jdec_support_pixfmts,
+    .hw_configs     = es_hw_configs,
+    .p.wrapper_name   = "es",
+    //.bsfs           = "mjpeg2jpeg",
+};
\ No newline at end of file
diff --git a/libavcodec/eslog.h b/libavcodec/eslog.h
new file mode 100644
index 0000000000..2141662976
--- /dev/null
+++ b/libavcodec/eslog.h
@@ -0,0 +1,30 @@
+
+#ifndef AVCODEC_ES_LOG_H__
+#define AVCODEC_ES_LOG_H__
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <libavutil/log.h>
+
+#define es_gettid() syscall(__NR_gettid)
+#ifndef LOG_TAG
+#define LOG_TAG "escodec"
+#endif
+
+#define log_info(avcl, fmt, ...) \
+    av_log(avcl, AV_LOG_INFO, "%s [tid:%ld][%s][%d]" fmt, LOG_TAG, es_gettid(), __FUNCTION__, __LINE__, ##__VA_ARGS__)
+#define log_error(avcl, fmt, ...)                 \
+    av_log(avcl,                                  \
+           AV_LOG_ERROR,                          \
+           "%s [tid:%ld][%s][%d] error !!! " fmt, \
+           LOG_TAG,                               \
+           es_gettid(),                           \
+           __FUNCTION__,                          \
+           __LINE__,                              \
+           ##__VA_ARGS__)
+#define log_debug(avcl, fmt, ...) \
+    av_log(avcl, AV_LOG_DEBUG, "%s [tid:%ld][%s][%d]" fmt, LOG_TAG, es_gettid(), __FUNCTION__, __LINE__, ##__VA_ARGS__)
+#define log_warn(avcl, fmt, ...) \
+    av_log(                      \
+        avcl, AV_LOG_WARNING, "%s [tid:%ld][%s][%d]" fmt, LOG_TAG, es_gettid(), __FUNCTION__, __LINE__, ##__VA_ARGS__)
+
+#endif
\ No newline at end of file
diff --git a/libavcodec/esqueue.c b/libavcodec/esqueue.c
new file mode 100644
index 0000000000..4c37bde9e0
--- /dev/null
+++ b/libavcodec/esqueue.c
@@ -0,0 +1,439 @@
+#define LOG_TAG "esqueue"
+#include <sys/time.h>
+#include "esqueue.h"
+#include "eslog.h"
+#include "es_common.h"
+
+static int32_t get_clock_time_by_timeout(struct timespec *ts, int32_t timeout_ms) {
+    int64_t reltime_sec;
+    int64_t time_sec;
+
+    if (!ts || timeout_ms <= 0) {
+        log_error(NULL, "error  ts: %p, timeout_ms: %d", ts, timeout_ms);
+        return -1;
+    }
+
+    clock_gettime(CLOCK_MONOTONIC, ts);
+
+    reltime_sec = timeout_ms / 1000;
+    ts->tv_nsec += (long)(timeout_ms % 1000 * 1000000);
+    if (reltime_sec < INT64_MAX && ts->tv_nsec >= 1000000000) {
+        ts->tv_nsec -= 1000000000;
+        ++reltime_sec;
+    }
+
+    time_sec = ts->tv_sec;
+    if (time_sec > INT64_MAX - reltime_sec) {
+        time_sec = INT64_MAX;
+    } else {
+        time_sec += reltime_sec;
+    }
+
+    ts->tv_sec = (time_sec > LONG_MAX) ? LONG_MAX : (long)(time_sec);
+
+    return 0;
+}
+
+void es_queue_init(ESQueue *q) {
+    if (q == NULL) {
+        return;
+    }
+    q->head = q->tail = NULL;
+    q->length = 0;
+}
+
+ESQueue *es_queue_create() {
+    ESQueue *q = (ESQueue *)malloc(sizeof(ESQueue));
+    if (q) {
+        es_queue_init(q);
+    }
+
+    return q;
+}
+
+int es_queue_destroy(ESQueue *q) {
+    if (!q) return -1;
+
+    free(q);
+    q = NULL;
+    return 0;
+}
+
+void *es_queue_peek_head(ESQueue *q) {
+    void *data = NULL;
+    if (q == NULL) {
+        return NULL;
+    }
+    if (q->head) {
+        data = q->head->data;
+    }
+
+    return data;
+}
+
+void *es_queue_pop_head(ESQueue *q) {
+    void *data = NULL;
+    if (q == NULL) {
+        return NULL;
+    }
+
+    if (q->head) {
+        List *node = q->head;
+        data = node->data;
+        q->head = node->next;
+        if (q->head) {
+            q->head->prev = NULL;
+        } else {
+            q->tail = NULL;
+        }
+        q->length--;
+        free(node);
+    }
+
+    return data;
+}
+
+static List *es_list_append(List *list, void *data) {
+    List *new_list;
+    new_list = (List *)malloc(sizeof(List));
+    if (new_list == NULL) {
+        return NULL;
+    }
+
+    new_list->data = data;
+    new_list->next = NULL;
+    if (list) {
+        list->next = new_list;
+        new_list->prev = list;
+    } else {
+        new_list->prev = NULL;
+    }
+    return new_list;
+}
+
+void *es_queue_peek_tail(ESQueue *q) {
+    void *data = NULL;
+    if (q == NULL) {
+        return NULL;
+    }
+    if (q->tail) {
+        data = q->tail->data;
+    }
+
+    return data;
+}
+
+int es_queue_push_tail(ESQueue *q, void *data) {
+    if (q == NULL) {
+        return -1;
+    }
+
+    q->tail = es_list_append(q->tail, data);
+    if (q->tail == NULL) {
+        return -1;
+    }
+
+    if (!q->tail->prev) {
+        q->head = q->tail;
+    }
+    q->length++;
+
+    return 0;
+}
+
+int es_queue_push_front(ESQueue *q, void *data) {
+    List *new_list;
+    if (!q) {
+        return -1;
+    }
+
+    new_list = (List *)malloc(sizeof(List));
+    if (!new_list) {
+        return -1;
+    }
+
+    new_list->data = data;
+    new_list->next = NULL;
+    new_list->prev = NULL;
+
+    if (!q->head) {
+        q->tail = q->head = new_list;
+    } else {
+        new_list->next = q->head;
+        q->head->prev = new_list;
+        q->head = new_list;
+    }
+    q->length++;
+
+    return 0;
+}
+
+int es_queue_is_empty(ESQueue *q) {
+    int ret = -1;
+
+    if (q == NULL || q->head == NULL) {
+        ret = 0;
+    }
+
+    return ret;
+}
+
+int es_queue_get_length(ESQueue *q) {
+    int length = 0;
+    if (q) {
+        length = q->length;
+    }
+
+    return length;
+}
+
+static void es_queue_delete_node(ESQueue *q, List *node) {
+    if (!q || !node) {
+        return;
+    }
+
+    if (node->prev) {
+        node->prev->next = node->next;
+    } else {
+        q->head = node->next;
+    }
+
+    if (node->next) {
+        node->next->prev = node->prev;
+    } else {
+        q->tail = node->prev;
+    }
+
+    free(node);
+}
+
+int es_queue_delete_data(ESQueue *q, void *data) {
+    int ret = -1;
+    List *node = NULL;
+    if (q == NULL || q->head == NULL) {
+        return -1;
+    }
+
+    node = q->head;
+    while (node) {
+        if (node->data == data) {
+            ret = 0;
+            es_queue_delete_node(q, node);
+            break;
+        } else {
+            node = node->next;
+        }
+    }
+
+    return ret;
+}
+
+/*************************************************************************************
+ *  fifo queue
+ *************************************************************************************/
+
+ESFifoQueue *es_fifo_queue_create(size_t nmemb, int mem_size, const char *name) {
+    pthread_condattr_t attr;
+    ESFifoQueue *queue;
+    if (nmemb <= 0 || mem_size < 0) {
+        return NULL;
+    }
+
+    queue = av_mallocz(sizeof(*queue));
+    if (!queue) {
+        return NULL;
+    }
+
+    queue->fifo = av_fifo_alloc_array(nmemb, mem_size);
+    if (!queue->fifo) {
+        av_freep(&queue);
+        return NULL;
+    }
+    queue->mem_size = mem_size;
+    queue->nmemb = nmemb;
+    queue->name = av_strdup(name);
+
+    pthread_condattr_init(&attr);
+    pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
+    pthread_cond_init(&queue->fifo_cond, &attr);
+    pthread_mutex_init(&queue->fifo_mutex, NULL);
+
+    return queue;
+}
+
+int es_fifo_queue_enlarge(ESFifoQueue *queue, size_t nmemb, int mem_size) {
+    pthread_condattr_t attr;
+    int ret = FAILURE;
+    int rv = 0;
+
+    if (!queue || !queue->fifo) {
+        return ret;
+    }
+
+    if (nmemb < 0) {
+        return ret;
+    }
+
+    pthread_mutex_lock(&queue->fifo_mutex);
+    rv = av_fifo_realloc2(queue->fifo, nmemb*mem_size);
+    if (rv >= 0) {
+        ret = SUCCESS;
+        pthread_cond_signal(&queue->fifo_cond);
+    } else {
+        log_error(NULL, "error !!! enlarge fifo space, nmemb: %d\n", nmemb);
+    }
+    pthread_mutex_unlock(&queue->fifo_mutex);
+
+    return ret;
+}
+
+void es_fifo_queue_free(ESFifoQueue **queue) {
+    ESFifoQueue *q;
+    if (!queue || !*queue) {
+        return;
+    }
+
+    q = *queue;
+    av_free(q->name);
+    pthread_mutex_destroy(&q->fifo_mutex);
+    pthread_cond_destroy(&q->fifo_cond);
+    av_fifo_freep(&q->fifo);
+    av_freep(queue);
+}
+
+int es_fifo_queue_push(ESFifoQueue *queue, void *src, int size) {
+    int ret = FAILURE;
+    int fifo_size;
+    if (!queue || !queue->fifo || !src) {
+        log_error(NULL, "params error!!! queue: %p, src: %p\n", queue, src);
+        return FAILURE;
+    }
+
+    if (queue->mem_size != size) {
+        log_error(NULL, "params error!!! size: %d, mem_size: %d\n", size, queue->mem_size);
+        return FAILURE;
+    }
+
+    pthread_mutex_lock(&queue->fifo_mutex);
+    fifo_size = av_fifo_space(queue->fifo);
+    if (fifo_size >= size) {
+        av_fifo_generic_write(queue->fifo, src, size, NULL);
+        ret = SUCCESS;
+        pthread_cond_signal(&queue->fifo_cond);
+    } else {
+        log_error(NULL, "error !!! fifo_size: %d, size: %d\n", fifo_size, size);
+    }
+    pthread_mutex_unlock(&queue->fifo_mutex);
+
+    return ret;
+}
+int es_fifo_queue_pop(ESFifoQueue *queue, void *dest, int dest_size) {
+    int ret = SUCCESS;
+    int fifo_size;
+    if (!queue || !queue->fifo || !dest || queue->mem_size != dest_size) {
+        log_error(NULL, "params error!!! dest_size: %d\n", dest_size);
+        return FAILURE;
+    }
+
+    pthread_mutex_lock(&queue->fifo_mutex);
+    if (!queue->abort_request) {
+        fifo_size = av_fifo_size(queue->fifo);
+        if (fifo_size < dest_size) {
+            if (fifo_size != 0) {
+                log_error(NULL, "error fifo_size: %d, dest_size: %d\n", fifo_size, dest_size);
+            }
+            pthread_cond_wait(&queue->fifo_cond, &queue->fifo_mutex);
+            fifo_size = av_fifo_size(queue->fifo);
+            if (fifo_size < dest_size) {
+                log_warn(NULL, "wait success but fifo_size: %d error dest_size: %d\n", fifo_size, dest_size);
+                ret = FAILURE;
+            }
+        }
+
+        if (ret == SUCCESS) {
+            ret = av_fifo_generic_read(queue->fifo, dest, dest_size, NULL);
+        }
+    } else {
+        ret = FAILURE;
+        log_info(NULL, "pop failed %s queue abort_request\n", queue->name);
+    }
+    pthread_mutex_unlock(&queue->fifo_mutex);
+
+    return ret;
+}
+
+int es_fifo_queue_pop_ignore_abort(ESFifoQueue *queue, void *dest, int dest_size) {
+    int ret = FAILURE;
+    int fifo_size;
+    if (!queue || !queue->fifo || !dest || queue->mem_size != dest_size) {
+        log_error(NULL, "params error!!! dest_size: %d\n", dest_size);
+        return FAILURE;
+    }
+
+    pthread_mutex_lock(&queue->fifo_mutex);
+    fifo_size = av_fifo_size(queue->fifo);
+    log_info(NULL, "fifo_size: %d, dest_size: %d\n", fifo_size, dest_size);
+    if (fifo_size >= dest_size) {
+        ret = SUCCESS;
+        av_fifo_generic_read(queue->fifo, dest, dest_size, NULL);
+    }
+    pthread_mutex_unlock(&queue->fifo_mutex);
+
+    return ret;
+}
+
+int es_fifo_queue_pop_until_timeout(ESFifoQueue *queue, void *dest, int dest_size, int timeout_ms) {
+    int ret = SUCCESS;
+    int fifo_size;
+    if (!queue || !queue->fifo || !dest || queue->mem_size != dest_size) {
+        log_error(NULL, "params error!!! dest_size: %d\n", dest_size);
+        return FAILURE;
+    }
+
+    pthread_mutex_lock(&queue->fifo_mutex);
+    if (!queue->abort_request) {
+        fifo_size = av_fifo_size(queue->fifo);
+        if (fifo_size < dest_size) {
+            if (fifo_size != 0) {
+                log_error(NULL, "error fifo_size: %d, dest_size: %d\n", fifo_size, dest_size);
+            }
+            if (timeout_ms == -1) {
+                pthread_cond_wait(&queue->fifo_cond, &queue->fifo_mutex);
+            } else if (timeout_ms > 0) {
+                struct timespec ts;
+                get_clock_time_by_timeout(&ts, timeout_ms);
+                ret = pthread_cond_timedwait(&queue->fifo_cond, &queue->fifo_mutex, &ts);
+            } else {
+                ret = FAILURE;
+            }
+
+            if (ret == SUCCESS) {
+                fifo_size = av_fifo_size(queue->fifo);
+                if (fifo_size < dest_size) {
+                    log_warn(NULL, "wait success but fifo_size: %d error dest_size: %d\n", fifo_size, dest_size);
+                    ret = FAILURE;
+                }
+            }
+        }
+        if (ret == SUCCESS) {
+            ret = av_fifo_generic_read(queue->fifo, dest, dest_size, NULL);
+        }
+    } else {
+        ret = FAILURE;
+        log_info(NULL, "pop failed %s queue abort_request\n", queue->name);
+    }
+    pthread_mutex_unlock(&queue->fifo_mutex);
+
+    return ret;
+}
+
+void es_fifo_queue_abort(ESFifoQueue *queue) {
+    if (!queue) {
+        return;
+    }
+    pthread_mutex_lock(&queue->fifo_mutex);
+    queue->abort_request = TRUE;
+    pthread_cond_broadcast(&queue->fifo_cond);
+    log_info(NULL, "%s request abort\n", queue->name);
+    pthread_mutex_unlock(&queue->fifo_mutex);
+}
diff --git a/libavcodec/esqueue.h b/libavcodec/esqueue.h
new file mode 100644
index 0000000000..041c598e7c
--- /dev/null
+++ b/libavcodec/esqueue.h
@@ -0,0 +1,56 @@
+#ifndef AVCODEC_ESQUEUE_H_
+#define AVCODEC_ESQUEUE_H_
+#include "libavutil/fifo.h"
+#include "libavutil/thread.h"
+
+typedef struct _List List;
+typedef struct ESQueue ESQueue;
+
+struct _List {
+    void *data;
+    List *next;
+    List *prev;
+};
+
+struct ESQueue {
+    List *head;
+    List *tail;
+    int length;
+};
+
+ESQueue *es_queue_create(void);
+int es_queue_destroy(ESQueue *q);
+void es_queue_init(ESQueue *q);
+void *es_queue_peek_head(ESQueue *q);
+void *es_queue_pop_head(ESQueue *q);
+int es_queue_is_empty(ESQueue *q);
+int es_queue_get_length(ESQueue *q);
+void *es_queue_peek_tail(ESQueue *q);
+int es_queue_push_tail(ESQueue *q, void *data);
+int es_queue_push_front(ESQueue *q, void *data);
+int es_queue_delete_data(ESQueue *q, void *data);
+
+/*************************************************************************************
+ *  fifo queue
+ *************************************************************************************/
+typedef struct ESFifoQueue {
+    int abort_request;
+    int mem_size;
+    int nmemb;
+    AVFifoBuffer *fifo;
+    char *name;
+    pthread_mutex_t fifo_mutex;
+    pthread_cond_t fifo_cond;
+} ESFifoQueue;
+
+ESFifoQueue *es_fifo_queue_create(size_t nmemb, int mem_size, const char *name);
+int es_fifo_queue_enlarge(ESFifoQueue *queue, size_t nmemb, int mem_size);
+void es_fifo_queue_free(ESFifoQueue **queue);
+int es_fifo_queue_push(ESFifoQueue *queue, void *src, int src_size);
+int es_fifo_queue_pop(ESFifoQueue *queue, void *dest, int dest_size);
+int es_fifo_queue_pop_ignore_abort(ESFifoQueue *queue, void *dest, int dest_size);
+void es_fifo_queue_abort(ESFifoQueue *queue);
+void es_fifo_queue_deinit(ESFifoQueue **queue);
+int es_fifo_queue_pop_until_timeout(ESFifoQueue *queue, void *dest, int dest_size, int timeout_ms);
+
+#endif
\ No newline at end of file
diff --git a/libavcodec/hwconfig.h b/libavcodec/hwconfig.h
index 721424912c..a4ac3e297c 100644
--- a/libavcodec/hwconfig.h
+++ b/libavcodec/hwconfig.h
@@ -78,6 +78,8 @@ typedef struct AVCodecHWConfigInternal {
     HW_CONFIG_HWACCEL(1, 1, 1, VIDEOTOOLBOX, VIDEOTOOLBOX, ff_ ## codec ## _videotoolbox_hwaccel)
 #define HWACCEL_D3D11VA(codec) \
     HW_CONFIG_HWACCEL(0, 0, 1, D3D11VA_VLD,  NONE,         ff_ ## codec ## _d3d11va_hwaccel)
+#define HWACCEL_ESDEC(codec) \
+    HW_CONFIG_HWACCEL(1, 1, 0, ES,          ES,         ff_ ## codec ## _esdec_hwaccel)
 
 #define HW_CONFIG_ENCODER(device, frames, ad_hoc, format, device_type_) \
     &(const AVCodecHWConfigInternal) { \
diff --git a/libavfilter/Makefile b/libavfilter/Makefile
index 30cc329fb6..accfb866c5 100644
--- a/libavfilter/Makefile
+++ b/libavfilter/Makefile
@@ -444,6 +444,7 @@ OBJS-$(CONFIG_SCALE_VULKAN_FILTER)           += vf_scale_vulkan.o vulkan.o vulka
 OBJS-$(CONFIG_SCALE2REF_FILTER)              += vf_scale.o scale_eval.o
 OBJS-$(CONFIG_SCALE2REF_NPP_FILTER)          += vf_scale_npp.o scale_eval.o
 OBJS-$(CONFIG_SCDET_FILTER)                  += vf_scdet.o
+OBJS-$(CONFIG_CONVERT_ES_FILTER)             += vf_convert_es.o esvfbuffer.o esvfqueue.o esvfcommon.o
 OBJS-$(CONFIG_SCHARR_FILTER)                 += vf_convolution.o
 OBJS-$(CONFIG_SCROLL_FILTER)                 += vf_scroll.o
 OBJS-$(CONFIG_SEGMENT_FILTER)                += f_segment.o
diff --git a/libavfilter/allfilters.c b/libavfilter/allfilters.c
index 5ebacfde27..42d1aa504c 100644
--- a/libavfilter/allfilters.c
+++ b/libavfilter/allfilters.c
@@ -578,6 +578,8 @@ extern  const AVFilter ff_vsink_buffer;
 extern const AVFilter ff_af_afifo;
 extern const AVFilter ff_vf_fifo;
 
+extern const AVFilter ff_vf_convert_es;
+
 #include "libavfilter/filter_list.c"
 
 
diff --git a/libavfilter/dnn/Makefile b/libavfilter/dnn/Makefile
index 4cfbce0efc..df31919027 100644
--- a/libavfilter/dnn/Makefile
+++ b/libavfilter/dnn/Makefile
@@ -16,5 +16,6 @@ OBJS-$(CONFIG_DNN)                           += dnn/dnn_backend_native_layer_mat
 
 DNN-OBJS-$(CONFIG_LIBTENSORFLOW)             += dnn/dnn_backend_tf.o
 DNN-OBJS-$(CONFIG_LIBOPENVINO)               += dnn/dnn_backend_openvino.o
+DNN-OBJS-$(CONFIG_ESUMD)                     += dnn/dnn_backend_umd.o
 
 OBJS-$(CONFIG_DNN)                           += $(DNN-OBJS-yes)
diff --git a/libavfilter/dnn/dnn_backend_umd.c b/libavfilter/dnn/dnn_backend_umd.c
new file mode 100644
index 0000000000..67c6432093
--- /dev/null
+++ b/libavfilter/dnn/dnn_backend_umd.c
@@ -0,0 +1,741 @@
+/*
+ * Copyright (c) 2018 Sergey Lavrushkin
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * DNN eswin umd backend implementation.
+ */
+
+#include "dnn_backend_umd.h"
+#include "libavformat/avio.h"
+#include "libavutil/avassert.h"
+#include "libavutil/avstring.h"
+#include "libavutil/cpu.h"
+#include "libavutil/opt.h"
+#include "libavutil/file.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/pixfmt.h"
+#include "libavutil/hwcontext.h"
+// #include "libavcodec/defs.h"
+#include "../internal.h"
+#include "dnn_backend_common.h"
+#include "safe_queue.h"
+#include "dnn_io_proc.h"
+#include "../esvfcommon.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "umd_wrapper.h"
+#ifdef __cplusplus
+}
+#endif
+
+#define ES_2D_ENABLE 1
+
+#define CHECK_PARAMS_INVALID(para)                                                                            \
+    if (!para) {                                                                                              \
+        av_log(NULL, AV_LOG_ERROR, "%s[%d]:" #para " invalid , Error: NULL params.", __FUNCTION__, __LINE__); \
+        return AVERROR(EINVAL);                                                                               \
+    }
+
+typedef struct UMDOptions {
+    uint8_t async;
+    uint32_t nireq;
+    char *test_input;
+    char *test_output;
+} UMDOptions;
+
+typedef struct UMDContext {
+    const AVClass *class;
+    UMDOptions options;
+} UMDContext;
+
+typedef struct TestData {
+    uint8_t *bufptr;
+    size_t size;
+} TestData;
+
+typedef struct UMDModel {
+    UMDContext ctx;
+    DNNModel *model;
+    UMDWarpper *umdWrapper;
+    TestData input_data;
+    TestData output_data;
+    Queue *lltask_queue;
+    Queue *task_queue;
+    UMDDescription input_desc;
+    UMDDescription output_desc;
+} UMDModel;
+
+#define OFFSET(x) offsetof(UMDContext, x)
+#define FLAGS AV_OPT_FLAG_FILTERING_PARAM
+static const AVOption dnn_umd_options[] = {
+    {"test_input", "umd input test", OFFSET(options.test_input), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, FLAGS},
+    {"test_output", "umd test_output", OFFSET(options.test_output), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, FLAGS},
+    DNN_BACKEND_COMMON_OPTIONS{NULL}};
+AVFILTER_DEFINE_CLASS(dnn_umd);
+
+static int read_file_bin(char *fname, TestData *test_data) {
+    AVIOContext *model_file_context;
+    uint8_t *data = NULL;
+    int file_size;
+    long bytes_read;
+    if (avio_open(&model_file_context, fname, AVIO_FLAG_READ) < 0) {
+        av_log(NULL, AV_LOG_ERROR, "read io faild \n ");
+        return -1;
+    }
+    file_size = avio_size(model_file_context);
+    av_log(NULL, AV_LOG_INFO, "  file_size:%d \n", file_size);
+    data = av_malloc(file_size);
+    if (!data) {
+        avio_closep(&model_file_context);
+        av_log(NULL, AV_LOG_ERROR, "read io faild \n ");
+        return -1;
+    }
+    bytes_read = avio_read(model_file_context, data, file_size);
+    avio_closep(&model_file_context);
+    if (bytes_read != file_size) {
+        av_freep(&data);
+        av_log(NULL, AV_LOG_ERROR, "read io faild \n ");
+        return -1;
+    }
+    for (size_t i = 0; i < 20; i++) {
+        av_log(NULL, AV_LOG_INFO, "%02x ", data[i]);
+    }
+    av_log(NULL, AV_LOG_INFO, " \n ");
+    test_data->bufptr = data;
+    test_data->size = bytes_read;
+    return 0;
+}
+
+static int read_file_txt(char *fname, TestData *test_data) {
+    return 0;
+}
+
+static int read_file_data(char *file, TestData *test_data) {
+    int ret = 0;
+    if (av_stristr(file, "bin") != NULL) {
+        av_log(NULL, AV_LOG_INFO, "file:%s it is bin file \n", file);
+        ret = read_file_bin(file, test_data);
+    } else if (av_stristr(file, "txt") != NULL) {
+        av_log(NULL, AV_LOG_INFO, "file:%s it is text file \n", file);
+        ret = read_file_txt(file, test_data);
+    }
+    return ret;
+}
+
+static int umd_got_mem_fd(const AVFrame *frame, int32_t *mem_fd) {
+    AVFrameSideData *sd = NULL;
+    if (!frame) return -1;
+    if (!frame->nb_side_data) return -1;
+
+    // mem fd
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_MEM_FRAME_FD);
+    if (sd) {
+        *mem_fd = *((int32_t *)sd->data);
+        av_log(NULL, AV_LOG_INFO, "got mem_fd: %x\n", *mem_fd);
+        return 0;
+    }
+
+    return -1;
+}
+
+static int umd_send_mem_fd(AVFrame *frame, int32_t mem_fd) {
+    int ret = SUCCESS;
+    AVFrameSideData *sd = NULL;
+
+    if (!frame) {
+        av_log(NULL, AV_LOG_ERROR, "frame is null\n");
+        return FAILURE;
+    }
+
+    av_log(NULL, AV_LOG_DEBUG, "umd_send_mem_fd: fd = %x\n", mem_fd);
+    sd = av_frame_new_side_data(frame, SIDE_DATA_TYPE_MEM_FRAME_FD_RELEASE, sizeof(mem_fd));
+    if (sd && sd->data) {
+        memcpy(sd->data, &mem_fd, sizeof(mem_fd));
+    } else {
+        ret = FAILURE;
+        av_log(NULL, AV_LOG_ERROR, "av_frame_new_side_data faild sd: %p\n", sd);
+    }
+
+    return ret;
+}
+
+static int calculate_frame_data_size(enum AVPixelFormat in_fmt, AVFrame *in) {
+    const AVPixFmtDescriptor *desc;
+    int height = 0;
+    int total_size = 0;
+
+    desc = av_pix_fmt_desc_get(in_fmt);
+    if (!desc) {
+        av_log(NULL,
+               AV_LOG_ERROR,
+               "convert_get_frame_data_size get fmt: %s AVPixFmtDescriptor failed.\n",
+               av_get_pix_fmt_name(in_fmt));
+        return FAILURE;
+    }
+
+    for (int i = 0; i < FF_ARRAY_ELEMS(in->data) && in->data[i]; i++) {
+        height = in->height;
+        if (i == 1 || i == 2) {
+            height = AV_CEIL_RSHIFT(height, desc->log2_chroma_h);
+        }
+        total_size += in->linesize[i] * height;
+    }
+
+    return total_size;
+}
+
+static int execute_model_umd(Queue *lltask_queue) {
+    UMDModel *umd_model = NULL;
+    UMDContext *ctx = NULL;
+    DNNData input, output;
+    UMD_MEMORY input_memory;
+    int32_t mem_fd;
+    uint64_t input_buf_size;
+    AVFrame *in_frame = NULL;
+    AVBufferRef *hw_frames_ctx = NULL;
+    AVHWFramesContext *in_hw_frames_ctx = NULL;
+
+    uint8_t *output_data = NULL;
+    UMD_MEMORY output_memory;
+    UMDDescription *output_desc = NULL;
+    UMDDescription *input_desc = NULL;
+
+    LastLevelTaskItem *lltask = NULL;
+    TaskItem *task = NULL;
+    int ret = 0;
+
+    UMD_MEMORY *input_umd_mem = NULL;
+
+    lltask = ff_queue_pop_front(lltask_queue);
+    if (!lltask) {
+        av_log(NULL, AV_LOG_ERROR, "Failed to get LastLevelTaskItem\n");
+        ret = AVERROR(EINVAL);
+        goto err;
+    }
+    task = lltask->task;
+    umd_model = task->model;
+    ctx = &umd_model->ctx;
+    in_frame = task->in_frame;
+
+    output_desc = &umd_model->output_desc;
+    input_desc = &umd_model->input_desc;
+
+#ifdef ES_2D_ENABLE
+    hw_frames_ctx = in_frame->hw_frames_ctx;
+    in_hw_frames_ctx = (AVHWFramesContext *)hw_frames_ctx->data;
+    input_buf_size = calculate_frame_data_size(in_hw_frames_ctx->sw_format, in_frame);
+    av_log(ctx,
+           AV_LOG_INFO,
+           "ES hwaccel mode. in_frame's fmt:%s, line_size:%d, height:%d, width:%d,bufsize:%ld\n",
+           av_get_pix_fmt_name(in_hw_frames_ctx->sw_format),
+           in_frame->linesize[0],
+           in_frame->height,
+           in_frame->width,
+           input_buf_size);
+
+    // check data is valid
+    if (input_buf_size != input_desc->bufferSize) {
+        av_log(NULL,
+               AV_LOG_ERROR,
+               "failed to compare data actual size:%ld, buffersize:%ld\n",
+               input_buf_size,
+               input_desc->bufferSize);
+        ret = AVERROR(EINVAL);
+        goto err;
+    }
+
+    input.height = input_desc->dims.h;
+    input.width = input_desc->dims.w;
+    input.channels = input_desc->dims.c;
+    input.data = in_frame->data[0];
+    input.dt = input_desc->dataType;
+
+    ret = umd_got_mem_fd(in_frame, &mem_fd);
+    if (ret != 0) {
+        av_log(NULL, AV_LOG_ERROR, "Failed to  umd_got_mem_fd\n");
+        goto err;
+    }
+
+    input_memory.fd = mem_fd;
+    input_memory.buffer = in_frame->data[0];
+    input_memory.size = input_buf_size;
+    input_memory.bindId = 0;
+    av_log(NULL,
+           AV_LOG_INFO,
+           "2d is enabled, data from 2d,input fd:%d, bufptr:%p, size:%ld \n",
+           input_memory.fd,
+           input_memory.buffer,
+           input_memory.size);
+#else
+    av_log(NULL, AV_LOG_INFO, "2d is disabled, data from test_input\n");
+    input.height = 321;
+    input.width = 481;
+    input.channels = 3;
+    input.data = in_frame->data[0];
+    input.dt = DNN_FLOAT;
+
+    input_umd_mem = umd_wrapper_alloc_buffer(umd_model->umdWrapper, umd_model->input_data.size);
+    if (!input_umd_mem) {
+        ret = AVERROR(ENOSYS);
+        av_log(NULL, AV_LOG_ERROR, "failed to cumd_wrapper_alloc_buffer\n");
+        goto err;
+    }
+    input_memory.fd = input_umd_mem->fd;
+    input_memory.buffer = input_umd_mem->buffer;
+    input_memory.size = input_umd_mem->size;
+    input_memory.bindId = 0;
+    if (input_memory.size != umd_model->input_data.size) {
+        ret = AVERROR(ENOSYS);
+        av_log(NULL, AV_LOG_ERROR, "input buffer invalid\n");
+        goto err;
+    }
+    memcpy(input_memory.buffer, umd_model->input_data.bufptr, input_memory.size);
+#endif
+
+    if (task->do_ioproc) {
+        if (umd_model->model->frame_pre_proc != NULL) {
+            av_log(NULL, AV_LOG_INFO, "frame_pre_proc is enabled\n");
+            umd_model->model->frame_pre_proc(in_frame, &input, umd_model->model->filter_ctx);
+        } else {
+            av_log(NULL, AV_LOG_INFO, "frame_pre_proc is do nothing\n");
+            // ff_proc_from_frame_to_dnn(in_frame, &input, ctx);
+        }
+    }
+
+    if (task->nb_output != 1) {
+        // currently, the filter does not need multiple outputs,
+        // so we just pending the support until we really need it.
+        avpriv_report_missing_feature(ctx, "multiple outputs");
+        ret = AVERROR(ENOSYS);
+        goto err;
+    }
+
+    ret = umd_wrapper_send_data(umd_model->umdWrapper, &input_memory);
+    if (ret != 0) {
+        ret = AVERROR(ENOSYS);
+        av_log(NULL, AV_LOG_ERROR, "Failed to  umd_wrapper_send_data\n");
+        goto err;
+    }
+    ret = umd_wrapper_get_result(umd_model->umdWrapper, &output_memory);
+    if (ret != 0) {
+        ret = AVERROR(ENOSYS);
+        av_log(NULL, AV_LOG_ERROR, "Failed to  umd_wrapper_get_result\n");
+        goto err;
+    }
+
+    av_log(ctx,
+           AV_LOG_INFO,
+           " output_memory buffer:%p, bindId:%d, fd:%d, size:%ld\n",
+           output_memory.buffer,
+           output_memory.bindId,
+           output_memory.fd,
+           output_memory.size);
+
+    output_data = output_memory.buffer;
+    for (size_t i = 0; i < 20; i++) {
+        av_log(ctx, AV_LOG_INFO, "%02x ", output_data[i]);
+    }
+    av_log(ctx, AV_LOG_INFO, " \n ");
+
+#define DUMP_UMD_OUTPUT 1
+#ifdef DUMP_UMD_OUTPUT
+    // dump output to file
+    FILE *fp = fopen("output.raw", "wb+");
+    fwrite(output_memory.buffer, output_memory.size, 1, fp);
+    fflush(fp);
+    fclose(fp);
+#endif
+
+#ifdef ES_2D_ENABLE
+    output.height = output_desc->dims.h;
+    output.width = output_desc->dims.w;
+    output.channels = output_desc->dims.c;
+    output.dt = output_desc->dataType;
+#else
+    output.height = 321;
+    output.width = 481;
+    output.channels = 3;
+    output.dt = DNN_FLOAT;
+#endif
+    // now output data is equal input frame data:
+    output.data = in_frame->data[0];
+    // memcpy(output.data, input_memory.buffer, input_memory.size);
+
+    if (task->do_ioproc) {
+        if (umd_model->model->frame_post_proc != NULL) {
+            av_log(NULL, AV_LOG_INFO, "frame_post_proc is enabled\n");
+            umd_model->model->frame_post_proc(task->out_frame, &output, umd_model->model->filter_ctx);
+        } else {
+            av_log(NULL, AV_LOG_INFO, "output data is input data \n");
+            // ff_proc_from_dnn_to_frame(task->out_frame, &output, ctx);
+            // task->out_frame->data[0] = output.data;
+            // task->out_frame->linesize[0] = input_memory.size;
+            task->out_frame = av_frame_clone(task->in_frame);
+        }
+    } else {
+        task->out_frame->width = output.width;
+        task->out_frame->height = output.height;
+    }
+    task->inference_done++;
+#ifdef ES_2D_ENABLE
+    umd_send_mem_fd(task->out_frame, mem_fd);
+#else
+    umd_wrapper_free_buffer(umd_model->umdWrapper, input_umd_mem);
+#endif
+err:
+    av_freep(&lltask);
+    return ret;
+}
+
+static int extract_lltask_from_task(TaskItem *task, Queue *lltask_queue) {
+    UMDModel *umd_model = task->model;
+    UMDContext *ctx = &umd_model->ctx;
+    LastLevelTaskItem *lltask = av_malloc(sizeof(*lltask));
+
+    if (!lltask) {
+        av_log(ctx, AV_LOG_ERROR, "Unable to allocate space for LastLevelTaskItem\n");
+        return AVERROR(ENOMEM);
+    }
+    task->inference_todo = 1;
+    task->inference_done = 0;
+    lltask->task = task;
+
+    if (ff_queue_push_back(lltask_queue, lltask) < 0) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to push back lltask_queue.\n");
+        av_freep(&lltask);
+        return AVERROR(ENOMEM);
+    }
+    return 0;
+}
+
+static int get_input_umd(void *model, DNNData *input, const char *input_name) {
+    UMDModel *umd_model = model;
+    UMDContext *ctx = &umd_model->ctx;
+    UMDDescription *input_desc = &umd_model->input_desc;
+    UMDDescription *output_desc = &umd_model->output_desc;
+    // TF_Status *status;
+
+    av_log(ctx, AV_LOG_INFO, " %s, %d, input_name:%s\n", __FUNCTION__, __LINE__, input_name);
+
+#ifdef ES_2D_ENABLE
+    umd_wrapper_get_input_description(umd_model->umdWrapper, input_desc);
+    umd_wrapper_get_output_description(umd_model->umdWrapper, output_desc);
+    // currently only NCHW is supported
+    av_log(
+        ctx,
+        AV_LOG_INFO,
+        "input_desc.name:%s, dims[n:%d,c:%d,h:%d,w:%d], dataType[%d], dataFormat[%d],bufferSize[%ld],pixelFormat[%d]\n",
+        input_desc->name,
+        input_desc->dims.n,
+        input_desc->dims.c,
+        input_desc->dims.h,
+        input_desc->dims.w,
+        input_desc->dataType,
+        input_desc->dataFormat,
+        input_desc->bufferSize,
+        input_desc->pixelFormat);
+    av_log(ctx,
+           AV_LOG_INFO,
+           "output_desc.name:%s, dims[n:%d,c:%d,h:%d,w:%d], dataType[%d], "
+           "dataFormat[%d],bufferSize[%ld],pixelFormat[%d]\n",
+           output_desc->name,
+           output_desc->dims.n,
+           output_desc->dims.c,
+           output_desc->dims.h,
+           output_desc->dims.w,
+           output_desc->dataType,
+           output_desc->dataFormat,
+           output_desc->bufferSize,
+           output_desc->pixelFormat);
+
+    // #define TENSOR_DATA_TYPE_UNKNOWN 0U
+    // #define TENSOR_DATA_TYPE_FLOAT   1U
+    // #define TENSOR_DATA_TYPE_HALF    2U
+    // #define TENSOR_DATA_TYPE_INT16   3U
+    // #define TENSOR_DATA_TYPE_INT8    4U
+    if (output_desc->dataType == 1U) {
+        input->dt = DNN_FLOAT;
+    } else if (output_desc->dataType == 4U) {
+        input->dt = DNN_UINT8;
+    } else {
+        input->dt = DNN_FLOAT;
+        av_log(ctx, AV_LOG_WARNING, "dataType:%d ffmpeg unsupport\n", output_desc->dataType);
+    }
+    input->dt = DNN_FLOAT;  // ffmpeg only support float
+    input->order = DCO_RGB;
+    input->height = input_desc->dims.h;
+    input->width = input_desc->dims.w;
+    input->channels = input_desc->dims.c;
+#else
+    int64_t dims[4];
+    input->dt = DNN_FLOAT;
+    input->order = DCO_RGB;
+    // currently only NCHW is supported
+    dims[0] = 1;
+    dims[1] = 321;
+    dims[2] = 481;
+    dims[3] = 3;
+    av_assert0(dims[0] == 1 || dims[0] == -1);
+    input->height = dims[1];
+    input->width = dims[2];
+    input->channels = dims[3];
+#endif
+
+    return 0;
+}
+
+static int get_output_umd(void *model,
+                          const char *input_name,
+                          int input_width,
+                          int input_height,
+                          const char *output_name,
+                          int *output_width,
+                          int *output_height) {
+    int ret = 0;
+    UMDModel *umd_model = model;
+    // UMDContext *ctx = &umd_model->ctx;
+    // TaskItem task;
+    // DNNExecBaseParams exec_params = {
+    //     .input_name = input_name,
+    //     .output_names = &output_name,
+    //     .nb_output = 1,
+    //     .in_frame = NULL,
+    //     .out_frame = NULL,
+    // };
+    UMDDescription *output_desc = &umd_model->output_desc;
+    av_log(NULL, AV_LOG_INFO, "input_name:%s output_name:%s\n", input_name, output_name);
+    av_log(NULL, AV_LOG_INFO, "%s,input_width:%d input_height:%d\n", __FUNCTION__, input_width, input_height);
+    // ret = ff_dnn_fill_gettingoutput_task(&task, &exec_params, umd_model, input_height, input_width, ctx);
+    // if (ret != 0) {
+    //     goto err;
+    // }
+    // ret = extract_lltask_from_task(&task, umd_model->lltask_queue);
+    // if (ret != 0) {
+    //     av_log(ctx, AV_LOG_ERROR, "unable to extract last level task from task.\n");
+    //     goto err;
+    // }
+
+    // ret = execute_model_umd(umd_model->lltask_queue);
+    // av_log(ctx,
+    //        AV_LOG_INFO,
+    //        " %s, %d w:%d, h:%d\n",
+    //        __FUNCTION__,
+    //        __LINE__,
+    //        task.out_frame->width,
+    //        task.out_frame->height);
+
+    *output_width = input_width;
+    *output_height = input_height;
+
+    return ret;
+}
+
+DNNModel *ff_dnn_load_model_umd(const char *model_filename,
+                                DNNFunctionType func_type,
+                                const char *options,
+                                AVFilterContext *filter_ctx) {
+    DNNModel *model = NULL;
+    UMDModel *umd_model = NULL;
+    UMDContext *ctx = NULL;
+    int ret = 0;
+
+    if (!model_filename || !filter_ctx) {
+        av_log(NULL, AV_LOG_ERROR, "params invalid\n");
+        return NULL;
+    }
+
+    av_log(ctx, AV_LOG_INFO, "%s, %d IN\n", __FUNCTION__, __LINE__);
+
+    model = av_mallocz(sizeof(DNNModel));
+    if (!model) {
+        return NULL;
+    }
+
+    umd_model = av_mallocz(sizeof(UMDModel));
+    if (!umd_model) {
+        av_freep(&model);
+        return NULL;
+    }
+    umd_model->model = model;
+    ctx = &umd_model->ctx;
+    ctx->class = &dnn_umd_class;
+
+    // parse options
+    av_opt_set_defaults(ctx);
+    if (av_opt_set_from_string(ctx, options, NULL, "=", "&") < 0) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to parse options \"%s\"\n", options);
+        goto err;
+    }
+
+#ifdef ES_2D_ENABLE
+#else
+    ret = read_file_data(ctx->options.test_input, &umd_model->input_data);
+    if (ret != 0) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to read_file_data\n");
+        goto err;
+    }
+    av_log(ctx, AV_LOG_INFO, "input[buf:%p, size:%ld]\n", umd_model->input_data.bufptr, umd_model->input_data.size);
+#endif
+
+    umd_model->umdWrapper = umd_wrapper_creat();
+    if (!umd_model->umdWrapper) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to umd_wrapper_creat\n");
+        return NULL;
+    }
+
+    if (umd_wrapper_load_model(umd_model->umdWrapper, model_filename) != 0) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to umd_wrapper_load_model\n");
+        return NULL;
+    }
+
+    if (ctx->options.nireq <= 0) {
+        ctx->options.nireq = av_cpu_count() / 2 + 1;
+    }
+
+#if !HAVE_PTHREAD_CANCEL
+    if (ctx->options.async) {
+        ctx->options.async = 0;
+        av_log(filter_ctx, AV_LOG_WARNING, "pthread is not supported, roll back to sync.\n");
+    }
+#endif
+
+    umd_model->lltask_queue = ff_queue_create();
+    if (!umd_model->lltask_queue) {
+        goto err;
+    }
+
+    umd_model->task_queue = ff_queue_create();
+    if (!umd_model->task_queue) {
+        goto err;
+    }
+
+    model->model = umd_model;
+    model->get_input = &get_input_umd;
+    model->get_output = &get_output_umd;
+    model->options = options;
+    model->filter_ctx = filter_ctx;
+    model->func_type = func_type;
+
+    return model;
+err:
+    ff_dnn_free_model_umd(&model);
+    return NULL;
+}
+
+int ff_dnn_execute_model_umd(const DNNModel *model, DNNExecBaseParams *exec_params) {
+    UMDModel *umd_model = model->model;
+    UMDContext *ctx = &umd_model->ctx;
+    TaskItem *task;
+    int ret = 0;
+    CHECK_PARAMS_INVALID(model)
+    CHECK_PARAMS_INVALID(exec_params)
+    av_log(NULL, AV_LOG_INFO, "ff_dnn_execute_model_umd \n");
+
+    ret = ff_check_exec_params(ctx, DNN_UMD, model->func_type, exec_params);
+    if (ret != 0) {
+        return ret;
+    }
+
+    task = av_malloc(sizeof(*task));
+    if (!task) {
+        av_log(ctx, AV_LOG_ERROR, "unable to alloc memory for task item.\n");
+        return AVERROR(ENOMEM);
+    }
+
+    ret = ff_dnn_fill_task(task, exec_params, umd_model, ctx->options.async, 1);
+    if (ret != 0) {
+        av_freep(&task);
+        return ret;
+    }
+
+    if (ff_queue_push_back(umd_model->task_queue, task) < 0) {
+        av_freep(&task);
+        av_log(ctx, AV_LOG_ERROR, "unable to push back task_queue.\n");
+        return AVERROR(ENOMEM);
+    }
+
+    ret = extract_lltask_from_task(task, umd_model->lltask_queue);
+    if (ret != 0) {
+        av_log(ctx, AV_LOG_ERROR, "unable to extract last level task from task.\n");
+        return ret;
+    }
+
+    return execute_model_umd(umd_model->lltask_queue);
+}
+
+DNNAsyncStatusType ff_dnn_get_result_umd(const DNNModel *model, AVFrame **in, AVFrame **out) {
+    UMDModel *umd_model = model->model;
+    av_log(NULL, AV_LOG_INFO, "ff_dnn_get_result_umd \n");
+    return ff_dnn_get_result_common(umd_model->task_queue, in, out);
+}
+
+int ff_dnn_flush_umd(const DNNModel *model) {
+    UMDModel *umd_model = model->model;
+    CHECK_PARAMS_INVALID(model)
+    av_log(NULL, AV_LOG_INFO, "ff_dnn_flush_umd \n");
+
+    if (ff_queue_size(umd_model->lltask_queue) == 0) {
+        // no pending task need to flush
+        return 0;
+    }
+
+    // for now, use sync node with flush operation
+    // Switch to async when it is supported
+    return execute_model_umd(umd_model->lltask_queue);
+}
+
+void ff_dnn_free_model_umd(DNNModel **model) {
+    UMDModel *umd_model;
+    if (!(*model)) {
+        av_log(NULL, AV_LOG_ERROR, "params invalid\n");
+        return;
+    }
+    av_log(NULL, AV_LOG_INFO, "ff_dnn_free_model_umd \n");
+    if (*model) {
+        if ((*model)->model) {
+            umd_model = (*model)->model;
+            // free input buffer
+            if (umd_model->input_data.bufptr) {
+                av_freep(&umd_model->input_data.bufptr);
+                umd_model->input_data.bufptr = NULL;
+            }
+            while (ff_queue_size(umd_model->lltask_queue) != 0) {
+                LastLevelTaskItem *item = ff_queue_pop_front(umd_model->lltask_queue);
+                av_freep(&item);
+            }
+            ff_queue_destroy(umd_model->lltask_queue);
+            while (ff_queue_size(umd_model->task_queue) != 0) {
+                TaskItem *item = ff_queue_pop_front(umd_model->task_queue);
+                av_frame_free(&item->in_frame);
+                av_frame_free(&item->out_frame);
+                av_freep(&item);
+            }
+
+            umd_wrapper_destroy(umd_model->umdWrapper);
+            ff_queue_destroy(umd_model->task_queue);
+            av_freep(&umd_model);
+        }
+        av_freep(model);
+    }
+    av_log(NULL, AV_LOG_INFO, "ff_dnn_free_model_umd done\n");
+}
\ No newline at end of file
diff --git a/libavfilter/dnn/dnn_backend_umd.h b/libavfilter/dnn/dnn_backend_umd.h
new file mode 100644
index 0000000000..fb51cd503f
--- /dev/null
+++ b/libavfilter/dnn/dnn_backend_umd.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2018 Sergey Lavrushkin
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * DNN inference functions interface for eswin umd backend.
+ */
+
+
+#ifndef AVFILTER_DNN_DNN_BACKEND_UMD_H
+#define AVFILTER_DNN_DNN_BACKEND_UMD_H
+
+#include "../dnn_interface.h"
+
+DNNModel *ff_dnn_load_model_umd(const char *model_filename, DNNFunctionType func_type, const char *options, AVFilterContext *filter_ctx);
+
+int ff_dnn_execute_model_umd(const DNNModel *model, DNNExecBaseParams *exec_params);
+DNNAsyncStatusType ff_dnn_get_result_umd(const DNNModel *model, AVFrame **in, AVFrame **out);
+int ff_dnn_flush_umd(const DNNModel *model);
+
+void ff_dnn_free_model_umd(DNNModel **model);
+
+#endif
diff --git a/libavfilter/dnn/dnn_interface.c b/libavfilter/dnn/dnn_interface.c
index 554a36b0dc..c3c8c46f0c 100644
--- a/libavfilter/dnn/dnn_interface.c
+++ b/libavfilter/dnn/dnn_interface.c
@@ -27,6 +27,7 @@
 #include "dnn_backend_native.h"
 #include "dnn_backend_tf.h"
 #include "dnn_backend_openvino.h"
+#include "dnn_backend_umd.h"
 #include "libavutil/mem.h"
 
 DNNModule *ff_get_dnn_module(DNNBackendType backend_type)
@@ -70,6 +71,18 @@ DNNModule *ff_get_dnn_module(DNNBackendType backend_type)
         return NULL;
     #endif
         break;
+    case DNN_UMD:
+    #if (CONFIG_ESUMD == 1)
+        dnn_module->load_model = &ff_dnn_load_model_umd;
+        dnn_module->execute_model = &ff_dnn_execute_model_umd;
+        dnn_module->get_result = &ff_dnn_get_result_umd;
+        dnn_module->flush = &ff_dnn_flush_umd;
+        dnn_module->free_model = &ff_dnn_free_model_umd;
+    #else
+        av_freep(&dnn_module);
+        return NULL;
+    #endif
+        break;
     default:
         av_log(NULL, AV_LOG_ERROR, "Module backend_type is not native or tensorflow\n");
         av_freep(&dnn_module);
diff --git a/libavfilter/dnn_interface.h b/libavfilter/dnn_interface.h
index ef8d7ae66f..4a2d17bf1b 100644
--- a/libavfilter/dnn_interface.h
+++ b/libavfilter/dnn_interface.h
@@ -32,7 +32,7 @@
 
 #define DNN_GENERIC_ERROR FFERRTAG('D','N','N','!')
 
-typedef enum {DNN_NATIVE, DNN_TF, DNN_OV} DNNBackendType;
+typedef enum {DNN_NATIVE, DNN_TF, DNN_OV, DNN_UMD} DNNBackendType;
 
 typedef enum {DNN_FLOAT = 1, DNN_UINT8 = 4} DNNDataType;
 
diff --git a/libavfilter/esvfbuffer.c b/libavfilter/esvfbuffer.c
new file mode 100644
index 0000000000..13968b4591
--- /dev/null
+++ b/libavfilter/esvfbuffer.c
@@ -0,0 +1,504 @@
+#define LOG_TAG "esvfbuffer"
+#include "esvfbuffer.h"
+#include <libavutil/log.h>
+#include <libavutil/frame.h>
+#include "libavutil/pixfmt.h"
+#include "libavutil/imgutils.h"
+
+static int esvf_queue_push(ESFifoQueue *queue, void *buffer, int size) {
+    int ret;
+    if (!queue || !buffer || size <= 0) {
+        av_log(NULL, AV_LOG_ERROR, "params error size: %d\n", size);
+        return FAILURE;
+    }
+
+    ret = esvf_fifo_queue_push(queue, buffer, size);
+    return ret;
+}
+
+int esvf_get_buffer_unitl_timeout(ESFifoQueue *queue, ESBuffer *buffer, int timeout) {
+    int ret;
+    if (!queue || !buffer) {
+        av_log(NULL, AV_LOG_ERROR, "params error buffer: %p, queue: %p\n", buffer, queue);
+        return FAILURE;
+    }
+    ret = esvf_fifo_queue_pop_until_timeout(queue, buffer, sizeof(ESBuffer), timeout);
+    return ret;
+}
+
+static int esvf_release_buffer(ESFifoQueue *queue, ESBuffer *buffer) {
+    int ret;
+
+    ret = esvf_queue_push(queue, buffer, sizeof(ESBuffer));
+    return ret;
+}
+
+static void esvf_output_port_free(void *opaque, uint8_t *output_port) {
+    ESOutputPort *port = (ESOutputPort *)output_port;
+    if (!port) {
+        av_log(NULL, AV_LOG_ERROR, "output port is null\n");
+        return;
+    }
+
+    esvf_fifo_queue_free(&port->frame_queue);
+    av_freep(&port->mems);
+    av_free(port);
+
+    av_log(NULL, AV_LOG_INFO, "esvf_output_port_free success\n");
+}
+
+static void esvf_output_port_memorys_unref(ESOutputPort *port) {
+    int mem_num;
+    ESMemory *memory;
+    if (!port || port->mem_num <= 0) {
+        return;
+    }
+    mem_num = port->mem_num;
+    port->mem_num = 0;
+    for (int i = 0; i < mem_num; i++) {
+        memory = port->mems[i];
+        port->mems[i] = NULL;
+        if (memory) {
+            if (memory->buffer_ref && memory->port_ref) {
+                av_log(NULL, AV_LOG_INFO,
+                         "i: %d, vir_addr: %p, buffer_ref count: %d, port_ref count: %d\n",
+                         i,
+                         memory->vir_addr,
+                         av_buffer_get_ref_count(memory->buffer_ref) - 1,
+                         av_buffer_get_ref_count(memory->port_ref) - 1);
+            }
+
+            av_buffer_unref(&memory->port_ref);
+            av_buffer_unref(&memory->buffer_ref);
+        }
+    }
+}
+
+void esvf_output_port_unref(ESOutputPort **output_port) {
+    ESOutputPort *port;
+    if (!output_port || !*output_port) {
+        av_log(NULL, AV_LOG_ERROR, "output_port is null %p\n", output_port);
+        return;
+    }
+
+    port = *output_port;
+    esvf_output_port_memorys_unref(port);
+
+    if (port->port_ref) {
+        av_log(NULL,
+               AV_LOG_INFO,
+               "port_ref count: %d\n",
+               av_buffer_get_ref_count(port->port_ref) - 1);
+        av_buffer_unref(&port->port_ref);
+    }
+    if (port->mem_info) {
+        av_free(port->mem_info);
+    }
+    *output_port = NULL;
+}
+
+static void esvf_output_mempry_free(void *opaque, uint8_t *data) {
+    ESMemory *memory = (ESMemory *)data;
+    if (!memory) {
+        av_log(NULL, AV_LOG_ERROR, "opaque or mem is null mem: %p\n", memory);
+        return;
+    }
+
+    av_log(NULL, AV_LOG_DEBUG, "esvf_output_mempry_free free mem: %p\n", memory->vir_addr);
+
+#ifdef MODEL_SIMULATION
+    av_free(memory->dma_buf);
+#else
+    es_dma_unmap(memory->dma_buf);
+    es_dma_free(memory->dma_buf);
+#endif
+
+    av_free(memory);
+}
+
+static ESOutputPort *esvf_output_port_create(int mem_num) {
+    int ret = FAILURE;
+    ESOutputPort *port;
+    if (mem_num <= 0) {
+        av_log(NULL, AV_LOG_ERROR, "mem_num: %d\n", mem_num);
+        return NULL;
+    }
+
+    port = av_mallocz(sizeof(*port));
+    if (!port) {
+        av_log(NULL, AV_LOG_ERROR, "av_mallocz failed\n");
+        return NULL;
+    }
+
+    port->max_mem_num = mem_num;
+
+    port->port_ref =
+        av_buffer_create((uint8_t *)port,
+                         sizeof(*port),
+                         esvf_output_port_free,
+                         NULL,
+                         AV_BUFFER_FLAG_READONLY);
+    if (!port->port_ref) {
+        av_log(NULL, AV_LOG_ERROR, "av_buffer_create failed\n");
+        esvf_output_port_free(NULL, (uint8_t *)port);
+        return NULL;
+    }
+
+    do {
+        port->frame_queue = esvf_fifo_queue_create(port->max_mem_num,
+                                                   sizeof(ESBuffer),
+                                                   "frame_queue");
+        if (!port->frame_queue) {
+            av_log(NULL, AV_LOG_ERROR, "frame_queue create failed\n");
+            break;
+        }
+        port->mems = av_mallocz_array(sizeof(*port->mems),  port->max_mem_num);
+        if (!port->mems) {
+            av_log(NULL, AV_LOG_ERROR, "av_mallocz_array mems failed\n");
+            break;
+        }
+        ret = SUCCESS;
+    } while (0);
+
+    if (ret == FAILURE) {
+        esvf_output_port_unref(&port);
+        av_log(NULL, AV_LOG_ERROR, "output port create failed\n");
+    } else {
+        av_log(NULL, AV_LOG_INFO, "output port create success\n");
+    }
+
+    return port;
+}
+
+static ESMemory *esvf_allocate_one_output_memory(int mem_size) {
+    int ret = FAILURE;
+    AVBufferRef *buffer_ref;
+    ESMemory *memory = NULL;
+#ifdef MODEL_SIMULATION
+    void *dma_buf = NULL;
+#else
+    es_dma_buf *dma_buf = NULL;
+#endif
+
+    memory = av_mallocz(sizeof(*memory));
+    do {
+        if (memory) {
+#ifdef MODEL_SIMULATION
+            dma_buf = av_malloc(mem_size);
+            if (!dma_buf) {
+                av_log(NULL, AV_LOG_ERROR, "allocate mem failed\n");
+                av_free(memory);
+                memory = NULL;
+                break;
+            }
+            memory->dma_buf = dma_buf;
+            memory->vir_addr = dma_buf;
+            memory->fd = (uint64_t)memory->vir_addr;
+#else
+            dma_buf = es_dma_alloc(DMA_TYPE_SYS, mem_size, UNCACHED_BUF, 0);
+            if (!dma_buf) {
+                av_log(NULL, AV_LOG_ERROR, "allocate dma_buf failed\n");
+                av_free(memory);
+                memory = NULL;
+                break;
+            }
+            es_dma_map(dma_buf, UNCACHED_BUF);
+            memory->dma_buf = dma_buf;
+            memory->vir_addr = dma_buf->vir_addr;
+            memory->fd = dma_buf->dmabuf_fd;
+#endif
+            memory->size = mem_size;
+
+            buffer_ref = av_buffer_create((uint8_t *)memory, sizeof(*memory),
+                                          esvf_output_mempry_free,
+                                          NULL,
+                                          AV_BUFFER_FLAG_READONLY);
+            if (!buffer_ref) {
+                esvf_output_mempry_free(NULL, (uint8_t *)memory);
+                memory = NULL;
+                av_log(NULL, AV_LOG_ERROR, "av_buffer_create failed\n");
+                break;
+            }
+            memory->buffer_ref = buffer_ref;
+            ret = SUCCESS;
+        }
+    } while (0);
+
+    if (ret == FAILURE) {
+        if (memory) {
+            av_free(memory);
+            memory = NULL;
+        }
+        av_log(NULL, AV_LOG_ERROR, "allocate one memory failed\n");
+    }
+
+    return memory;
+}
+
+static void esvf_output_buffer_init(ESBuffer *buffer,
+                                    ESOutputPort *port,
+                                    ESMemory *memory) {
+    if (!buffer || !port || !memory) {
+        return;
+    }
+
+    memset(buffer, 0, sizeof(*buffer));
+    buffer->max_size = memory->size;
+    buffer->vir_addr = memory->vir_addr;
+    buffer->memory = memory;
+    memory->buffer = *buffer;
+}
+
+int esvf_allocate_one_output_memorys(ESOutputPort *port) {
+    int ret = SUCCESS;
+    int index = 0;
+    ESMemory *memory;
+    ESBuffer buffer;
+    if (!port) {
+        return FAILURE;
+    }
+
+    if (port->mem_num >= port->max_mem_num) {
+        av_log(NULL, AV_LOG_INFO,
+                "output port can not allocate any memory anyway, max_mem_num: %d, mem_num: %d\n",
+                port->max_mem_num,
+                port->mem_num);
+        return FAILURE;
+    }
+
+    index = port->mem_num;
+    memory = esvf_allocate_one_output_memory(port->mem_size);
+    if (memory) {
+        port->mems[index] = memory;
+        memory->port_ref = av_buffer_ref(port->port_ref);
+        port->mem_num++;
+        esvf_output_buffer_init(&buffer,
+                                port,
+                                memory);
+        esvf_release_buffer(port->frame_queue, &buffer);
+    } else {
+        ret = FAILURE;
+    }
+
+    if (ret == SUCCESS) {
+        av_log(NULL, AV_LOG_INFO, "output memorys allocate success\n");
+    } else {
+        av_log(NULL, AV_LOG_ERROR, "output memorys allocate failed\n");
+    }
+
+    return ret;
+}
+
+int esvf_allocate_all_output_memorys(ESOutputPort *port) {
+    int ret = SUCCESS;
+    int index = 0;
+    ESMemory *memory;
+    ESBuffer buffer;
+    if (!port) {
+        return FAILURE;
+    }
+
+    for (int i = 0; i < port->max_mem_num; i++) {
+        index = port->mem_num;
+        memory = esvf_allocate_one_output_memory(port->mem_size);
+        if (memory) {
+            port->mems[index] = memory;
+            memory->port_ref = av_buffer_ref(port->port_ref);
+            port->mem_num++;
+            esvf_output_buffer_init(&buffer,
+                                    port,
+                                    memory);
+            esvf_release_buffer(port->frame_queue, &buffer);
+        } else {
+            ret = FAILURE;
+            break;
+        }
+    }
+
+    if (ret == SUCCESS) {
+        av_log(NULL, AV_LOG_INFO, "output memorys allocate success\n");
+    } else {
+        av_log(NULL, AV_LOG_ERROR, "output memorys allocate failed\n");
+    }
+
+    return ret;
+}
+
+static int esvf_init_meminfo(MemInfo *mem_info,
+                             enum AVPixelFormat out_fmt,
+                             uint32_t pic_width,
+                             uint32_t pic_height,
+                             uint32_t stride_align) {
+    AVPixFmtDescriptor *desc;
+    int height = 0;
+    int buffer_size = 0;
+
+    if (!mem_info) {
+        av_log(NULL, AV_LOG_ERROR,
+               "esvf_init_meminfo invaild paras, mem_info: %p.\n",
+               mem_info);
+        return FAILURE;
+    }
+
+    desc = av_pix_fmt_desc_get(out_fmt);
+    if (!desc) {
+        av_log(NULL, AV_LOG_ERROR,
+               "esvf_init_meminfo get fmt: %s AVPixFmtDescriptor failed.\n",
+               av_get_pix_fmt_name(out_fmt));
+        return FAILURE;
+    }
+
+    av_image_fill_linesizes(mem_info->linesize, out_fmt, FFALIGN(pic_width, stride_align));
+
+    for (int i = 0; i < 4 && mem_info->linesize[i]; i++) {
+        height = pic_height;
+        if (i == 1 || i == 2) {
+            height = AV_CEIL_RSHIFT(height, desc->log2_chroma_h);
+        }
+        mem_info->offset[i] = buffer_size;
+        mem_info->datasize[i] = mem_info->linesize[i] * height;
+        buffer_size += mem_info->datasize[i];
+    }
+    mem_info->w = pic_width;
+    mem_info->h = pic_height;
+    mem_info->size = buffer_size;
+
+    return SUCCESS;
+}
+
+ESOutputPort *esvf_allocate_output_port(int mem_num,
+                                        enum AVPixelFormat out_fmt,
+                                        uint32_t width,
+                                        uint32_t height,
+                                        uint32_t stride_align) {
+    int ret = FAILURE;
+    ESOutputPort *port = NULL;
+    int32_t output_buf_num;
+    MemInfo *mem_info;
+
+    output_buf_num = mem_num;
+
+    do {
+        if (mem_num <= 0) {
+            output_buf_num = DEFAULT_OUTPUT_BUFFERS;
+        } else {
+            output_buf_num = mem_num > MAX_OUTPUT_BUFFERS ? MAX_OUTPUT_BUFFERS : mem_num;
+        }
+
+        port = esvf_output_port_create(output_buf_num);
+        if (!port) {
+            av_log(NULL, AV_LOG_ERROR, "esvf_output_port_create failed\n");
+            return NULL;
+        }
+
+        mem_info = (MemInfo *)av_malloc(sizeof(MemInfo));
+        if (!mem_info) {
+            av_log(NULL, AV_LOG_ERROR, "mem_info_alloc failed \n");
+            return FAILURE;
+        }
+        ret = esvf_init_meminfo(mem_info, out_fmt, width, height, stride_align);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "esvf_init_meminfo faild\n");
+            return FAILURE;
+        }
+
+        port->mem_info = mem_info;
+        port->mem_size = FFALIGN(mem_info->size, stride_align);
+        port->mem_num = 0;
+
+        ret = esvf_allocate_all_output_memorys(port);
+        if (ret == FAILURE) {
+            av_log(NULL, AV_LOG_ERROR, "esvf_allocate_all_output_memorys failed\n");
+            ret = FAILURE;
+            break;
+        }
+
+        ret = SUCCESS;
+    } while (0);
+
+    if (ret == FAILURE) {
+        av_log(NULL, AV_LOG_INFO, "esvf_allocate_out_port failed\n");
+        esvf_output_port_unref(&port);
+    } else {
+        av_log(NULL, AV_LOG_INFO, "esvf_allocate_out_port success\n");
+    }
+
+    return port;
+}
+
+static int esvf_release_buffer_to_frame_queue(ESFifoQueue *queue, ESBuffer *buffer) {
+    struct AVBufferRef *buffer_ref = NULL;
+    struct AVBufferRef *port_ref = NULL;
+    int ret;
+    if (!queue || !buffer) {
+        av_log(NULL, AV_LOG_ERROR, "queue: %p, buffer: %p\n", queue, buffer);
+        return FAILURE;
+    }
+
+    if (buffer->buffer_ref) {
+        buffer_ref = buffer->buffer_ref;
+        buffer->buffer_ref = NULL;
+    }
+
+    if (buffer->port_ref) {
+        port_ref = buffer->port_ref;
+        buffer->port_ref = NULL;
+    }
+
+    ret = esvf_release_buffer(queue, buffer);
+    if (ret == FAILURE) {
+        av_log(NULL, AV_LOG_ERROR, "esvf_release_output_buffer failed\n");
+    }
+
+    if (buffer_ref) {
+        av_buffer_unref(&buffer_ref);
+    }
+    if (port_ref) {
+        av_buffer_unref(&port_ref);
+    }
+
+    return ret;
+}
+
+void esvf_buffer_consume(void *opaque, uint8_t *data) {
+    ESBuffer *buffer;
+    ESOutputPort *port = (ESOutputPort *)opaque;
+    ESMemory *memory = (ESMemory *)data;
+
+    if (!memory || !port) {
+        av_log(NULL, AV_LOG_ERROR, "memory or port is null port: %p\n", port);
+        return;
+    }
+
+    buffer = &memory->buffer;
+
+    if (buffer) {
+        esvf_release_buffer_to_frame_queue(port->frame_queue, buffer);
+    } else {
+        av_log(NULL, AV_LOG_ERROR, "output buffer: %p is null\n", buffer);
+    }
+}
+
+static int esvf_get_video_buffer(ESOutputPort *port, ESBuffer *buffer) {
+    int ret;
+
+    if (!port) {
+        av_log(NULL, AV_LOG_ERROR, "params error port: %p\n", port);
+        return FAILURE;
+    }
+
+    if (port->mem_num < port->max_mem_num) {
+        ret = esvf_get_buffer_unitl_timeout(port->frame_queue, buffer, 0);
+        if (ret != SUCCESS) {
+            ret = esvf_allocate_one_output_memorys(port);
+            if (ret == FAILURE) {
+                av_log(NULL, AV_LOG_ERROR, "esvf_allocate_one_output_memorys failed\n");
+            }
+            ret = esvf_get_buffer_unitl_timeout(port->frame_queue, buffer, -1);
+        }
+    } else {
+        ret = esvf_get_buffer_unitl_timeout(port->frame_queue, buffer, -1);
+    }
+
+    return ret;
+}
\ No newline at end of file
diff --git a/libavfilter/esvfbuffer.h b/libavfilter/esvfbuffer.h
new file mode 100644
index 0000000000..dadd470f40
--- /dev/null
+++ b/libavfilter/esvfbuffer.h
@@ -0,0 +1,71 @@
+#ifndef AVCODEC_ES_VF_BUFFER_H__
+#define AVCODEC_ES_VF_BUFFER_H__
+
+// #include <dectypes.h>
+#include "esvfqueue.h"
+#include "esvfcommon.h"
+
+typedef struct ESMemory ESMemory;
+
+typedef struct _MemInfo
+{
+    int w;
+    int h;
+    int linesize[4]; // output frame linesize
+    int offset[4]; // output frame yuv data's offset
+    int datasize[4]; // size of output frame yuv data'plane
+    int size; // total size of output frame
+} MemInfo;
+
+
+typedef struct ESBuffer {
+    int flags;
+    struct AVBufferRef *buffer_ref;
+    struct AVBufferRef *port_ref;
+    uint32_t *vir_addr;
+    void *mem;
+    uint32_t max_size;
+    ESMemory *memory;
+} ESBuffer;
+
+struct ESMemory {
+    uint64_t fd;
+    void *vir_addr;
+#ifdef MODEL_SIMULATION
+    void *dma_buf;
+#else
+    es_dma_buf *dma_buf;
+#endif
+    uint32_t size;
+    ESBuffer buffer;
+    struct AVBufferRef *buffer_ref;
+    struct AVBufferRef *port_ref;
+};
+
+typedef struct ESOutputPort {
+    int mem_num;
+    int max_mem_num;
+    int mem_size;
+    ESMemory **mems;
+    MemInfo *mem_info;
+    ESFifoQueue *frame_queue;
+    struct AVBufferRef *port_ref;
+} ESOutputPort;
+
+void esvf_output_port_unref(ESOutputPort **output_port);
+
+ESOutputPort *esvf_allocate_output_port(int mem_num,
+                                        enum AVPixelFormat out_fmt,
+                                        uint32_t width,
+                                        uint32_t height,
+                                        uint32_t stride_align);
+
+int esvf_allocate_one_output_memorys(ESOutputPort *port);
+
+int esvf_allocate_all_output_memorys(ESOutputPort *port);
+
+void esvf_buffer_consume(void *opaque, uint8_t *data);
+
+int esvf_get_buffer_unitl_timeout(ESFifoQueue *queue, ESBuffer *buffer, int timeout);
+
+#endif
\ No newline at end of file
diff --git a/libavfilter/esvfcommon.c b/libavfilter/esvfcommon.c
new file mode 100644
index 0000000000..8996dad1ec
--- /dev/null
+++ b/libavfilter/esvfcommon.c
@@ -0,0 +1,442 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "esvfcommon.h"
+#include <libavutil/pixfmt.h>
+#ifndef MODEL_SIMULATION
+#include <es2d_api.h>
+#endif
+
+int vf_is_simulation(void) {
+    int result;
+#ifndef MODEL_SIMULATION
+    result = FALSE;
+#else
+    result = TRUE;
+#endif
+
+    av_log(NULL, AV_LOG_INFO, "is simulation: %d\n", result);
+    return result;
+}
+
+int vf_add_fd_to_side_data(AVFrame *frame, uint64_t fd) {
+    int ret = SUCCESS;
+    AVFrameSideData *sd = NULL;
+
+    if (!frame) {
+        av_log(NULL, AV_LOG_ERROR, "frame is null\n");
+        return FAILURE;
+    }
+
+    av_log(NULL, AV_LOG_DEBUG, "convert_esadd side data: fd = %lx\n", fd);
+    sd = av_frame_new_side_data(frame, SIDE_DATA_TYPE_MEM_FRAME_FD, sizeof(fd));
+    if (sd && sd->data) {
+        memcpy(sd->data, &fd, sizeof(fd));
+    } else {
+        ret = FAILURE;
+        av_log(NULL, AV_LOG_ERROR, "av_frame_new_side_data faild sd: %p\n", sd);
+    }
+
+    return ret;
+}
+
+int esvf_get_fd(const AVFrame *frame, int64_t *fd) {
+    AVFrameSideData *sd = NULL;
+    if (!frame) return -1;
+    if (!frame->nb_side_data) return -1;
+
+    sd = av_frame_get_side_data(frame, SIDE_DATA_TYPE_MEM_FRAME_FD);
+    if (sd) {
+        *fd = *((int64_t *)sd->data);
+        av_log(NULL, AV_LOG_INFO, "convert_es got mem_fd: %lx\n", *fd);
+        return 0;
+    }
+
+    return -1;
+}
+
+void esvf_memcpy_block(void *src, void *dst, size_t data_size) {
+    memcpy(dst, src, data_size);
+}
+
+int esvf_memcpy_by_line(uint8_t *src, uint8_t *dst, int src_linesize, int dst_linesize, int linecount) {
+    int copy_size;
+    if (!src || !dst) {
+        return AVERROR(EINVAL);
+    }
+
+    copy_size = FFMIN(src_linesize, dst_linesize);
+    for (int i = 0; i < linecount; i++) {
+        memcpy(dst + i * dst_linesize, src + i * src_linesize, copy_size);
+    }
+
+    return 0;
+}
+
+FILE *vf_dump_file_open(const char *dump_path, const char* filename) {
+    FILE *dump_handle = NULL;
+    char file_path[PATH_MAX];
+    int64_t time_ms;
+    int ret;
+
+    if (!dump_path || !filename) {
+        av_log(NULL, AV_LOG_ERROR, "error !!! dump path or filename is null\n");
+        return NULL;
+    }
+
+    ret = access(dump_path, 0);
+    if (ret == -1) {
+        av_log(NULL, AV_LOG_INFO, "dump_path: %s does not exist\n", dump_path);
+        if (mkdir(dump_path, 0731) == -1) {
+            av_log(NULL, AV_LOG_ERROR, "create dump_path: %s failed errno: %d\n", dump_path, errno);
+            return NULL;
+        }
+    } else {
+        av_log(NULL, AV_LOG_INFO, "dump_path: %s exist\n", dump_path);
+    }
+
+    time_ms =  av_gettime();
+
+    snprintf(file_path, sizeof(file_path), "%s/%lld_%s", dump_path, time_ms, filename);
+
+    dump_handle = fopen(file_path, "ab+");
+    if (dump_handle) {
+        av_log(NULL, AV_LOG_INFO, "open %s success\n", file_path);
+    } else {
+        dump_handle = NULL;
+        av_log(NULL, AV_LOG_ERROR, "open %s failed\n", file_path);
+        return NULL;
+    }
+
+    return dump_handle;
+}
+
+int vf_dump_bytes_to_file(void *data, int size, FILE *fp) {
+    int len = 0;
+
+    if (!fp) {
+        av_log(NULL, AV_LOG_ERROR, " invaild file handle\n");
+        return FAILURE;
+    }
+
+    if (!data || size <= 0) {
+        return FAILURE;
+    }
+
+    len = fwrite(data, 1, size, fp);
+    fflush(fp);
+    if (len != size) {
+        av_log(NULL, AV_LOG_ERROR, "write data to file error !!! len: %d, data size: %d\n", len, size);
+    }
+
+    return len;
+}
+
+int vf_para_crop(char *str, CropInfo *crop_info) {
+    if (!str || !crop_info) {
+        return FAILURE;
+    }
+
+    if (sscanf(str,
+               "%dx%dx%dx%d",
+               &crop_info->crop_xoffset,
+               &crop_info->crop_yoffset,
+               &crop_info->crop_width,
+               &crop_info->crop_height) != 4) {
+        return FAILURE;
+    }
+
+    return SUCCESS;
+}
+
+int vf_para_scale(char *str, ScaleInfo *scale_info) {
+    if (!str || !scale_info) {
+        return FAILURE;
+    }
+
+    if (sscanf(str,
+              "%dx%d",
+               &scale_info->scale_width,
+               &scale_info->scale_height) != 2) {
+        return FAILURE;
+    }
+
+    return SUCCESS;
+}
+
+int vf_para_normalization_rgb(char *str, VF2DRgbU32 *RGB_info) {
+    if (!str || !RGB_info) {
+        return FAILURE;
+    }
+
+    if (sscanf(str,
+              "%x/%x/%x",
+               &RGB_info->R,
+               &RGB_info->G,
+               &RGB_info->B) != 3) {
+        return FAILURE;
+    }
+
+    return SUCCESS;
+}
+
+#ifndef MODEL_SIMULATION
+typedef struct {
+    enum AVPixelFormat pixfmt;
+    ES2D_PIXEL_FMT picfmt;
+} AvFmtTo2Dfmt;
+
+static const AvFmtTo2Dfmt fmtto2dfmttable[] = {
+    {AV_PIX_FMT_NV12, ES2D_FMT_NV12},
+    {AV_PIX_FMT_NV21, ES2D_FMT_NV21},
+    {AV_PIX_FMT_YUV420P, ES2D_FMT_I420},
+    {AV_PIX_FMT_GRAY8, ES2D_FMT_GRAY8},
+    {AV_PIX_FMT_GRAYF32LE, ES2D_FMT_GRAY32F},
+    {AV_PIX_FMT_YUV420P10LE, ES2D_FMT_I010_LSB},
+    {AV_PIX_FMT_P010LE, ES2D_FMT_P010},
+    {AV_PIX_FMT_YVYU422, ES2D_FMT_YVYU},
+    {AV_PIX_FMT_YUYV422, ES2D_FMT_YUY2},
+    {AV_PIX_FMT_UYVY422, ES2D_FMT_UYVY},
+    {AV_PIX_FMT_NV16, ES2D_FMT_NV16},
+    {AV_PIX_FMT_BGR24, ES2D_FMT_R8G8B8},
+    {AV_PIX_FMT_ARGB, ES2D_FMT_B8G8R8A8},
+    {AV_PIX_FMT_ABGR, ES2D_FMT_R8G8B8A8},
+    {AV_PIX_FMT_BGRA, ES2D_FMT_A8R8G8B8},
+    {AV_PIX_FMT_RGBA, ES2D_FMT_A8B8G8R8},
+    {AV_PIX_FMT_B16G16R16I, ES2D_FMT_R16G16B16I},
+    {AV_PIX_FMT_B16G16R16I_PLANAR, ES2D_FMT_R16G16B16I_PLANAR},
+    {AV_PIX_FMT_B8G8R8_PLANAR, ES2D_FMT_R8G8B8_PLANAR},
+    {AV_PIX_FMT_B8G8R8I, ES2D_FMT_R8G8B8I},
+    {AV_PIX_FMT_B8G8R8I_PLANAR, ES2D_FMT_R8G8B8I_PLANAR},
+    {AV_PIX_FMT_B16G16R16F, ES2D_FMT_R16G16B16F},
+    {AV_PIX_FMT_B16G16R16F_PLANAR, ES2D_FMT_R16G16B16F_PLANAR},
+    {AV_PIX_FMT_B32G32R32F, ES2D_FMT_R32G32B32F},
+    {AV_PIX_FMT_B32G32R32F_PLANAR, ES2D_FMT_R32G32B32F_PLANAR},
+};
+
+static enum AVPixelFormat vf_2dfmt_to_pixfmt(ES2D_PIXEL_FMT picfmt) {
+    int i;
+
+    for (i = 0; i < sizeof(fmtto2dfmttable) / sizeof(AvFmtTo2Dfmt); i++)
+        if (fmtto2dfmttable[i].picfmt == picfmt) return fmtto2dfmttable[i].pixfmt;
+
+    return AV_PIX_FMT_NONE;
+}
+
+static ES2D_PIXEL_FMT vf_pixfmt_to_2dfmt(enum AVPixelFormat pixfmt) {
+    int i;
+
+    for (i = 0; i < sizeof(fmtto2dfmttable) / sizeof(AvFmtTo2Dfmt); i++)
+        if (fmtto2dfmttable[i].pixfmt == pixfmt) return fmtto2dfmttable[i].picfmt;
+
+    return AV_PIX_FMT_NONE;
+}
+
+int vf_2D_init(ES2D_ID *id) {
+    if (!id) {
+        av_log(NULL, AV_LOG_ERROR, "vf_2D_init invaild id: %p\n", id);
+        return FAILURE;
+    }
+
+    if (es2d_init(id) != ES2D_STATUS_OK) {
+        av_log(NULL, AV_LOG_ERROR, "vf_2D_init failed!\n");
+        return FAILURE;
+    } else {
+        av_log(NULL, AV_LOG_INFO, "vf_2D_init ...ok\n");
+    }
+
+    return SUCCESS;
+}
+
+int vf_2D_unint(ES2D_ID *id) {
+    if (!id) {
+        av_log(NULL, AV_LOG_ERROR, "vf_2D_unint invaild id: %p\n", id);
+        return FAILURE;
+    }
+
+    if (es2d_destroy(*id) != ES2D_STATUS_OK) {
+        av_log(NULL, AV_LOG_ERROR, "es2d_destroy failed!\n");
+        return FAILURE;
+    } else {
+        av_log(NULL, AV_LOG_INFO, "es2d_destroy ...ok\n");
+    }
+
+    return SUCCESS;
+}
+
+static void vf_printf_2Dsurface(ES2D_SURFACE *surface, const char *name) {
+     if (!surface || !name) {
+        av_log(NULL, AV_LOG_ERROR, "invaild paras, surface: %p, name: %p!\n", surface, name);
+        return;
+    }
+
+    av_log(NULL, AV_LOG_DEBUG,
+           "%s: surface.dma_buf: %p, surface.offset: %d, "
+           "surface.width: %d, surface.height: %d, surface.format: %d\n",
+           name,
+           surface->dma_buf,
+           surface->offset,
+           surface->width,
+           surface->height,
+           surface->format);
+}
+
+static void vf_printf_2Drect(ES2D_RECT *rect, const char *name) {
+    if (!rect || !name) {
+        av_log(NULL, AV_LOG_ERROR, "invaild paras, rect: %p, name: %p!\n", rect, name);
+        return;
+    }
+
+    av_log(NULL, AV_LOG_DEBUG,
+           "%s: rect.left: %d, rect.top: %d, "
+           "rect.right: %d, rect.bottom: %d\n",
+           name,
+           rect->left,
+           rect->top,
+           rect->right,
+           rect->bottom);
+}
+
+static void vf_printf_normalization_params(ES2D_NORMALIZATION_PARAMS *paras) {
+    if (!paras) {
+        av_log(NULL, AV_LOG_ERROR, "normalization paras is null!\n");
+        return;
+    }
+
+    av_log(NULL, AV_LOG_DEBUG,
+           "normalizationMode: %d,stepReciprocal: %x\n",
+           paras->normalizationMode,
+           paras->stepReciprocal);
+    av_log(NULL, AV_LOG_DEBUG,
+           "minValue.R: %x, minValue.G: %x, minValue.B: %x\n",
+           paras->minValue.R,
+           paras->minValue.G,
+           paras->minValue.B);
+    av_log(NULL, AV_LOG_DEBUG,
+           "maxMinReciprocal.R: %x, maxMinReciprocal.G: %x, maxMinReciprocal.B: %x\n",
+           paras->maxMinReciprocal.R,
+           paras->maxMinReciprocal.G,
+           paras->maxMinReciprocal.B);
+    av_log(NULL, AV_LOG_DEBUG,
+           "meanValue.R: %x, meanValue.G: %x, meanValue.B: %x\n",
+           paras->meanValue.R,
+           paras->meanValue.G,
+           paras->meanValue.B);
+    av_log(NULL, AV_LOG_DEBUG,
+           "stdReciprocal.R: %x, stdReciprocal.G: %x, stdReciprocal.B: %x\n",
+           paras->stdReciprocal.R,
+           paras->stdReciprocal.G,
+           paras->stdReciprocal.B);
+}
+
+int vf_2D_work(ES2D_ID *id,
+               VF2DSurface *srcSurface,
+               VF2DSurface *dstSurface,
+               VF2DNormalizationParams *normalizationParas,
+               VF2DRect *srcRect,
+               VF2DRect *dstRect) {
+    ES2D_SURFACE src_surface;
+    ES2D_SURFACE dst_surface;
+    ES2D_RECT src_rect;
+    ES2D_RECT dst_rect;
+    ES2D_NORMALIZATION_PARAMS normalization_paras;
+    int is_normalization = 0;
+    int ret = FAILURE;
+
+    if (!id || !srcSurface || !dstSurface || !srcRect || !dstRect) {
+        av_log(NULL, AV_LOG_ERROR,
+               "vf_2D_work invaild id: %p,"
+               " srcSurface: %p, dstSurface: %p srcRect: %p, dstRect: %p\n",
+               id,
+               srcSurface,
+               dstSurface,
+               srcRect,
+               dstRect);
+        return FAILURE;
+    }
+
+    memset(&src_surface, 0, sizeof(ES2D_SURFACE));
+    memset(&dst_surface, 0, sizeof(ES2D_SURFACE));
+    memset(&src_rect, 0, sizeof(ES2D_RECT));
+    memset(&dst_rect, 0, sizeof(ES2D_RECT));
+
+    src_surface.width = srcSurface->width;
+    src_surface.height = srcSurface->height;
+    src_surface.format = vf_pixfmt_to_2dfmt(srcSurface->pixfmt);
+    src_surface.dma_buf = srcSurface->dma_buf;
+
+    dst_surface.width = dstSurface->width;
+    dst_surface.height = dstSurface->height;
+    dst_surface.format = vf_pixfmt_to_2dfmt(dstSurface->pixfmt);
+    dst_surface.dma_buf = dstSurface->dma_buf;
+
+    src_rect.bottom = srcRect->bottom;
+    src_rect.left = srcRect->left;
+    src_rect.right = srcRect->right;
+    src_rect.top = srcRect->top;
+
+    dst_rect.bottom = dstRect->bottom;
+    dst_rect.left = dstRect->left;
+    dst_rect.right = dstRect->right;
+    dst_rect.top = dstRect->top;
+
+    vf_printf_2Dsurface(&src_surface, "src_surface");
+    vf_printf_2Dsurface(&dst_surface, "dst_surface");
+    vf_printf_2Drect(&src_rect, "src_rect");
+    vf_printf_2Drect(&dst_rect, "dst_rect");
+
+    if (normalizationParas) {
+        is_normalization = 1;
+        // for mode
+        normalization_paras.normalizationMode =  normalizationParas->normalizationMode;
+        // for min-max
+        normalization_paras.minValue.R = normalizationParas->minValue.R;
+        normalization_paras.minValue.G = normalizationParas->minValue.G;
+        normalization_paras.minValue.B = normalizationParas->minValue.B;
+        normalization_paras.maxMinReciprocal.R = normalizationParas->maxMinReciprocal.R;
+        normalization_paras.maxMinReciprocal.G = normalizationParas->maxMinReciprocal.G;
+        normalization_paras.maxMinReciprocal.B = normalizationParas->maxMinReciprocal.B;
+        // for z-score
+        normalization_paras.meanValue.R = normalizationParas->meanValue.R;
+        normalization_paras.meanValue.G = normalizationParas->meanValue.G;
+        normalization_paras.meanValue.B = normalizationParas->meanValue.B;
+        normalization_paras.stdReciprocal.R = normalizationParas->stdReciprocal.R;
+        normalization_paras.stdReciprocal.G = normalizationParas->stdReciprocal.G;
+        normalization_paras.stdReciprocal.B = normalizationParas->stdReciprocal.B;
+        // for stepReciprocal
+        normalization_paras.stepReciprocal = normalizationParas->stepReciprocal;
+
+        vf_printf_normalization_params(&normalization_paras);
+    }
+
+    if (es2d_work(*id,
+                  &src_surface,
+                  &dst_surface,
+                  OP_STRECHBLIT,
+                  is_normalization ? &normalization_paras : NULL,
+                  &src_rect,
+                  &dst_rect) == ES2D_STATUS_OK) {
+        ret = SUCCESS;
+    }
+
+    return ret;
+}
+
+#endif
\ No newline at end of file
diff --git a/libavfilter/esvfcommon.h b/libavfilter/esvfcommon.h
new file mode 100644
index 0000000000..2010a7f485
--- /dev/null
+++ b/libavfilter/esvfcommon.h
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ESVF_COMMON_H
+#define AVCODEC_ESVF_COMMON_H
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <time.h>
+#include <sys/timeb.h>
+#include "libavutil/time.h"
+#include <linux/limits.h>
+#include <unistd.h>
+#include <libavutil/pixfmt.h>
+#include <libavutil/frame.h>
+#ifndef MODEL_SIMULATION
+#include <es-dma-buf.h>
+#endif
+
+#ifndef SUCCESS
+#define SUCCESS (0)
+#endif
+
+#ifndef FAILURE
+#define FAILURE (-1)
+#endif
+
+#ifndef ERR_TIMEOUT
+#define ERR_TIMEOUT (-2)
+#endif
+
+#ifndef TRUE
+#define TRUE (1)
+#endif
+
+#ifndef FALSE
+#define FALSE (0)
+#endif
+
+#define MAX_OUTPUT_BUFFERS 18
+#define DEFAULT_OUTPUT_BUFFERS 3
+
+
+#define SIDE_DATA_TYPE_MEM_FRAME_FD 0x12340007
+#define SIDE_DATA_TYPE_MEM_FRAME_FD_RELEASE 0x12340008
+
+typedef unsigned char ES2D_ID;
+
+typedef struct _CropInfo{
+    int crop_xoffset;
+    int crop_yoffset;
+    int crop_width;
+    int crop_height;
+} CropInfo;
+
+typedef struct _ScaleInfo{
+    int scale_width;
+    int scale_height;
+} ScaleInfo;
+
+typedef struct _VF2DSurface {
+    void *dma_buf; //es_dma_buf structure point
+    int32_t offset; //the offset based on dma_buf
+    int32_t width;
+    int32_t height;
+    enum AVPixelFormat pixfmt;
+} VF2DSurface;
+
+typedef struct _VF2DRect {
+    int32_t left;
+    int32_t top;
+    int32_t right;
+    int32_t bottom;
+} VF2DRect;
+
+typedef enum _VF2DNormalizationMode {
+    VF2D_NORMALIZATION_MIN_MAX,
+    VF2D_NORMALIZATION_Z_SCORE
+} VF2DNormalizationMode;
+
+typedef struct _VF2DRGBU32 {
+    uint32_t R;
+    uint32_t G;
+    uint32_t B;
+} VF2DRgbU32;
+
+typedef struct _VF2DNormalizationParams {
+    VF2DNormalizationMode normalizationMode;
+    VF2DRgbU32 minValue;
+    VF2DRgbU32 maxMinReciprocal;
+    VF2DRgbU32 stdReciprocal;
+    VF2DRgbU32 meanValue;
+    uint32_t stepReciprocal;
+} VF2DNormalizationParams;
+
+int vf_is_simulation(void);
+
+int vf_add_fd_to_side_data(AVFrame *frame, uint64_t fd);
+
+int esvf_get_fd(const AVFrame *frame, int64_t *fd);
+
+void esvf_memcpy_block(void *src, void *dst, size_t data_size);
+
+int esvf_memcpy_by_line(uint8_t *src, uint8_t *dst, int src_linesize, int dst_linesize, int linecount);
+
+FILE *vf_dump_file_open(const char *dump_path, const char* filename);
+
+int vf_dump_bytes_to_file(void *data, int size, FILE *fp);
+
+int vf_para_crop(char *str, CropInfo *crop_info);
+
+int vf_para_scale(char *str, ScaleInfo *scale_info);
+
+int vf_para_normalization_rgb(char *str, VF2DRgbU32 *RGB_info);
+
+#ifndef MODEL_SIMULATION
+int vf_2D_init(ES2D_ID *id);
+
+int vf_2D_unint(ES2D_ID *id);
+
+int vf_2D_work(ES2D_ID *id,
+               VF2DSurface *srcSurface,
+               VF2DSurface *dstSurface,
+               VF2DNormalizationParams *normalizationParas,
+               VF2DRect *srcRect,
+               VF2DRect *dstRect);
+#endif
+
+#endif
\ No newline at end of file
diff --git a/libavfilter/esvfqueue.c b/libavfilter/esvfqueue.c
new file mode 100644
index 0000000000..c646571161
--- /dev/null
+++ b/libavfilter/esvfqueue.c
@@ -0,0 +1,230 @@
+#define LOG_TAG "esqueue"
+#include <sys/time.h>
+#include "esvfqueue.h"
+#include <libavutil/log.h>
+#include "esvfcommon.h"
+
+static int32_t get_clock_time_by_timeout(struct timespec *ts, int32_t timeout_ms) {
+    int64_t reltime_sec;
+    int64_t time_sec;
+
+    if (!ts || timeout_ms <= 0) {
+        av_log(NULL, AV_LOG_ERROR, "error  ts: %p, timeout_ms: %d", ts, timeout_ms);
+        return -1;
+    }
+
+    clock_gettime(CLOCK_MONOTONIC, ts);
+
+    reltime_sec = timeout_ms / 1000;
+    ts->tv_nsec += (long)(timeout_ms % 1000 * 1000000);
+    if (reltime_sec < INT64_MAX && ts->tv_nsec >= 1000000000) {
+        ts->tv_nsec -= 1000000000;
+        ++reltime_sec;
+    }
+
+    time_sec = ts->tv_sec;
+    if (time_sec > INT64_MAX - reltime_sec) {
+        time_sec = INT64_MAX;
+    } else {
+        time_sec += reltime_sec;
+    }
+
+    ts->tv_sec = (time_sec > LONG_MAX) ? LONG_MAX : (long)(time_sec);
+
+    return 0;
+}
+
+ESFifoQueue *esvf_fifo_queue_create(size_t nmemb, int mem_size, const char *name) {
+    pthread_condattr_t attr;
+    ESFifoQueue *queue;
+    if (nmemb <= 0 || mem_size < 0) {
+        return NULL;
+    }
+
+    queue = av_mallocz(sizeof(*queue));
+    if (!queue) {
+        return NULL;
+    }
+
+    queue->fifo = av_fifo_alloc_array(nmemb, mem_size);
+    if (!queue->fifo) {
+        av_freep(&queue);
+        return NULL;
+    }
+    queue->mem_size = mem_size;
+    queue->nmemb = nmemb;
+    queue->name = av_strdup(name);
+
+    pthread_condattr_init(&attr);
+    pthread_condattr_setclock(&attr, CLOCK_MONOTONIC);
+    pthread_cond_init(&queue->fifo_cond, &attr);
+    pthread_mutex_init(&queue->fifo_mutex, NULL);
+
+    return queue;
+}
+
+void esvf_fifo_queue_free(ESFifoQueue **queue) {
+    ESFifoQueue *q;
+    if (!queue || !*queue) {
+        return;
+    }
+
+    q = *queue;
+    av_free(q->name);
+    pthread_mutex_destroy(&q->fifo_mutex);
+    pthread_cond_destroy(&q->fifo_cond);
+    av_fifo_freep(&q->fifo);
+    av_freep(queue);
+}
+
+int esvf_fifo_queue_push(ESFifoQueue *queue, void *src, int size) {
+    int ret = FAILURE;
+    int fifo_size;
+    if (!queue || !queue->fifo || !src) {
+        av_log(NULL, AV_LOG_ERROR, "params error!!! queue: %p, src: %p\n", queue, src);
+        return FAILURE;
+    }
+
+    if (queue->mem_size != size) {
+        av_log(NULL, AV_LOG_ERROR,
+               "params error!!! size: %d, mem_size: %d\n",
+               size,
+               queue->mem_size);
+        return FAILURE;
+    }
+
+    pthread_mutex_lock(&queue->fifo_mutex);
+    fifo_size = av_fifo_space(queue->fifo);
+    if (fifo_size >= size) {
+        av_fifo_generic_write(queue->fifo, src, size, NULL);
+        ret = SUCCESS;
+        pthread_cond_signal(&queue->fifo_cond);
+    } else {
+        av_log(NULL, AV_LOG_ERROR, "error !!! fifo_size: %d, size: %d\n", fifo_size, size);
+    }
+    pthread_mutex_unlock(&queue->fifo_mutex);
+
+    return ret;
+}
+int esvf_fifo_queue_pop(ESFifoQueue *queue, void *dest, int dest_size) {
+    int ret = SUCCESS;
+    int fifo_size;
+    if (!queue || !queue->fifo || !dest || queue->mem_size != dest_size) {
+        av_log(NULL, AV_LOG_ERROR, "params error!!! dest_size: %d\n", dest_size);
+        return FAILURE;
+    }
+
+    pthread_mutex_lock(&queue->fifo_mutex);
+    if (!queue->abort_request) {
+        fifo_size = av_fifo_size(queue->fifo);
+        if (fifo_size < dest_size) {
+            if (fifo_size != 0) {
+                av_log(NULL, AV_LOG_ERROR,
+                      "error fifo_size: %d, dest_size: %d\n",
+                      fifo_size,
+                      dest_size);
+            }
+            pthread_cond_wait(&queue->fifo_cond, &queue->fifo_mutex);
+            fifo_size = av_fifo_size(queue->fifo);
+            if (fifo_size < dest_size) {
+                av_log(NULL, AV_LOG_WARNING,
+                       "wait success but fifo_size: %d error dest_size: %d\n",
+                       fifo_size,
+                       dest_size);
+                ret = FAILURE;
+            }
+        }
+
+        if (ret == SUCCESS) {
+            ret = av_fifo_generic_read(queue->fifo, dest, dest_size, NULL);
+        }
+    } else {
+        ret = FAILURE;
+        av_log(NULL, AV_LOG_INFO, "pop failed %s queue abort_request\n", queue->name);
+    }
+    pthread_mutex_unlock(&queue->fifo_mutex);
+
+    return ret;
+}
+
+int esvf_fifo_queue_pop_ignore_abort(ESFifoQueue *queue, void *dest, int dest_size) {
+    int ret = FAILURE;
+    int fifo_size;
+    if (!queue || !queue->fifo || !dest || queue->mem_size != dest_size) {
+        av_log(NULL, AV_LOG_ERROR, "params error!!! dest_size: %d\n", dest_size);
+        return FAILURE;
+    }
+
+    pthread_mutex_lock(&queue->fifo_mutex);
+    fifo_size = av_fifo_size(queue->fifo);
+    av_log(NULL, AV_LOG_INFO, "fifo_size: %d, dest_size: %d\n", fifo_size, dest_size);
+    if (fifo_size >= dest_size) {
+        ret = SUCCESS;
+        av_fifo_generic_read(queue->fifo, dest, dest_size, NULL);
+    }
+    pthread_mutex_unlock(&queue->fifo_mutex);
+
+    return ret;
+}
+
+int esvf_fifo_queue_pop_until_timeout(ESFifoQueue *queue, void *dest, int dest_size, int timeout_ms) {
+    int ret = SUCCESS;
+    int fifo_size;
+    if (!queue || !queue->fifo || !dest || queue->mem_size != dest_size) {
+        av_log(NULL, AV_LOG_ERROR, "params error!!! dest_size: %d\n", dest_size);
+        return FAILURE;
+    }
+
+    pthread_mutex_lock(&queue->fifo_mutex);
+    if (!queue->abort_request) {
+        fifo_size = av_fifo_size(queue->fifo);
+        if (fifo_size < dest_size) {
+            if (fifo_size != 0) {
+                av_log(NULL, AV_LOG_ERROR,
+                      "error fifo_size: %d,dest_size: %d\n",
+                      fifo_size,
+                      dest_size);
+            }
+            if (timeout_ms == -1) {
+                pthread_cond_wait(&queue->fifo_cond, &queue->fifo_mutex);
+            } else if (timeout_ms > 0) {
+                struct timespec ts;
+                get_clock_time_by_timeout(&ts, timeout_ms);
+                ret = pthread_cond_timedwait(&queue->fifo_cond, &queue->fifo_mutex, &ts);
+            } else {
+                ret = FAILURE;
+            }
+
+            if (ret == SUCCESS) {
+                fifo_size = av_fifo_size(queue->fifo);
+                if (fifo_size < dest_size) {
+                    av_log(NULL, AV_LOG_WARNING,
+                           "wait success but fifo_size: %d error dest_size: %d\n",
+                           fifo_size,
+                           dest_size);
+                    ret = FAILURE;
+                }
+            }
+        }
+        if (ret == SUCCESS) {
+            ret = av_fifo_generic_read(queue->fifo, dest, dest_size, NULL);
+        }
+    } else {
+        ret = FAILURE;
+        av_log(NULL, AV_LOG_INFO, "pop failed %s queue abort_request\n", queue->name);
+    }
+    pthread_mutex_unlock(&queue->fifo_mutex);
+
+    return ret;
+}
+
+void esvf_fifo_queue_abort(ESFifoQueue *queue) {
+    if (!queue) {
+        return;
+    }
+    pthread_mutex_lock(&queue->fifo_mutex);
+    queue->abort_request = TRUE;
+    pthread_cond_broadcast(&queue->fifo_cond);
+    av_log(NULL, AV_LOG_INFO, "%s request abort\n", queue->name);
+    pthread_mutex_unlock(&queue->fifo_mutex);
+}
diff --git a/libavfilter/esvfqueue.h b/libavfilter/esvfqueue.h
new file mode 100644
index 0000000000..d21c6cf8ea
--- /dev/null
+++ b/libavfilter/esvfqueue.h
@@ -0,0 +1,28 @@
+#ifndef AVCODEC_ESQUEUE_H_
+#define AVCODEC_ESQUEUE_H_
+#include "libavutil/fifo.h"
+#include "libavutil/thread.h"
+
+typedef struct ESFifoQueue {
+    int abort_request;
+    int mem_size;
+    int nmemb;
+    AVFifoBuffer *fifo;
+    char *name;
+    pthread_mutex_t fifo_mutex;
+    pthread_cond_t fifo_cond;
+} ESFifoQueue;
+
+ESFifoQueue *esvf_fifo_queue_create(size_t nmemb, int mem_size, const char *name);
+void esvf_fifo_queue_free(ESFifoQueue **queue);
+int esvf_fifo_queue_push(ESFifoQueue *queue, void *src, int src_size);
+int esvf_fifo_queue_pop(ESFifoQueue *queue, void *dest, int dest_size);
+int esvf_fifo_queue_pop_ignore_abort(ESFifoQueue *queue, void *dest, int dest_size);
+void esvf_fifo_queue_abort(ESFifoQueue *queue);
+void esvf_fifo_queue_deinit(ESFifoQueue **queue);
+int esvf_fifo_queue_pop_until_timeout(ESFifoQueue *queue,
+                                      void *dest,
+                                      int dest_size,
+                                      int timeout_ms);
+
+#endif
\ No newline at end of file
diff --git a/libavfilter/vf_convert_es.c b/libavfilter/vf_convert_es.c
new file mode 100644
index 0000000000..47aa5181ad
--- /dev/null
+++ b/libavfilter/vf_convert_es.c
@@ -0,0 +1,1234 @@
+#include <stdio.h>
+#include <string.h>
+#include <dlfcn.h>
+#include "libavutil/avstring.h"
+#include "libavutil/common.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_es.h"
+#include "esvfbuffer.h"
+#include "esvfcommon.h"
+#include "libavutil/internal.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/pixfmt.h"
+#include "libavutil/imgutils.h"
+#include "avfilter.h"
+#include "formats.h"
+#include "internal.h"
+#include "video.h"
+
+static const enum AVPixelFormat supported_formats[] = {
+    AV_PIX_FMT_NV12,
+    AV_PIX_FMT_NV21,
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_GRAY8,
+    AV_PIX_FMT_GRAYF32LE,
+    AV_PIX_FMT_YUV420P10LE,
+    AV_PIX_FMT_P010LE,
+    AV_PIX_FMT_YVYU422,
+    AV_PIX_FMT_YUYV422,
+    AV_PIX_FMT_UYVY422,
+    AV_PIX_FMT_NV16,
+    AV_PIX_FMT_RGB24,
+    AV_PIX_FMT_BGR24,
+    AV_PIX_FMT_ARGB,
+    AV_PIX_FMT_ABGR,
+    AV_PIX_FMT_BGRA,
+    AV_PIX_FMT_RGBA,
+    AV_PIX_FMT_B16G16R16I,
+    AV_PIX_FMT_B16G16R16I_PLANAR,
+    AV_PIX_FMT_B8G8R8_PLANAR,
+    AV_PIX_FMT_B8G8R8I,
+    AV_PIX_FMT_B8G8R8I_PLANAR,
+    AV_PIX_FMT_B16G16R16F,
+    AV_PIX_FMT_B16G16R16F_PLANAR,
+    AV_PIX_FMT_B32G32R32F,
+    AV_PIX_FMT_B32G32R32F_PLANAR,
+};
+
+typedef struct _MemoryInfo {
+    int64_t fd;
+    uint32_t size;
+    void *vir_addr;
+    ESMemory *memory;  // only be used in output memory
+#ifndef MODEL_SIMULATION
+    es_dma_buf *dma_buf;
+    // uint32_t need_map;
+#endif
+} MemoryInfo;
+
+typedef struct _VideoRect {
+    uint32_t width;
+    uint32_t height;
+    uint32_t xoffset;
+    uint32_t yoffset;
+} VideoRect;
+
+typedef struct ConvertContext {
+    const AVClass *class;
+    enum AVPixelFormat in_fmt;
+    enum AVPixelFormat out_fmt;
+
+    AVBufferRef *hw_device_ref;
+    AVBufferRef *in_hw_frame_ref;
+    AVBufferRef *out_hw_frame_ref;
+
+    AVVSVDeviceContext *hw_dev_ctx;
+    AVHWFramesContext *in_hw_frame_ctx;
+    AVHWFramesContext *out_hw_frame_ctx;
+
+    ES2D_ID id;
+
+    MemoryInfo input_mem;
+
+    VideoRect src_video_rect;
+    VideoRect dst_video_rect;
+
+    CropInfo crop_info;
+    ScaleInfo scale_info;
+    uint32_t is_crop;
+    uint32_t is_scale;
+    VF2DRgbU32 min_value;
+    VF2DRgbU32 max_min_reciprocal;
+    VF2DRgbU32 std_reciprocal;
+    VF2DRgbU32 mean_value;
+    uint32_t is_normalization;
+
+    ESOutputPort *port;
+
+    uint32_t stride_align;
+    char *scale_set;
+    char *crop_set;
+    int32_t enter_out_fmt;
+    char *dump_path;
+    char *mm_r;
+    char *min;
+    char *mean;
+    char *std_r;
+    uint32_t step_r;
+    int32_t normalization_mode;
+
+    FILE *fp_input;
+    FILE *fp_output;
+
+} ConvertContext;
+
+static int query_formats(AVFilterContext *ctx) {
+    static const enum AVPixelFormat pixel_formats[] = {
+        AV_PIX_FMT_NV12,        AV_PIX_FMT_NV21,   AV_PIX_FMT_YUV420P, AV_PIX_FMT_GRAY8,   AV_PIX_FMT_GRAYF32LE,
+        AV_PIX_FMT_YUV420P10LE, AV_PIX_FMT_P010LE, AV_PIX_FMT_YVYU422, AV_PIX_FMT_YUYV422, AV_PIX_FMT_UYVY422,
+        AV_PIX_FMT_NV16,        AV_PIX_FMT_RGB24,  AV_PIX_FMT_BGR24,   AV_PIX_FMT_ARGB,    AV_PIX_FMT_ABGR,
+        AV_PIX_FMT_BGRA,        AV_PIX_FMT_RGBA,   AV_PIX_FMT_ES,      AV_PIX_FMT_NONE,
+    };
+    AVFilterFormats *pix_fmts = ff_make_format_list(pixel_formats);
+
+    int ret;
+    if ((ret = ff_set_common_formats(ctx, pix_fmts)) < 0) return ret;
+
+    return 0;
+}
+
+static int convert_format_is_supported(enum AVPixelFormat pixfmt) {
+    int i;
+    for (i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++)
+        if (supported_formats[i] == pixfmt) return SUCCESS;
+    return FAILURE;
+}
+
+static av_cold int init(AVFilterContext *ctx) {
+    ConvertContext *s = (ConvertContext *)ctx->priv;
+    int ret = SUCCESS;
+
+    if (!s) {
+        ret = FAILURE;
+        return ret;
+    }
+    s->hw_device_ref = NULL;
+    s->in_hw_frame_ref = NULL;
+    s->out_hw_frame_ref = NULL;
+
+    s->hw_dev_ctx = NULL;
+    s->in_hw_frame_ctx = NULL;
+    s->out_hw_frame_ctx = NULL;
+
+    s->is_scale = 0;
+    s->is_crop = 0;
+    s->crop_info.crop_height = 0;
+    s->crop_info.crop_width = 0;
+    s->crop_info.crop_xoffset = 0;
+    s->crop_info.crop_yoffset = 0;
+    s->scale_info.scale_height = 0;
+    s->scale_info.scale_width = 0;
+
+    s->port = NULL;
+    s->input_mem.vir_addr = NULL;
+    s->input_mem.size = 0;
+    s->input_mem.fd = -1;
+#ifndef MODEL_SIMULATION
+    s->input_mem.dma_buf = NULL;
+    // s->input_mem.need_map = 0;
+
+    // init 2D handle
+    ret = vf_2D_init(&s->id);
+    if (ret < 0) {
+        av_log(NULL, AV_LOG_ERROR, "vf_2D_init failed\n");
+        ret = FAILURE;
+        return ret;
+    }
+#endif
+
+    s->fp_input = NULL;
+    s->fp_output = NULL;
+    if (s->dump_path) {
+        s->fp_input = vf_dump_file_open(s->dump_path, "input");
+        if (!s->fp_input) {
+            av_log(ctx, AV_LOG_ERROR, "create dump input data file failed\n");
+        }
+        s->fp_output = vf_dump_file_open(s->dump_path, "output");
+        if (!s->fp_output) {
+            av_log(ctx, AV_LOG_ERROR, "create dump output data file failed\n");
+        }
+    }
+
+    return ret;
+}
+
+static av_cold void uninit(AVFilterContext *ctx) {
+    ConvertContext *s = (ConvertContext *)ctx->priv;
+
+    if (s->in_hw_frame_ref) {
+        av_buffer_unref(&s->in_hw_frame_ref);
+    }
+    if (s->out_hw_frame_ref) {
+        av_buffer_unref(&s->out_hw_frame_ref);
+    }
+    if (s->hw_device_ref) {
+        av_buffer_unref(&s->hw_device_ref);
+    }
+
+    // unref output port
+    esvf_output_port_unref(&s->port);
+
+    if (s->input_mem.fd >= 0) {
+        if (vf_is_simulation()) {
+            if (s->input_mem.vir_addr) av_free(s->input_mem.vir_addr);
+        } else {
+#ifndef MODEL_SIMULATION
+            es_dma_unmap(s->input_mem.dma_buf);
+            es_dma_free(s->input_mem.dma_buf);
+#endif
+        }
+    }
+
+#ifndef MODEL_SIMULATION
+    int ret = SUCCESS;
+    ret = vf_2D_unint(&s->id);
+    if (ret < 0) {
+        av_log(ctx, AV_LOG_ERROR, "vf_2D_unint failed.\n");
+    }
+#endif
+
+    if (s->fp_input) {
+        fclose(s->fp_input);
+    }
+    if (s->fp_output) {
+        fclose(s->fp_output);
+    }
+}
+
+static int convert_para_crop(char *crop_set, CropInfo *crop_info, int width, int height) {
+    int ret = SUCCESS;
+
+    if (crop_set) {
+        ret = vf_para_crop(crop_set, crop_info);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "vf_para_crop failed\n");
+            return FAILURE;
+        }
+
+        crop_info->crop_width = FFALIGN(crop_info->crop_width, 2);
+        crop_info->crop_height = FFALIGN(crop_info->crop_height, 2);
+        crop_info->crop_xoffset = FFALIGN(crop_info->crop_xoffset, 2);
+        crop_info->crop_yoffset = FFALIGN(crop_info->crop_yoffset, 2);
+
+        if (crop_info->crop_xoffset + crop_info->crop_width > width
+            || crop_info->crop_yoffset + crop_info->crop_height > height) {
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "crop paras are invaild crop:%d:%d;%d:%d\n",
+                   crop_info->crop_xoffset,
+                   crop_info->crop_yoffset,
+                   crop_info->crop_width,
+                   crop_info->crop_height);
+            return FAILURE;
+        }
+    }
+
+    return SUCCESS;
+}
+
+static int convert_para_scale(char *scale_set, ScaleInfo *scale_info, int width, int height) {
+    int max_w = 0;
+    int max_h = 0;
+    int min_w = 0;
+    int min_h = 0;
+    int ret = SUCCESS;
+
+    if (scale_set) {
+        ret = vf_para_scale(scale_set, scale_info);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "vf_para_crop failed\n");
+            return FAILURE;
+        }
+
+        max_w = width * 32;
+        max_h = height * 32;
+        min_w = width / 32;
+        min_h = height / 32;
+
+        scale_info->scale_width = FFALIGN(scale_info->scale_width, 2);
+        scale_info->scale_height = FFALIGN(scale_info->scale_height, 2);
+
+        if (scale_info->scale_width < min_w || scale_info->scale_width > max_w || scale_info->scale_height > max_h
+            || scale_info->scale_height < min_h) {
+            av_log(NULL,
+                   AV_LOG_INFO,
+                   "scale paras are invaild scale:%d:%d\n",
+                   scale_info->scale_width,
+                   scale_info->scale_height);
+            return FAILURE;
+        }
+    }
+
+    return SUCCESS;
+}
+
+static int convert_get_output_fmt(ConvertContext *s) {
+    int ret = SUCCESS;
+
+    if (!s) {
+        av_log(NULL, AV_LOG_ERROR, "convert_get_output_fmt invaild paras, s: %p\n", s);
+        return FAILURE;
+    }
+
+    if (s->enter_out_fmt == -1) {
+        s->out_fmt = s->in_fmt;
+        return SUCCESS;
+    }
+
+    ret = convert_format_is_supported(s->enter_out_fmt);
+    if (ret < 0) {
+        av_log(NULL, AV_LOG_ERROR, "enter_out_fmt: %d, is not supported\n", s->enter_out_fmt);
+        return FAILURE;
+    }
+
+    s->out_fmt = (enum AVPixelFormat)s->enter_out_fmt;
+    av_log(NULL, AV_LOG_INFO, "output format: %s\n", av_get_pix_fmt_name(s->out_fmt));
+
+    return SUCCESS;
+}
+
+static int convert_para_normalization(ConvertContext *s) {
+    int ret = SUCCESS;
+
+    if (!s) {
+        av_log(NULL, AV_LOG_ERROR, "convert_para_normalization invaild paras, s: %p\n", s);
+        return FAILURE;
+    }
+
+    s->is_normalization = 0;
+
+    if (s->normalization_mode != 0 && s->normalization_mode != 1) {
+        av_log(NULL, AV_LOG_INFO, "do not normalization, normalization_mode: %d\n", s->normalization_mode);
+        return SUCCESS;
+    }
+
+    if (s->normalization_mode == 0 && (!s->min || !s->mm_r)) {
+        av_log(NULL, AV_LOG_ERROR, "normalization_mode is min_max, min: %p, mm_r: %p\n", s->min, s->mm_r);
+        return FAILURE;
+    }
+
+    if (s->normalization_mode == 1 && (!s->mean || !s->std_r)) {
+        av_log(NULL, AV_LOG_ERROR, "normalization_mode is z_score, mean: %p, std_r: %p\n", s->mean, s->std_r);
+        return FAILURE;
+    }
+
+    if (s->mm_r) {
+        ret = vf_para_normalization_rgb(s->mm_r, &s->max_min_reciprocal);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "para max_min_reciprocal failed\n");
+            return FAILURE;
+        }
+    }
+    if (s->min) {
+        ret = vf_para_normalization_rgb(s->min, &s->min_value);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "para min_value failed\n");
+            return FAILURE;
+        }
+    }
+    if (s->mean) {
+        ret = vf_para_normalization_rgb(s->mean, &s->mean_value);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "para mean_value failed\n");
+            return FAILURE;
+        }
+    }
+    if (s->std_r) {
+        ret = vf_para_normalization_rgb(s->std_r, &s->std_reciprocal);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "para std_reciprocal failed\n");
+            return FAILURE;
+        }
+    }
+
+    s->is_normalization = 1;
+
+    av_log(NULL, AV_LOG_DEBUG, "normalizationMode: %d,stepReciprocal: %x\n", s->normalization_mode, s->step_r);
+    av_log(NULL,
+           AV_LOG_DEBUG,
+           "min_value.R: %x, min_value.G: %x, min_value.B: %x\n",
+           s->min_value.R,
+           s->min_value.G,
+           s->min_value.B);
+    av_log(NULL,
+           AV_LOG_DEBUG,
+           "maxMinReciprocal.R: %x, maxMinReciprocal.G: %x, maxMinReciprocal.B: %x\n",
+           s->max_min_reciprocal.R,
+           s->max_min_reciprocal.G,
+           s->max_min_reciprocal.B);
+    av_log(NULL,
+           AV_LOG_DEBUG,
+           "meanValue.R: %x, meanValue.G: %x, meanValue.B: %x\n",
+           s->mean_value.R,
+           s->mean_value.G,
+           s->mean_value.B);
+    av_log(NULL,
+           AV_LOG_DEBUG,
+           "stdReciprocal.R: %x, stdReciprocal.G: %x, stdReciprocal.B: %x\n",
+           s->std_reciprocal.R,
+           s->std_reciprocal.G,
+           s->std_reciprocal.B);
+
+    return SUCCESS;
+}
+
+static av_cold int convert_config_props(AVFilterLink *outlink) {
+    AVFilterContext *ctx = outlink->src;
+    AVFilterLink *inlink = ctx->inputs[0];
+    ConvertContext *s = (ConvertContext *)ctx->priv;
+
+    AVVSVDeviceContext *hw_device_ctx = NULL;
+    AVHWFramesContext *in_hw_frames_ctx = NULL;
+    AVHWFramesContext *out_hw_frames_ctx = NULL;
+
+    MemInfo *mem_info = NULL;
+    int buffer_size = 0;
+    int height = 0;
+    int buf_num;
+    int ret = FAILURE;
+
+    s->src_video_rect.width = inlink->w;
+    s->src_video_rect.height = inlink->h;
+    s->src_video_rect.xoffset = 0;
+    s->src_video_rect.yoffset = 0;
+
+    if (s->crop_set) {
+        ret = convert_para_crop(s->crop_set, &s->crop_info, inlink->w, inlink->h);
+        if (ret == SUCCESS) {
+            s->is_crop = 1;
+        } else {
+            av_log(ctx, AV_LOG_ERROR, "crop paras are invaild.\n");
+            return FAILURE;
+        }
+    } else {
+        s->crop_info.crop_height = inlink->h;
+        s->crop_info.crop_width = inlink->w;
+        s->crop_info.crop_xoffset = 0;
+        s->crop_info.crop_yoffset = 0;
+    }
+
+    if (s->scale_set) {
+        if (s->is_crop) {
+            ret = convert_para_scale(s->scale_set, &s->scale_info, s->crop_info.crop_width, s->crop_info.crop_height);
+        } else {
+            ret = convert_para_scale(s->scale_set, &s->scale_info, inlink->w, inlink->h);
+        }
+        if (ret == SUCCESS) {
+            s->is_scale = 1;
+        } else {
+            av_log(ctx, AV_LOG_ERROR, "scale paras are invaild.\n");
+            return FAILURE;
+        }
+    } else {
+        if (s->is_crop) {
+            s->scale_info.scale_height = s->crop_info.crop_height;
+            s->scale_info.scale_width = s->crop_info.crop_width;
+        } else {
+            s->scale_info.scale_height = inlink->h;
+            s->scale_info.scale_width = inlink->w;
+        }
+    }
+
+    if (s->is_crop && !s->is_scale) {
+        s->dst_video_rect.width = s->crop_info.crop_width;
+        s->dst_video_rect.height = s->crop_info.crop_height;
+    } else if (s->is_scale) {
+        s->dst_video_rect.width = s->scale_info.scale_width;
+        s->dst_video_rect.height = s->scale_info.scale_height;
+    } else {
+        s->dst_video_rect.width = inlink->w;
+        s->dst_video_rect.height = inlink->h;
+    }
+
+    outlink->w = s->dst_video_rect.width;
+    outlink->h = s->dst_video_rect.height;
+
+    ret = convert_para_normalization(s);
+    if (ret < 0) {
+        av_log(ctx, AV_LOG_ERROR, "normalization param is invaild\n");
+        return FAILURE;
+    }
+
+    if (inlink->format == AV_PIX_FMT_ES && inlink->hw_frames_ctx) {
+        in_hw_frames_ctx = (AVHWFramesContext *)inlink->hw_frames_ctx->data;
+        hw_device_ctx = in_hw_frames_ctx->device_ctx->hwctx;
+
+        if (!inlink->hw_frames_ctx) {
+            av_log(ctx, AV_LOG_ERROR, "Input must have a hwframe reference. \n");
+            if (!s->in_hw_frame_ref) av_buffer_unref(&s->in_hw_frame_ref);
+            if (!s->out_hw_frame_ref) av_buffer_unref(&s->out_hw_frame_ref);
+            if (!s->hw_device_ref) av_buffer_unref(&s->hw_device_ref);
+            return AVERROR(EINVAL);
+        }
+
+        s->in_hw_frame_ref = av_buffer_ref(inlink->hw_frames_ctx);
+        s->hw_device_ref = av_buffer_ref(in_hw_frames_ctx->device_ref);
+
+        s->hw_dev_ctx = hw_device_ctx;
+        s->in_hw_frame_ctx = in_hw_frames_ctx;
+
+        s->in_fmt = in_hw_frames_ctx->sw_format;
+        ret = convert_get_output_fmt(s);
+        if (ret < 0) {
+            av_log(ctx, AV_LOG_ERROR, "convert_get_output_fmt failed \n");
+            return FAILURE;
+        }
+
+        outlink->format = inlink->format;
+
+        av_buffer_unref(&s->out_hw_frame_ref);
+        s->out_hw_frame_ref = av_hwframe_ctx_alloc(s->hw_device_ref);
+        if (!s->out_hw_frame_ref) {
+            av_log(ctx, AV_LOG_ERROR, "av_hwframe_ctx_alloc failed \n");
+            if (!s->in_hw_frame_ref) av_buffer_unref(&s->in_hw_frame_ref);
+            if (!s->out_hw_frame_ref) av_buffer_unref(&s->out_hw_frame_ref);
+            if (!s->hw_device_ref) av_buffer_unref(&s->hw_device_ref);
+            return AVERROR(EINVAL);
+        }
+        out_hw_frames_ctx = (AVHWFramesContext *)s->out_hw_frame_ref->data;
+        s->out_hw_frame_ctx = out_hw_frames_ctx;
+        out_hw_frames_ctx->format = AV_PIX_FMT_ES;
+        out_hw_frames_ctx->sw_format = s->out_fmt;
+        out_hw_frames_ctx->width = FFALIGN(outlink->w, s->stride_align);
+        out_hw_frames_ctx->height = FFALIGN(outlink->h, 1);
+        outlink->hw_frames_ctx = av_buffer_ref(s->out_hw_frame_ref);
+    } else {
+        s->in_fmt = inlink->format;
+        ret = convert_get_output_fmt(s);
+        if (ret < 0) {
+            av_log(ctx, AV_LOG_ERROR, "convert_get_output_fmt failed \n");
+            return FAILURE;
+        }
+        outlink->format = s->out_fmt;
+    }
+
+    if (s->port) {
+        esvf_output_port_unref(&s->port);
+    }
+    if (inlink->format == AV_PIX_FMT_ES) {
+        if (ctx->extra_hw_frames > 0) {
+            buf_num = ctx->extra_hw_frames;
+        } else {
+            buf_num = 5;
+        }
+        av_log(ctx, AV_LOG_INFO, "hwaccel mode, allocate buffer num: %d\n", buf_num);
+        s->port = esvf_allocate_output_port(
+            buf_num, s->out_fmt, s->dst_video_rect.width, s->dst_video_rect.height, s->stride_align);
+    } else {
+        av_log(ctx, AV_LOG_INFO, "no hwaccel mode, allocate buffer num: 1\n");
+        s->port = esvf_allocate_output_port(
+            1, s->out_fmt, s->dst_video_rect.width, s->dst_video_rect.height, s->stride_align);
+    }
+    if (!s->port) {
+        av_log(ctx, AV_LOG_ERROR, "esvf_allocate_output_port faild\n");
+        ret = FAILURE;
+    }
+
+    return SUCCESS;
+}
+
+static int convert_transfer_data_from(AVFrame *dst, ConvertContext *s, MemoryInfo *out_mem) {
+    AVPixFmtDescriptor *desc;
+    int height;
+
+    if (!s || !out_mem || !dst) {
+        av_log(NULL, AV_LOG_INFO, "invaild paras, s: %p, out_mem: %p, dst: %p\n", s, out_mem, dst);
+        return FAILURE;
+    }
+
+    desc = av_pix_fmt_desc_get(s->out_fmt);
+    if (!desc) {
+        av_log(NULL,
+               AV_LOG_ERROR,
+               "convert_transfer_data_from get fmt: %s AVPixFmtDescriptor failed.\n",
+               av_get_pix_fmt_name(s->out_fmt));
+        return FAILURE;
+    }
+
+#ifndef MODEL_SIMULATION
+    es_dma_sync_start(out_mem->dma_buf);
+#endif
+    for (int i = 0; i < 4 && s->port->mem_info->datasize[i]; i++) {
+        height = s->port->mem_info->h;
+        if (i == 1 || i == 2) {
+            height = AV_CEIL_RSHIFT(height, desc->log2_chroma_h);
+        }
+        if (s->port->mem_info->linesize[i] == dst->linesize[i]) {
+            esvf_memcpy_block(out_mem->vir_addr + s->port->mem_info->offset[i],
+                              dst->data[i],
+                              s->port->mem_info->linesize[i] * height);
+        } else {
+            esvf_memcpy_by_line(out_mem->vir_addr + s->port->mem_info->offset[i],
+                                dst->data[i],
+                                s->port->mem_info->linesize[i],
+                                dst->linesize[i],
+                                height);
+        }
+    }
+#ifndef MODEL_SIMULATION
+    es_dma_sync_end(out_mem->dma_buf);
+#endif
+
+    return 0;
+}
+
+static AVFrame *convert_allocate_and_fill_output_frame(AVFilterLink *link, AVFrame *in, MemoryInfo *out_mem) {
+    AVFilterContext *ctx = link->dst;
+    ConvertContext *s = (ConvertContext *)ctx->priv;
+    AVFilterLink *outlink = ctx->outputs[0];
+    AVFrame *out = NULL;
+    ESMemory *memory;
+    ESBuffer *buffer;
+    int ret = FAILURE;
+
+    if (!out_mem) {
+        av_log(NULL, AV_LOG_ERROR, "out_mem: %p is null\n", out_mem);
+    }
+    memory = out_mem->memory;
+
+    if (link->format == AV_PIX_FMT_ES) {
+        out = av_frame_alloc();
+        if (!out) {
+            return NULL;
+        }
+        out->width = outlink->w;
+        out->height = outlink->h;
+        out->format = AV_PIX_FMT_ES;
+        out->key_frame = in->key_frame;
+        out->pts = in->pts;
+        out->reordered_opaque = in->reordered_opaque;
+        out->hw_frames_ctx = av_buffer_ref(s->out_hw_frame_ref);
+        buffer = &memory->buffer;
+        buffer->port_ref = av_buffer_ref(memory->port_ref);
+        buffer->buffer_ref = av_buffer_ref(memory->buffer_ref);
+        vf_add_fd_to_side_data(out, out_mem->fd);
+        for (int i = 0; i < 4 && s->port->mem_info->linesize[i]; i++) {
+            out->data[i] = out_mem->vir_addr + s->port->mem_info->offset[i];
+            out->linesize[i] = s->port->mem_info->linesize[i];
+        }
+        out->buf[0] =
+            av_buffer_create((uint8_t *)memory, sizeof(*memory), esvf_buffer_consume, s->port, AV_BUFFER_FLAG_READONLY);
+        if (!out->buf[0]) {
+            av_log(NULL, AV_LOG_ERROR, "av_buffer_create frame[0] failed\n");
+            av_free(out);
+            return NULL;
+        }
+    } else {
+        out = ff_get_video_buffer(outlink, FFALIGN(outlink->w, s->stride_align), outlink->h);
+        av_frame_copy_props(out, in);
+        out->width = outlink->w;
+        out->height = outlink->h;
+        out->format = s->out_fmt;
+        if (!out) {
+            return NULL;
+        }
+
+        ret = convert_transfer_data_from(out, s, out_mem);
+        if (ret == FAILURE) {
+            av_log(NULL, AV_LOG_ERROR, "convert_transfer_data_from failed\n");
+            av_frame_free(&out);
+            return NULL;
+        }
+    }
+
+    return out;
+}
+
+static int convert_memcpy_host2device(ConvertContext *s, AVFrame *in, MemoryInfo *input_mem) {
+    AVPixFmtDescriptor *desc;
+    int height = 0;
+    int cp_size = 0;
+    int totol_size = 0;
+
+    desc = av_pix_fmt_desc_get(s->in_fmt);
+    if (!desc) {
+        av_log(NULL,
+               AV_LOG_ERROR,
+               "convert_memcpy_host2device get fmt: %s AVPixFmtDescriptor failed.\n",
+               av_get_pix_fmt_name(s->out_fmt));
+        return FAILURE;
+    }
+
+#ifndef MODEL_SIMULATION
+    es_dma_sync_start(input_mem->dma_buf);
+#endif
+    for (int i = 0; i < FF_ARRAY_ELEMS(in->data) && in->data[i]; i++) {
+        height = in->height;
+        if (i == 1 || i == 2) {
+            height = AV_CEIL_RSHIFT(height, desc->log2_chroma_h);
+        }
+        cp_size = in->linesize[i] * height;
+        if (totol_size + cp_size > input_mem->size) {
+            av_log(NULL, AV_LOG_ERROR, "convert_memcpy_host2device input_mem has no enough space\n");
+            return FAILURE;
+        }
+        memcpy(input_mem->vir_addr + totol_size, in->data[i], cp_size);
+        totol_size += cp_size;
+    }
+#ifndef MODEL_SIMULATION
+    es_dma_sync_end(input_mem->dma_buf);
+#endif
+
+    return SUCCESS;
+}
+
+static int convert_allocate_input_mem(ConvertContext *s, MemoryInfo *input_mem) {
+    if (!input_mem) {
+        av_log(NULL, AV_LOG_ERROR, "input_mem is invalid\n");
+        return FAILURE;
+    }
+
+    if (input_mem->vir_addr) {
+        return SUCCESS;
+    }
+
+    if (vf_is_simulation()) {
+        if (input_mem->size > 0) {
+            input_mem->vir_addr = av_malloc(FFALIGN(input_mem->size, s->stride_align));
+            if (!input_mem->vir_addr) {
+                av_log(NULL, AV_LOG_ERROR, "allocate mem failed\n");
+                return FAILURE;
+            }
+            input_mem->fd = (int64_t)input_mem->vir_addr;
+        } else {
+            av_log(NULL, AV_LOG_ERROR, "invaild mem size: %d0\n", input_mem->size);
+            return FAILURE;
+        }
+    } else {
+#ifndef MODEL_SIMULATION
+        input_mem->dma_buf = es_dma_alloc(DMA_TYPE_SYS, FFALIGN(input_mem->size, s->stride_align), UNCACHED_BUF, 0);
+        if (!input_mem->dma_buf) {
+            av_log(NULL, AV_LOG_ERROR, "allocate input_mem dma_buf failed\n");
+            return FAILURE;
+        }
+        es_dma_map(input_mem->dma_buf, UNCACHED_BUF);
+        input_mem->fd = input_mem->dma_buf->dmabuf_fd;
+        input_mem->vir_addr = input_mem->dma_buf->vir_addr;
+#endif
+    }
+
+    return SUCCESS;
+}
+
+static int convert_get_frame_data_size(ConvertContext *s, AVFrame *in) {
+    AVPixFmtDescriptor *desc;
+    int height = 0;
+    int total_size = 0;
+
+    if (!in) {
+        av_log(NULL, AV_LOG_ERROR, "convert_get_frame_data_size invaild paras, in: %p\n", in);
+        return FAILURE;
+    }
+
+    desc = av_pix_fmt_desc_get(s->in_fmt);
+    if (!desc) {
+        av_log(NULL,
+               AV_LOG_ERROR,
+               "convert_get_frame_data_size get fmt: %s AVPixFmtDescriptor failed.\n",
+               av_get_pix_fmt_name(s->out_fmt));
+        return FAILURE;
+    }
+
+    for (int i = 0; i < FF_ARRAY_ELEMS(in->data) && in->data[i]; i++) {
+        height = in->height;
+        if (i == 1 || i == 2) {
+            height = AV_CEIL_RSHIFT(height, desc->log2_chroma_h);
+        }
+        total_size += in->linesize[i] * height;
+    }
+
+    return total_size;
+}
+
+#ifndef MODEL_SIMULATION
+static int convert_init_input_mem_from_fd(MemoryInfo *input_mem) {
+    es_dma_buf *dma_buf = NULL;
+
+    if (!input_mem) {
+        av_log(NULL, AV_LOG_ERROR, "convert_init_input_mem_from_fd invalid paras\n");
+        return FAILURE;
+    }
+
+    if (input_mem->dma_buf) {
+        dma_buf = input_mem->dma_buf;
+        es_dma_unwrap(dma_buf);
+        dma_buf = NULL;
+    }
+
+    dma_buf = es_dma_wrap(input_mem->fd, input_mem->vir_addr, input_mem->size);
+    if (!dma_buf) {
+        av_log(NULL, AV_LOG_ERROR, "convert_init_input_mem_from_fd es_dma_wrap failed\n");
+        return FAILURE;
+    }
+    // input_mem->need_map = !(input_mem->vir_addr);
+    // av_log(NULL, AV_LOG_ERROR,
+    //             "input_mem->vir_addr: %p,  dma_buf->vir_addr: %p, need_map:%d\n",
+    //             input_mem->vir_addr, dma_buf->vir_addr, input_mem->need_map);
+    // if (input_mem->need_map) {
+    //     es_dma_map(dma_buf);
+    //     input_mem->dma_buf = dma_buf;
+    //     input_mem->vir_addr = dma_buf->vir_addr;
+    // }
+
+    es_dma_map(dma_buf, UNCACHED_BUF);
+    input_mem->dma_buf = dma_buf;
+    input_mem->vir_addr = dma_buf->vir_addr;
+
+    return SUCCESS;
+}
+
+static int convert_init_input_mem_from_fd_copy(ConvertContext *s, AVFrame *in, int64_t fd) {
+    es_dma_buf *dma_buf = NULL;
+    es_dma_buf *src_dma_buf = NULL;
+    size_t dma_buf_size = 0;
+    int ret = SUCCESS;
+
+    if (!s) {
+        av_log(NULL, AV_LOG_ERROR, "convert_init_input_mem_from_fd invalid paras\n");
+        return FAILURE;
+    }
+
+    if (!s->input_mem.dma_buf) {
+        dma_buf_size = FFALIGN(s->input_mem.size, s->stride_align);
+        dma_buf = es_dma_alloc(DMA_TYPE_SYS, dma_buf_size, UNCACHED_BUF, 0);
+        if (!dma_buf) {
+            av_log(NULL, AV_LOG_ERROR, "convert_init_input_mem_from_fd_copy allocate dma_buf failed\n");
+            return FAILURE;
+        }
+        av_log(NULL,
+               AV_LOG_INFO,
+               "convert_init_input_mem_from_fd_copy allocate dma_buf size: %ld data size: %d\n",
+               dma_buf->size,
+               s->input_mem.size);
+        es_dma_map(dma_buf, UNCACHED_BUF);
+        s->input_mem.dma_buf = dma_buf;
+        s->input_mem.vir_addr = dma_buf->vir_addr;
+        s->input_mem.fd = dma_buf->dmabuf_fd;
+    }
+
+    src_dma_buf = es_dma_wrap(fd, in->data[0], s->input_mem.size);
+    if (!src_dma_buf) {
+        av_log(NULL, AV_LOG_ERROR, "convert_init_input_mem_from_fd_copy es_dma_wrap failed\n");
+        return FAILURE;
+    }
+
+    es_dma_sync_start(s->input_mem.dma_buf);
+    ret = read_from_es_dma(src_dma_buf, s->input_mem.vir_addr, s->input_mem.size);
+    es_dma_sync_end(s->input_mem.dma_buf);
+    if (ret < 0) {
+        av_log(NULL, AV_LOG_ERROR, "read_from_es_dma failed\n");
+        ret = FAILURE;
+    }
+
+    es_dma_unwrap(src_dma_buf);
+
+    return ret;
+}
+
+#endif
+
+static int convert_filter_frame(AVFilterLink *link, AVFrame *in) {
+    AVFilterContext *ctx = link->dst;
+    ConvertContext *s = (ConvertContext *)ctx->priv;
+    AVFilterLink *outlink = ctx->outputs[0];
+    ESBuffer buffer;
+    ESMemory *memory = NULL;
+    MemoryInfo out_mem;
+    AVFrame *out = NULL;
+    int64_t fd;
+    int ret = SUCCESS;
+
+    out_mem.fd = -1;
+    out_mem.vir_addr = NULL;
+    out_mem.size = 0;
+    out_mem.memory = NULL;
+
+    if (link->format == AV_PIX_FMT_ES && !in->hw_frames_ctx) {
+        av_log(ctx, AV_LOG_ERROR, "Input frames must have hardware context.\n");
+        av_frame_free(&in);
+        return FAILURE;
+    }
+
+    ret = esvf_get_buffer_unitl_timeout(s->port->frame_queue, &buffer, -1);
+    if (ret == FAILURE) {
+        av_log(ctx, AV_LOG_ERROR, "esvf_get_video_buffer failed\n");
+        av_frame_free(&in);
+        return FAILURE;
+    }
+
+    memory = buffer.memory;
+    if (!memory) {
+        av_log(ctx, AV_LOG_ERROR, "memory is invaild\n");
+        av_frame_free(&in);
+        return FAILURE;
+    }
+
+    if (s->input_mem.fd < 0) {
+        s->input_mem.size = convert_get_frame_data_size(s, in);
+    }
+
+    if (link->format == AV_PIX_FMT_ES) {
+        ret = esvf_get_fd(in, &fd);
+        if (ret < 0) {
+            av_log(ctx, AV_LOG_ERROR, "esvf_get_fd faild\n");
+            av_frame_free(&in);
+            return FAILURE;
+        }
+
+        if (vf_is_simulation()) {
+            s->input_mem.fd = fd;
+            s->input_mem.vir_addr = (void *)s->input_mem.fd;
+        } else {
+#ifndef MODEL_SIMULATION
+            // s->input_mem.fd = fd;
+            // s->input_mem.vir_addr = in->data[0];
+            // ret = convert_init_input_mem_from_fd(&s->input_mem);
+            ret = convert_init_input_mem_from_fd_copy(s, in, fd);
+            if (ret < 0) {
+                av_log(ctx, AV_LOG_ERROR, "convert_init_input_mem_from_fd_copy faild\n");
+                av_frame_free(&in);
+                return FAILURE;
+            }
+#endif
+        }
+    } else {
+        ret = convert_allocate_input_mem(s, &s->input_mem);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "convert_allocate_input_mem failed\n");
+            esvf_buffer_consume((void *)s->port, (void *)memory);
+            av_frame_free(&in);
+            return FAILURE;
+        }
+
+        ret = convert_memcpy_host2device(s, in, &s->input_mem);
+        if (ret < 0) {
+            av_log(ctx, AV_LOG_ERROR, "convert_memcpy_host2device faild\n");
+            esvf_buffer_consume((void *)s->port, (void *)memory);
+            av_frame_free(&in);
+            return FAILURE;
+        }
+    }
+
+    out_mem.fd = memory->fd;
+    out_mem.vir_addr = memory->vir_addr;
+    out_mem.size = memory->size;
+    out_mem.memory = memory;
+#ifndef MODEL_SIMULATION
+    out_mem.dma_buf = memory->dma_buf;
+#endif
+
+    if (s->fp_input) {
+        vf_dump_bytes_to_file(s->input_mem.vir_addr, s->input_mem.size, s->fp_input);
+    }
+
+    if (vf_is_simulation()) {
+        /*todo convert, test code*/
+        memcpy(out_mem.vir_addr,
+               s->input_mem.vir_addr,
+               s->port->mem_info->size < s->input_mem.size ? s->port->mem_info->size : s->input_mem.size);
+    } else {
+#ifndef MODEL_SIMULATION
+        VF2DSurface input_paras;
+        VF2DSurface output_paras;
+        VF2DRect input_rect;
+        VF2DRect output_rect;
+        VF2DNormalizationParams normalization_paras;
+
+        av_log(ctx, AV_LOG_DEBUG, "2D input memory: %p, size: %ld\n", s->input_mem.dma_buf, s->input_mem.dma_buf->size);
+
+        av_log(ctx, AV_LOG_DEBUG, "2D output memory: %p, size: %ld\n", out_mem.dma_buf, out_mem.dma_buf->size);
+
+#if 0
+        // read test file to input mem for umd test
+        FILE *fp = fopen("ILSVRC2012_val_00000043_224x224x3_R8G8B8_0317.raw", "rb+");
+        if(fp == NULL){
+            av_log(ctx, AV_LOG_ERROR, "test fopen faild\n");
+        }
+        av_log(ctx, AV_LOG_INFO, "vir_addr:%p, size:%d\n",s->input_mem.vir_addr, s->input_mem.size);
+        es_dma_sync_start(s->input_mem.dma_buf);
+        fread(s->input_mem.vir_addr, s->input_mem.size, 1, fp);
+        fflush(fp);
+        fclose(fp);
+        es_dma_sync_end(s->input_mem.dma_buf);
+#endif
+
+        input_paras.height = s->src_video_rect.height;
+        input_paras.width = FFALIGN(s->src_video_rect.width, s->stride_align);
+        input_paras.pixfmt = s->in_fmt;
+        input_paras.dma_buf = s->input_mem.dma_buf;
+        input_paras.offset = 0;
+
+        input_rect.left = s->crop_info.crop_xoffset;
+        input_rect.top = s->crop_info.crop_yoffset;
+        input_rect.bottom = s->crop_info.crop_yoffset + s->crop_info.crop_height;
+        input_rect.right = s->crop_info.crop_xoffset + s->crop_info.crop_width;
+
+        output_paras.height = s->dst_video_rect.height;
+        output_paras.width = FFALIGN(s->dst_video_rect.width, s->stride_align);
+        output_paras.pixfmt = s->out_fmt;
+        output_paras.dma_buf = out_mem.dma_buf;
+        output_paras.offset = 0;
+
+        output_rect.left = 0;
+        output_rect.top = 0;
+        output_rect.bottom = s->scale_info.scale_height;
+        output_rect.right = s->scale_info.scale_width;
+
+        if (s->is_normalization) {
+            normalization_paras.normalizationMode = s->normalization_mode;
+            // for min-max
+            normalization_paras.minValue.R = s->min_value.R;
+            normalization_paras.minValue.G = s->min_value.G;
+            normalization_paras.minValue.B = s->min_value.B;
+            normalization_paras.maxMinReciprocal.R = s->max_min_reciprocal.R;
+            normalization_paras.maxMinReciprocal.G = s->max_min_reciprocal.G;
+            normalization_paras.maxMinReciprocal.B = s->max_min_reciprocal.B;
+            // for z-score
+            normalization_paras.meanValue.R = s->mean_value.R;
+            normalization_paras.meanValue.G = s->mean_value.G;
+            normalization_paras.meanValue.B = s->mean_value.B;
+            normalization_paras.stdReciprocal.R = s->std_reciprocal.R;
+            normalization_paras.stdReciprocal.G = s->std_reciprocal.G;
+            normalization_paras.stdReciprocal.B = s->std_reciprocal.B;
+            // for stepReciprocal
+            normalization_paras.stepReciprocal = s->step_r;
+        }
+
+        ret = vf_2D_work(&s->id,
+                         &input_paras,
+                         &output_paras,
+                         s->is_normalization ? &normalization_paras : NULL,
+                         &input_rect,
+                         &output_rect);
+        if (ret < 0) {
+            av_log(ctx, AV_LOG_ERROR, "vf_2D_work error\n");
+            esvf_buffer_consume((void *)s->port, (void *)memory);
+            av_frame_free(&in);
+            return FAILURE;
+        }
+#endif
+    }
+
+    if (s->fp_output) {
+        vf_dump_bytes_to_file(out_mem.vir_addr, s->port->mem_info->size, s->fp_output);
+    }
+
+    out = convert_allocate_and_fill_output_frame(link, in, &out_mem);
+    if (!out) {
+        av_log(ctx, AV_LOG_ERROR, "convert_allocate_and_fill_output_frame failed\n");
+        esvf_buffer_consume((void *)s->port, (void *)memory);
+        av_frame_free(&in);
+        return FAILURE;
+    }
+
+    if (link->format == AV_PIX_FMT_ES) {
+        if (vf_is_simulation()) {
+            s->input_mem.fd = -1;
+            s->input_mem.vir_addr = NULL;
+            s->input_mem.size = 0;
+        }
+#ifndef MODEL_SIMULATION
+        // if (s->input_mem.need_map) {
+        //     es_dma_unmap(s->input_mem.dma_buf);
+        // }
+        // es_dma_unwrap(s->input_mem.dma_buf);
+        // s->input_mem.dma_buf = NULL;
+#endif
+    } else {
+        esvf_buffer_consume((void *)s->port, (void *)memory);
+    }
+
+    av_frame_free(&in);
+    return ff_filter_frame(outlink, out);
+}
+
+#define OFFSET(x) offsetof(ConvertContext, x)
+#define FLAGS (AV_OPT_FLAG_FILTERING_PARAM | AV_OPT_FLAG_VIDEO_PARAM)
+static const AVOption options[] = {
+    {"stride_align", "set buffer stride", OFFSET(stride_align), AV_OPT_TYPE_INT, {.i64 = 64}, 0, 2048, FLAGS},
+    {"scale", "widthxheight", OFFSET(scale_set), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, FLAGS},
+    {"crop",
+     "crop(xoffset)x(yoffset))x(width)x(height)",
+     OFFSET(crop_set),
+     AV_OPT_TYPE_STRING,
+     {.str = NULL},
+     0,
+     0,
+     FLAGS},
+    {"o_fmt", "output pixfmt", OFFSET(enter_out_fmt), AV_OPT_TYPE_INT, {.i64 = -1}, -1, INT_MAX, FLAGS, "fmt"},
+    {"nv12", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_NV12}, 0, INT_MAX, FLAGS, "fmt"},
+    {"nv21", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_NV21}, 0, INT_MAX, FLAGS, "fmt"},
+    {"yuv420p", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_YUV420P}, 0, INT_MAX, FLAGS, "fmt"},
+    {"gray", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_GRAY8}, 0, INT_MAX, FLAGS, "fmt"},
+    {"gray32f", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_GRAYF32LE}, 0, INT_MAX, FLAGS, "fmt"},
+    {"yuv420p10le", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_YUV420P10LE}, 0, INT_MAX, FLAGS, "fmt"},
+    {"p010le", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_P010LE}, 0, INT_MAX, FLAGS, "fmt"},
+    {"yvyu422", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_YVYU422}, 0, INT_MAX, FLAGS, "fmt"},
+    {"yuyv422", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_YUYV422}, 0, INT_MAX, FLAGS, "fmt"},
+    {"uyvy422", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_UYVY422}, 0, INT_MAX, FLAGS, "fmt"},
+    {"nv16", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_NV16}, 0, INT_MAX, FLAGS, "fmt"},
+    {"rgb24", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_RGB24}, 0, INT_MAX, FLAGS, "fmt"},
+    {"bgr24", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_BGR24}, 0, INT_MAX, FLAGS, "fmt"},
+    {"argb", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_ARGB}, 0, INT_MAX, FLAGS, "fmt"},
+    {"abgr", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_ABGR}, 0, INT_MAX, FLAGS, "fmt"},
+    {"bgra", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_BGRA}, 0, INT_MAX, FLAGS, "fmt"},
+    {"rgba", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_RGBA}, 0, INT_MAX, FLAGS, "fmt"},
+    {"b16g16r16i", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_B16G16R16I}, 0, INT_MAX, FLAGS, "fmt"},
+    {"b16g16r16i_p",
+     "output pixfmt",
+     0,
+     AV_OPT_TYPE_CONST,
+     {.i64 = AV_PIX_FMT_B16G16R16I_PLANAR},
+     0,
+     INT_MAX,
+     FLAGS,
+     "fmt"},
+    {"bgr24_p", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_B8G8R8_PLANAR}, 0, INT_MAX, FLAGS, "fmt"},
+    {"bgr24i", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_B8G8R8I}, 0, INT_MAX, FLAGS, "fmt"},
+    {"bgr24i_p", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_B8G8R8I_PLANAR}, 0, INT_MAX, FLAGS, "fmt"},
+    {"b16g16r16f", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_B16G16R16F}, 0, INT_MAX, FLAGS, "fmt"},
+    {"b16g16r16f_p",
+     "output pixfmt",
+     0,
+     AV_OPT_TYPE_CONST,
+     {.i64 = AV_PIX_FMT_B16G16R16F_PLANAR},
+     0,
+     INT_MAX,
+     FLAGS,
+     "fmt"},
+    {"b32g32r32f", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = AV_PIX_FMT_B32G32R32F}, 0, INT_MAX, FLAGS, "fmt"},
+    {"b32g32r32f_p",
+     "output pixfmt",
+     0,
+     AV_OPT_TYPE_CONST,
+     {.i64 = AV_PIX_FMT_B32G32R32F_PLANAR},
+     0,
+     INT_MAX,
+     FLAGS,
+     "fmt"},
+    {"n_mode",
+     "set normalization mode",
+     OFFSET(normalization_mode),
+     AV_OPT_TYPE_INT,
+     {.i64 = -1},
+     -1,
+     INT_MAX,
+     FLAGS,
+     "n_mode"},
+    {"min_max", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = 0}, 0, INT_MAX, FLAGS, "n_mode"},
+    {"z_score", "output pixfmt", 0, AV_OPT_TYPE_CONST, {.i64 = 1}, 0, INT_MAX, FLAGS, "n_mode"},
+    {"mm_r",
+     "set normalization maxMinReciprocal, such as:R/G/B",
+     OFFSET(mm_r),
+     AV_OPT_TYPE_STRING,
+     {.str = NULL},
+     0,
+     0,
+     FLAGS},
+    {"min", "set normalization minValue, such as:R/G/B", OFFSET(min), AV_OPT_TYPE_STRING, {.str = NULL}, 0, 0, FLAGS},
+    {"mean",
+     "set normalization meanValue, such as:R/G/B",
+     OFFSET(mean),
+     AV_OPT_TYPE_STRING,
+     {.str = NULL},
+     0,
+     0,
+     FLAGS},
+    {"std_r",
+     "set normalization stdReciprocal, such as:R/G/B",
+     OFFSET(std_r),
+     AV_OPT_TYPE_STRING,
+     {.str = NULL},
+     0,
+     0,
+     FLAGS},
+    {"step_r", "set normalization stepReciprocal", OFFSET(step_r), AV_OPT_TYPE_INT, {.i64 = 0}, 0, INT_MAX, FLAGS},
+    {"dump_path",
+     "set file path to dump 2D input data and output data",
+     OFFSET(dump_path),
+     AV_OPT_TYPE_STRING,
+     {.i64 = NULL},
+     0,
+     0,
+     FLAGS},
+    {NULL}};
+
+static const AVClass convert_class = {
+    .class_name = "convert",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+static const AVFilterPad convert_inputs[] = {
+    {
+        .name = "default",
+        .type = AVMEDIA_TYPE_VIDEO,
+        .filter_frame = convert_filter_frame,
+    },
+};
+
+static const AVFilterPad convert_outputs[] = {
+    {
+        .name = "default",
+        .type = AVMEDIA_TYPE_VIDEO,
+        .config_props = convert_config_props,
+    },
+};
+
+AVFilter ff_vf_convert_es = {
+    .name = "convert_es",
+    .description = NULL_IF_CONFIG_SMALL("es 2D convert"),
+
+    .init = init,
+    .uninit = uninit,
+
+    .priv_size = sizeof(ConvertContext),
+    .priv_class = &convert_class,
+
+    FILTER_INPUTS(convert_inputs),
+    FILTER_OUTPUTS(convert_outputs),
+    FILTER_QUERY_FUNC(query_formats),
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+};
diff --git a/libavfilter/vf_derain.c b/libavfilter/vf_derain.c
index 86e9eb8752..010258cb32 100644
--- a/libavfilter/vf_derain.c
+++ b/libavfilter/vf_derain.c
@@ -47,6 +47,9 @@ static const AVOption derain_options[] = {
     { "native",      "native backend flag",         0,                      AV_OPT_TYPE_CONST,  { .i64 = 0 },    0, 0, FLAGS, "backend" },
 #if (CONFIG_LIBTENSORFLOW == 1)
     { "tensorflow",  "tensorflow backend flag",     0,                      AV_OPT_TYPE_CONST,  { .i64 = 1 },    0, 0, FLAGS, "backend" },
+#endif
+#if (CONFIG_ESUMD == 1)
+    { "umd",         "umd backend flag",            0,                      AV_OPT_TYPE_CONST,  { .i64 = 3 },    0, 0, FLAGS, "backend" },
 #endif
     { "model",       "path to model file",          OFFSET(dnnctx.model_filename),   AV_OPT_TYPE_STRING,    { .str = NULL }, 0, 0, FLAGS },
     { "input",       "input name of the model",     OFFSET(dnnctx.model_inputname),  AV_OPT_TYPE_STRING,    { .str = "x" },  0, 0, FLAGS },
diff --git a/libavfilter/vf_dnn_classify.c b/libavfilter/vf_dnn_classify.c
index 852f5ddcee..ab46664027 100644
--- a/libavfilter/vf_dnn_classify.c
+++ b/libavfilter/vf_dnn_classify.c
@@ -51,6 +51,9 @@ static const AVOption dnn_classify_options[] = {
     { "dnn_backend", "DNN backend",                OFFSET(backend_type),     AV_OPT_TYPE_INT,       { .i64 = 2 },    INT_MIN, INT_MAX, FLAGS, "backend" },
 #if (CONFIG_LIBOPENVINO == 1)
     { "openvino",    "openvino backend flag",      0,                        AV_OPT_TYPE_CONST,     { .i64 = 2 },    0, 0, FLAGS, "backend" },
+#endif
+#if (CONFIG_ESUMD == 1)
+    { "umd",         "umd backend flag",           0,                        AV_OPT_TYPE_CONST,     { .i64 = 3 },    0, 0, FLAGS, "backend" },
 #endif
     DNN_COMMON_OPTIONS
     { "confidence",  "threshold of confidence",    OFFSET2(confidence),      AV_OPT_TYPE_FLOAT,     { .dbl = 0.5 },  0, 1, FLAGS},
diff --git a/libavfilter/vf_dnn_detect.c b/libavfilter/vf_dnn_detect.c
index 68bd2cd0c3..d75186b106 100644
--- a/libavfilter/vf_dnn_detect.c
+++ b/libavfilter/vf_dnn_detect.c
@@ -53,6 +53,9 @@ static const AVOption dnn_detect_options[] = {
 #endif
 #if (CONFIG_LIBOPENVINO == 1)
     { "openvino",    "openvino backend flag",      0,                        AV_OPT_TYPE_CONST,     { .i64 = 2 },    0, 0, FLAGS, "backend" },
+#endif
+#if (CONFIG_ESUMD == 1)
+    { "umd",         "umd backend flag",           0,                        AV_OPT_TYPE_CONST,     { .i64 = 3 },    0, 0, FLAGS, "backend" },
 #endif
     DNN_COMMON_OPTIONS
     { "confidence",  "threshold of confidence",    OFFSET2(confidence),      AV_OPT_TYPE_FLOAT,     { .dbl = 0.5 },  0, 1, FLAGS},
diff --git a/libavfilter/vf_dnn_processing.c b/libavfilter/vf_dnn_processing.c
index cac096a19f..6e98c64d5a 100644
--- a/libavfilter/vf_dnn_processing.c
+++ b/libavfilter/vf_dnn_processing.c
@@ -34,12 +34,16 @@
 #include "internal.h"
 #include "libswscale/swscale.h"
 #include "libavutil/time.h"
+#include "libavutil/hwcontext.h"
 
 typedef struct DnnProcessingContext {
     const AVClass *class;
     DnnContext dnnctx;
     struct SwsContext *sws_uv_scale;
     int sws_uv_height;
+
+    AVBufferRef *hwdevice;
+    AVBufferRef *hwframe;
 } DnnProcessingContext;
 
 #define OFFSET(x) offsetof(DnnProcessingContext, dnnctx.x)
@@ -52,6 +56,9 @@ static const AVOption dnn_processing_options[] = {
 #endif
 #if (CONFIG_LIBOPENVINO == 1)
     { "openvino",    "openvino backend flag",      0,                        AV_OPT_TYPE_CONST,     { .i64 = 2 },    0, 0, FLAGS, "backend" },
+#endif
+#if (CONFIG_ESUMD == 1)
+    { "umd",         "umd backend flag",           0,                        AV_OPT_TYPE_CONST,     { .i64 = 3 },    0, 0, FLAGS, "backend" },
 #endif
     DNN_COMMON_OPTIONS
     { NULL }
@@ -71,6 +78,9 @@ static const enum AVPixelFormat pix_fmts[] = {
     AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P,
     AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUV411P,
     AV_PIX_FMT_NV12,
+#if (CONFIG_ESUMD == 1)
+    AV_PIX_FMT_ES, AV_PIX_FMT_B8G8R8I_PLANAR,
+#endif
     AV_PIX_FMT_NONE
 };
 
@@ -102,6 +112,19 @@ static int check_modelinput_inlink(const DNNData *model_input, const AVFilterLin
         return AVERROR(EIO);
     }
 
+#if (CONFIG_ESUMD == 1)
+    if(inlink->hw_frames_ctx && fmt == AV_PIX_FMT_ES){
+        AVHWFramesContext *in_hw_frames_ctx  = NULL;
+        in_hw_frames_ctx = (AVHWFramesContext*)inlink->hw_frames_ctx->data;
+        av_log(ctx, AV_LOG_INFO, "now is ES hwaccel mode. fmt:%s\n",av_get_pix_fmt_name(in_hw_frames_ctx->sw_format));
+        return 0;
+    }
+    if(AV_PIX_FMT_B8G8R8I_PLANAR == fmt){
+        av_log(ctx, AV_LOG_INFO, "now is ES NO-hwaccel mode.\n");
+        return 0;
+    }
+#endif
+
     switch (fmt) {
     case AV_PIX_FMT_RGB24:
     case AV_PIX_FMT_BGR24:
@@ -190,6 +213,42 @@ static int prepare_uv_scale(AVFilterLink *outlink)
     return 0;
 }
 
+#if (CONFIG_ESUMD == 1)
+static int umd_hw_config_output(DnnProcessingContext *s, AVFilterLink *outlink)
+{
+    AVFilterContext *ctx = outlink->src;
+    AVFilterLink *inlink = ctx->inputs[0];
+
+    AVHWFramesContext *hwframe_ctx;
+    int ret;
+
+    av_log(ctx, AV_LOG_INFO, "%d umd_hw_config_output in\n",__LINE__);
+    av_buffer_unref(&s->hwframe);
+    s->hwframe = av_hwframe_ctx_alloc(s->hwdevice);
+    if (!s->hwframe)
+        return AVERROR(ENOMEM);
+
+    hwframe_ctx            = (AVHWFramesContext*)s->hwframe->data;
+    hwframe_ctx->format    = AV_PIX_FMT_ES;
+    if (inlink->hw_frames_ctx) {
+        AVHWFramesContext *in_hwframe_ctx = (AVHWFramesContext*)inlink->hw_frames_ctx->data;
+        hwframe_ctx->sw_format = in_hwframe_ctx->sw_format;
+    } else {
+        hwframe_ctx->sw_format = inlink->format;
+    }
+    hwframe_ctx->width     = inlink->w;
+    hwframe_ctx->height    = inlink->h;
+
+    ret = av_hwframe_ctx_init(s->hwframe);
+    if (ret < 0)
+        return ret;
+    outlink->hw_frames_ctx = av_buffer_ref(s->hwframe);
+    if (!outlink->hw_frames_ctx)
+        return AVERROR(ENOMEM);
+    return 0;
+}
+#endif
+
 static int config_output(AVFilterLink *outlink)
 {
     AVFilterContext *context = outlink->src;
@@ -204,6 +263,14 @@ static int config_output(AVFilterLink *outlink)
         return result;
     }
 
+#if (CONFIG_ESUMD == 1)
+    AVHWFramesContext *in_frames_ctx = inlink->hw_frames_ctx->data;
+    ctx->hwdevice = in_frames_ctx->device_ref;
+    if(umd_hw_config_output(ctx, outlink) != 0){
+        av_log(ctx, AV_LOG_ERROR, "failed to umd_hw_config_output\n");
+    }
+#endif
+
     prepare_uv_scale(outlink);
 
     return 0;
@@ -340,6 +407,8 @@ static av_cold void uninit(AVFilterContext *ctx)
 {
     DnnProcessingContext *context = ctx->priv;
 
+    av_buffer_unref(&context->hwframe);
+
     sws_freeContext(context->sws_uv_scale);
     ff_dnn_uninit(&context->dnnctx);
 }
@@ -371,4 +440,5 @@ const AVFilter ff_vf_dnn_processing = {
     FILTER_PIXFMTS_ARRAY(pix_fmts),
     .priv_class    = &dnn_processing_class,
     .activate      = activate,
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
 };
diff --git a/libavformat/aviobuf.c b/libavformat/aviobuf.c
index b20b1a611a..61125f1114 100644
--- a/libavformat/aviobuf.c
+++ b/libavformat/aviobuf.c
@@ -531,6 +531,12 @@ static int read_packet_wrapper(AVIOContext *s, uint8_t *buf, int size)
     if (!s->read_packet)
         return AVERROR(EINVAL);
     ret = s->read_packet(s->opaque, buf, size);
+#if ESW_FF_ENHANCEMENT
+    if (!ret && !s->max_packet_size) {
+        av_log(NULL, AV_LOG_WARNING, "Invalid return value 0 for stream protocol\n");
+        ret = AVERROR_EOF;
+    }
+#endif
     av_assert2(ret || s->max_packet_size);
     return ret;
 }
diff --git a/libavutil/Makefile b/libavutil/Makefile
index 9435a0bfb0..f6474f104f 100644
--- a/libavutil/Makefile
+++ b/libavutil/Makefile
@@ -49,6 +49,7 @@ HEADERS = adler32.h                                                     \
           hwcontext_videotoolbox.h                                      \
           hwcontext_vdpau.h                                             \
           hwcontext_vulkan.h                                            \
+          hwcontext_es.h                                                \
           imgutils.h                                                    \
           intfloat.h                                                    \
           intreadwrite.h                                                \
@@ -195,6 +196,9 @@ OBJS-$(CONFIG_VAAPI)                    += hwcontext_vaapi.o
 OBJS-$(CONFIG_VIDEOTOOLBOX)             += hwcontext_videotoolbox.o
 OBJS-$(CONFIG_VDPAU)                    += hwcontext_vdpau.o
 OBJS-$(CONFIG_VULKAN)                   += hwcontext_vulkan.o
+#ifdef ESW_FF_ENHANCEMENT
+OBJS-$(CONFIG_ES_CODEC)                 += hwcontext_es.o
+#endif
 
 OBJS-$(!CONFIG_VULKAN)                  += hwcontext_stub.o
 
@@ -214,6 +218,7 @@ SKIPHEADERS-$(CONFIG_OPENCL)           += hwcontext_opencl.h
 SKIPHEADERS-$(CONFIG_VAAPI)            += hwcontext_vaapi.h
 SKIPHEADERS-$(CONFIG_VIDEOTOOLBOX)     += hwcontext_videotoolbox.h
 SKIPHEADERS-$(CONFIG_VDPAU)            += hwcontext_vdpau.h
+SKIPHEADERS-$(CONFIG_ES_CODEC)         += hwcontext_es.h
 SKIPHEADERS-$(CONFIG_VULKAN)           += hwcontext_vulkan.h vulkan.h   \
                                           vulkan_functions.h            \
                                           vulkan_loader.h
diff --git a/libavutil/hwcontext.c b/libavutil/hwcontext.c
index ab9ad3703e..8d7a62f5cd 100644
--- a/libavutil/hwcontext.c
+++ b/libavutil/hwcontext.c
@@ -62,6 +62,9 @@ static const HWContextType * const hw_table[] = {
 #endif
 #if CONFIG_VULKAN
     &ff_hwcontext_type_vulkan,
+#endif
+#if CONFIG_ES_CODEC
+    &ff_hwcontext_type_es,
 #endif
     NULL,
 };
@@ -78,6 +81,7 @@ static const char *const hw_type_names[] = {
     [AV_HWDEVICE_TYPE_VIDEOTOOLBOX] = "videotoolbox",
     [AV_HWDEVICE_TYPE_MEDIACODEC] = "mediacodec",
     [AV_HWDEVICE_TYPE_VULKAN] = "vulkan",
+    [AV_HWDEVICE_TYPE_ES]    = "es",
 };
 
 enum AVHWDeviceType av_hwdevice_find_type_by_name(const char *name)
diff --git a/libavutil/hwcontext.h b/libavutil/hwcontext.h
index c18b7e1e8b..d2424d7e09 100644
--- a/libavutil/hwcontext.h
+++ b/libavutil/hwcontext.h
@@ -37,6 +37,7 @@ enum AVHWDeviceType {
     AV_HWDEVICE_TYPE_OPENCL,
     AV_HWDEVICE_TYPE_MEDIACODEC,
     AV_HWDEVICE_TYPE_VULKAN,
+    AV_HWDEVICE_TYPE_ES,
 };
 
 typedef struct AVHWDeviceInternal AVHWDeviceInternal;
diff --git a/libavutil/hwcontext_es.c b/libavutil/hwcontext_es.c
new file mode 100644
index 0000000000..42ab254139
--- /dev/null
+++ b/libavutil/hwcontext_es.c
@@ -0,0 +1,299 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include "buffer.h"
+#include "common.h"
+#include "hwcontext.h"
+#include "hwcontext_internal.h"
+#include "hwcontext_es.h"
+#include "pixfmt.h"
+#include "pixdesc.h"
+#include "imgutils.h"
+
+#define ES_FRAME_ALIGNMENT 1
+
+struct DWLLinearMem;
+
+static const enum AVPixelFormat supported_formats[] = {
+    AV_PIX_FMT_YUV420P,
+    AV_PIX_FMT_NV12,
+    AV_PIX_FMT_NV21,
+    AV_PIX_FMT_GRAY8,
+    AV_PIX_FMT_P010,
+    AV_PIX_FMT_RGB24,
+    AV_PIX_FMT_BGR24,
+    AV_PIX_FMT_ARGB,
+    AV_PIX_FMT_ABGR,
+    AV_PIX_FMT_0RGB,
+    AV_PIX_FMT_0BGR,
+#ifdef ESW_FF_ENHANCEMENT
+    AV_PIX_FMT_B16G16R16I,
+    AV_PIX_FMT_B16G16R16I_PLANAR,
+    AV_PIX_FMT_B8G8R8_PLANAR,
+    AV_PIX_FMT_B8G8R8I,
+    AV_PIX_FMT_B8G8R8I_PLANAR,
+    AV_PIX_FMT_B16G16R16F,
+    AV_PIX_FMT_B16G16R16F_PLANAR,
+    AV_PIX_FMT_B32G32R32F,
+    AV_PIX_FMT_B32G32R32F_PLANAR,
+#endif
+};
+
+typedef struct {
+    int shift_width;
+    int shift_height;
+} ESFramesContext;
+
+static void es_memcpy_block(void *src, void *dst, size_t data_size) {
+    memcpy(dst, src, data_size);
+}
+
+static int es_memcpy_by_line(uint8_t *src, uint8_t *dst, int src_linesize, int dst_linesize, int linecount) {
+    int copy_size;
+    if (!src || !dst) {
+        return AVERROR(EINVAL);
+    }
+
+    copy_size = FFMIN(src_linesize, dst_linesize);
+    for (int i = 0; i < linecount; i++) {
+        memcpy(dst + i * dst_linesize, src + i * src_linesize, copy_size);
+    }
+
+    return 0;
+}
+
+static int es_frames_get_constraints(AVHWDeviceContext *device_ctx,
+                                      const void *hwconfig,
+                                      AVHWFramesConstraints *constraints) {
+    av_log(device_ctx, AV_LOG_TRACE, "%s(%d)\n", __FUNCTION__, __LINE__);
+
+    constraints->valid_sw_formats =
+        av_malloc_array(FF_ARRAY_ELEMS(supported_formats) + 1, sizeof(*constraints->valid_sw_formats));
+    if (!constraints->valid_sw_formats) {
+        return AVERROR(ENOMEM);
+    }
+
+    for (int i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++) {
+        constraints->valid_sw_formats[i] = supported_formats[i];
+    }
+    constraints->valid_sw_formats[FF_ARRAY_ELEMS(supported_formats)] = AV_PIX_FMT_NONE;
+
+    constraints->valid_hw_formats = av_malloc_array(2, sizeof(*constraints->valid_hw_formats));
+    if (!constraints->valid_hw_formats) {
+        return AVERROR(ENOMEM);
+    }
+
+    constraints->valid_hw_formats[0] = AV_PIX_FMT_ES;
+    constraints->valid_hw_formats[1] = AV_PIX_FMT_NONE;
+
+    return 0;
+}
+
+static void es_memory_free(void *opaque, uint8_t *data) {
+    AVHWFramesContext *ctx = opaque;
+    AVHWDeviceContext *device_ctx = ctx->device_ctx;
+    AVVSVDeviceContext *hwctx = device_ctx->hwctx;
+    const void *dwl_inst = hwctx->dwl_inst;
+
+#ifndef ESW_FF_ENHANCEMENT
+    if (data) {
+        DWLFreeLinear(dwl_inst, (struct DWLLinearMem *)data);
+        av_free(data);
+    }
+#endif
+}
+
+static AVBufferRef *es_pool_alloc(void *opaque, int size) {
+    AVHWFramesContext *ctx = opaque;
+    AVHWDeviceContext *device_ctx = ctx->device_ctx;
+    AVVSVDeviceContext *hwctx = device_ctx->hwctx;
+    const void *dwl_inst = hwctx->dwl_inst;
+    AVBufferRef *ret = NULL;
+    struct DWLLinearMem *memory = NULL;
+
+#ifndef ESW_FF_ENHANCEMENT
+    memory = av_mallocz(sizeof(*memory));
+    if (!memory) {
+        return NULL;
+    }
+
+    memory->mem_type = DWL_MEM_TYPE_DPB;
+    if (DWLMallocLinear(dwl_inst, size, memory)) {
+        av_free(memory);
+        return NULL;
+    }
+#endif
+    ret = av_buffer_create((uint8_t *)memory, size, es_memory_free, ctx, 0);
+    if (!ret) {
+        es_memory_free(ctx, (uint8_t *)memory);
+        av_log(ctx, AV_LOG_ERROR, "dwl malloc failed: size %d\n", size);
+    }
+
+    return ret;
+}
+
+static int es_frames_init(AVHWFramesContext *hw_frames_ctx) {
+    int i;
+    ESFramesContext *priv = hw_frames_ctx->internal->priv;
+
+    av_log(hw_frames_ctx, AV_LOG_TRACE, "%s\n", __FUNCTION__);
+
+    for (i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++) {
+        if (hw_frames_ctx->sw_format == supported_formats[i]) {
+            break;
+        }
+    }
+    if (i == FF_ARRAY_ELEMS(supported_formats)) {
+        av_log(hw_frames_ctx,
+               AV_LOG_ERROR,
+               "Pixel format '%s' is not supported\n",
+               av_get_pix_fmt_name(hw_frames_ctx->sw_format));
+        return AVERROR(ENOSYS);
+    }
+
+    av_pix_fmt_get_chroma_sub_sample(hw_frames_ctx->sw_format, &priv->shift_width, &priv->shift_height);
+
+    if (!hw_frames_ctx->pool) {
+        int size = av_image_get_buffer_size(
+            hw_frames_ctx->sw_format, hw_frames_ctx->width, hw_frames_ctx->height, ES_FRAME_ALIGNMENT);
+        if (size < 0) {
+            return size;
+        }
+
+        hw_frames_ctx->internal->pool_internal = av_buffer_pool_init2(size, hw_frames_ctx, es_pool_alloc, NULL);
+        if (!hw_frames_ctx->internal->pool_internal) {
+            return AVERROR(ENOMEM);
+        }
+    }
+
+    return 0;
+}
+
+static int es_frames_get_buffer(AVHWFramesContext *hw_frames_ctx, AVFrame *frame) {
+    int res;
+
+    frame->buf[0] = av_buffer_pool_get(hw_frames_ctx->pool);
+    if (!frame->buf[0]) {
+        return AVERROR(ENOMEM);
+    }
+
+    res = av_image_fill_arrays(frame->data,
+                               frame->linesize,
+                               frame->buf[0]->data,
+                               hw_frames_ctx->sw_format,
+                               hw_frames_ctx->width,
+                               hw_frames_ctx->height,
+                               ES_FRAME_ALIGNMENT);
+    if (res < 0) {
+        return res;
+    }
+
+    frame->format = AV_PIX_FMT_ES;
+    frame->width = hw_frames_ctx->width;
+    frame->height = hw_frames_ctx->height;
+    return 0;
+}
+
+static int es_transfer_get_formats(AVHWFramesContext *hw_frames_ctx,
+                                    enum AVHWFrameTransferDirection dir,
+                                    enum AVPixelFormat **formats) {
+    enum AVPixelFormat *fmts;
+
+    fmts = av_malloc_array(2, sizeof(*fmts));
+    if (!fmts) return AVERROR(ENOMEM);
+
+    fmts[0] = hw_frames_ctx->sw_format;
+    fmts[1] = AV_PIX_FMT_NONE;
+
+    *formats = fmts;
+    return 0;
+}
+
+static int es_transfer_data_from(AVHWFramesContext *hw_frames_ctx, AVFrame *dst, const AVFrame *src) {
+    int height;
+    if (!src || !dst) {
+        av_log(hw_frames_ctx, AV_LOG_INFO, "es_transfer_data_from failed EINVAL\n");
+        return AVERROR(EINVAL);
+    } else {
+        av_log(hw_frames_ctx, AV_LOG_INFO, "src data[0]: %p\n", src->data[0]);
+    }
+
+    for (int i = 0; i < FF_ARRAY_ELEMS(src->data) && src->data[i]; i++) {
+        height = src->height * (i ? 1.0 / 2 : 1);
+        if (src->linesize[i] == dst->linesize[i]) {
+            es_memcpy_block(src->data[i], dst->data[i], src->linesize[i] * height);
+        } else {
+            es_memcpy_by_line(src->data[i], dst->data[i], src->linesize[i], dst->linesize[i], height);
+        }
+    }
+
+    return 0;
+}
+
+static int es_transfer_data_to(AVHWFramesContext *hw_frames_ctx, AVFrame *dst, const AVFrame *src) {
+    return 0;
+}
+
+static void es_device_uninit(AVHWDeviceContext *device_ctx) {
+}
+
+static int es_device_init(AVHWDeviceContext *device_ctx) {
+    av_log(device_ctx, AV_LOG_INFO, "%s(%d) device_ctx: %p\n", __FUNCTION__, __LINE__, device_ctx);
+
+    return 0;
+}
+
+static int es_device_create(AVHWDeviceContext *device_ctx, const char *device, AVDictionary *opts, int flags) {
+    av_log(device_ctx, AV_LOG_INFO, "%s(%d) hwctx = %p\n", __FUNCTION__, __LINE__, device_ctx);
+
+    if (device) {
+        av_log(device_ctx, AV_LOG_INFO, "device(%s)\n", device);
+    } else {
+        av_log(device_ctx, AV_LOG_WARNING, "device null\n");
+    }
+
+    return 0;
+}
+
+const HWContextType ff_hwcontext_type_es = {
+    .type = AV_HWDEVICE_TYPE_ES,
+    .name = "ES",
+
+    .device_hwctx_size = sizeof(AVVSVDeviceContext),
+    .frames_priv_size = sizeof(AVVSVFramesContext),
+
+    .device_create = es_device_create,
+    .device_init = es_device_init,
+    .device_uninit = es_device_uninit,
+    .frames_get_constraints = es_frames_get_constraints,
+    .frames_init = es_frames_init,
+    .frames_get_buffer = es_frames_get_buffer,
+    .transfer_get_formats = es_transfer_get_formats,
+    .transfer_data_to = es_transfer_data_to,
+    .transfer_data_from = es_transfer_data_from,
+
+    .pix_fmts = (const enum AVPixelFormat[]){AV_PIX_FMT_ES, AV_PIX_FMT_NONE},
+};
diff --git a/libavutil/hwcontext_es.h b/libavutil/hwcontext_es.h
new file mode 100644
index 0000000000..6cc996bf22
--- /dev/null
+++ b/libavutil/hwcontext_es.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright (C) 2019  VeriSilicon
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_HWCONTEXT_VSV_H
+#define AVUTIL_HWCONTEXT_VSV_H
+// #ifndef ESW_FF_ENHANCEMENT
+// #include "dectypes.h"
+// #include "dwl.h"
+// #endif
+/**
+ * VAAPI connection details.
+ *
+ * Allocated as AVHWDeviceContext.hwctx
+ */
+typedef struct AVVSVDeviceContext {
+    char *device;
+    unsigned int dec_client_type;
+    unsigned int enc_client_type;
+
+    int priority;
+    int fbloglevel;
+    int tile_enable;
+    int planar_enable;
+
+    int fd_mem;
+    int task_id;
+
+    int lookahead;
+    int nb_frames;
+    const void *dwl_inst;
+} AVVSVDeviceContext;
+
+typedef enum AVVSVFormat {
+    AVVSV_FORMAT_YUV420_SEMIPLANAR,
+} AVVSVFormat;
+
+/**
+ * VAAPI-specific data associated with a frame pool.
+ *
+ * Allocated as AVHWFramesContext.hwctx.
+ */
+typedef struct AVVSVFramesContext {
+    int task_id;
+    struct {
+        int enabled;
+        AVVSVFormat format;
+        int width;
+        int height;
+        struct {
+            int enabled;
+            int x;
+            int y;
+            int w;
+            int h;
+        } crop;
+        struct {
+            int enabled;
+            int w;
+            int h;
+        } scale;
+    } pic_info[5];
+// #ifndef ESW_FF_ENHANCEMENT
+//     struct DWLLinearMem* buffer;
+// #endif
+} AVVSVFramesContext;
+
+typedef struct VSVFramePriv {
+    int pp_sel;
+} VSVFramePriv;
+
+#endif
+
+
diff --git a/libavutil/hwcontext_internal.h b/libavutil/hwcontext_internal.h
index e6266494ac..2ab240dcd6 100644
--- a/libavutil/hwcontext_internal.h
+++ b/libavutil/hwcontext_internal.h
@@ -174,5 +174,6 @@ extern const HWContextType ff_hwcontext_type_vdpau;
 extern const HWContextType ff_hwcontext_type_videotoolbox;
 extern const HWContextType ff_hwcontext_type_mediacodec;
 extern const HWContextType ff_hwcontext_type_vulkan;
+extern const HWContextType ff_hwcontext_type_es;
 
 #endif /* AVUTIL_HWCONTEXT_INTERNAL_H */
diff --git a/libavutil/pixdesc.c b/libavutil/pixdesc.c
index 6e57a82cb6..ade9f830a8 100644
--- a/libavutil/pixdesc.c
+++ b/libavutil/pixdesc.c
@@ -2491,6 +2491,120 @@ static const AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = {
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
+    [AV_PIX_FMT_ES] = {
+        .name = "es",
+        .flags = AV_PIX_FMT_FLAG_HWACCEL,
+    },
+// ESW_FF_ENHANCEMENT
+    [AV_PIX_FMT_B16G16R16I] = {
+        .name = "b16g16r16i",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 6, 4, 0, 16 },       /* R */
+            { 0, 6, 2, 0, 16 },       /* G */
+            { 0, 6, 0, 0, 16 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB,
+    },
+    [AV_PIX_FMT_B16G16R16I_PLANAR] = {
+        .name = "b16g16r16i_p",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 2, 2, 0, 0, 16 },       /* R */
+            { 1, 2, 0, 0, 16 },       /* G */
+            { 0, 2, 0, 0, 16 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
+    },
+    [AV_PIX_FMT_B8G8R8_PLANAR] = {
+        .name = "bgr24_p",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 2, 1, 0, 0, 8 },        /* R */
+            { 1, 1, 0, 0, 8 },        /* G */
+            { 0, 1, 0, 0, 8 },        /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
+    },
+    [AV_PIX_FMT_B8G8R8I] = {
+        .name = "bgr24i",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 3, 2, 0, 8 },        /* R */
+            { 0, 3, 1, 0, 8 },        /* G */
+            { 0, 3, 0, 0, 8 },        /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB,
+    },
+    [AV_PIX_FMT_B8G8R8I_PLANAR] = {
+        .name = "bgr24i_p",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 2, 1, 0, 0, 8 },        /* R */
+            { 1, 1, 0, 0, 8 },        /* G */
+            { 0, 1, 0, 0, 8 },        /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB,
+    },
+    [AV_PIX_FMT_B16G16R16F] = {
+        .name = "b16g16r16f",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 6, 4, 0, 16 },       /* R */
+            { 0, 6, 2, 0, 16 },       /* G */
+            { 0, 6, 0, 0, 16 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_B16G16R16F_PLANAR] = {
+        .name = "b16g16r16f_p",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 2, 2, 0, 0, 16 },       /* R */
+            { 1, 2, 0, 0, 16 },       /* G */
+            { 0, 2, 0, 0, 16 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_B32G32R32F] = {
+        .name = "b32g32r32f",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 12, 8, 0, 32 },       /* R */
+            { 0, 12, 4, 0, 32 },       /* G */
+            { 0, 12, 0, 0, 32 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_B32G32R32F_PLANAR] = {
+        .name = "b32g32r32f_p",
+        .nb_components = 3,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 2, 4, 0, 0, 32 },       /* R */
+            { 1, 4, 0, 0, 32 },       /* G */
+            { 0, 4, 0, 0, 32 },       /* B */
+        },
+        .flags = AV_PIX_FMT_FLAG_PLANAR | AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_FLOAT,
+    },
+// ESW_FF_ENHANCEMENT END
 };
 
 static const char * const color_range_names[] = {
diff --git a/libavutil/pixfmt.h b/libavutil/pixfmt.h
index 2d3927cc3f..adfb83d730 100644
--- a/libavutil/pixfmt.h
+++ b/libavutil/pixfmt.h
@@ -367,6 +367,20 @@ enum AVPixelFormat {
     AV_PIX_FMT_P416BE,      ///< interleaved chroma YUV 4:4:4, 48bpp, big-endian
     AV_PIX_FMT_P416LE,      ///< interleaved chroma YUV 4:4:4, 48bpp, little-endian
 
+// ESW_FF_ENHANCEMENT
+    AV_PIX_FMT_B16G16R16I,        // only be used in convert_es filter and es-umd filter
+    AV_PIX_FMT_B16G16R16I_PLANAR, // only be used in convert_es filter and es-umd filter
+    AV_PIX_FMT_B8G8R8_PLANAR,     // only be used in convert_es filter and es-umd filter
+    AV_PIX_FMT_B8G8R8I,           // only be used in convert_es filter and es-umd filter
+    AV_PIX_FMT_B8G8R8I_PLANAR,    // only be used in convert_es filter and es-umd filter
+    AV_PIX_FMT_B16G16R16F,        // only be used in convert_es filter and es-umd filter
+    AV_PIX_FMT_B16G16R16F_PLANAR, // only be used in convert_es filter and es-umd filter
+    AV_PIX_FMT_B32G32R32F,        // only be used in convert_es filter and es-umd filter
+    AV_PIX_FMT_B32G32R32F_PLANAR, // only be used in convert_es filter and es-umd filter
+// ESW_FF_ENHANCEMENT END
+
+    AV_PIX_FMT_ES,       ///< HW acceleration through VeriSilicon ES VPU
+
     AV_PIX_FMT_NB         ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
-- 
2.40.1

